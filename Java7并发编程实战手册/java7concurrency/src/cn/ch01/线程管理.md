线程管理
========

- 线程的创建和运行  
- 线程信息的获取和设置  
- 线程的中断  
- 线程中断的控制  
- 线程的休眠和恢复  
- 等待线程的终止  
- 守护线程的创建和运行  
- 线程中不可控异常的处理  
- 线程局部变量的使用  
- 线程的分组  
- 线程组中不可控异常的处理  
- 使用工厂类创建线程  

### 1 简介
在计算机领域中，我们说的并发(Concurrency) 是指一系列任务的同时运行。如果一
台电脑有多个处理器或者有一个多核处理器，这个同时性(Simultaneity) 是真正意义的并
发;但是一台电脑只有一个单核处理器，这个同时性并不是真正的并发  

同时打开不同程序是进程级（Process-Level)并发  
一个进程内也可以同时进行多个任务，进程内并发任务成为线程（Thread）

与并发相关的另-个概念是并行(Parallelism)  

一些学者认为并发是在单核处理器中使用多线程执行应用，与此同时你看到
的程序执行只是表面的；相应的，他们认为并行是在多核处理器中使用多线程执行应用，
这里的多核处理器可以是一个多核处理器，也可以是同一台电脑上的多个处理器  

另一些学者认为并发执行应用的线程是非顺序执行的，相应的，他们认为并行是使用很多线程去
简化问题，这些线程是按预定顺序执行的  


### 2 线程的创建和运行
1. 继承Thread类，并且覆盖run(方法  
2. 创建一个实现Runnable接口的类。使用带参数的Thread构造器来创建Thread对象。这个参数就是实现Runnable接口的类的一个对象

### 3 线程信息的获取和设置
Thread类有一些保存信息的属性，比如可以用来：   
1. 标识线程  
2. 显示线程的状态  
3. 控制线程的优先级   
  
- ID: 保存了线程的唯一标示符  
- Name: 保存了线程名称  
- Priority: 保存了线程对象的优先级。线程的优先级是从1到10,其中1是最低优先级;
10是最高优先级  
- Status: 保存了线程的状态。在Java中，线程的状态有6种: new、 runnable、 blocked、
waiting、time waiting或者terminated  

### 4 线程的中断
Java提供了中断机制，我们可以使用它来结束一个线程。这种机制要求线程检查它是
否被中断了，然后决定是不是响应这个中断请求。线程允许忽略中断请求并且继续执行

### 5 线程中断的控制
如果线程实现了复杂的算法并且分布在几个方法中，或者线程里有递归调用的方法，我们
就得使用一个更好的机制来控制线程的中断。为了达到这个目的，Java 提供了
InterruptedException异常。当检查到线程中断的时候，就抛出这个异常，然后在run()中捕
获并处理这个异常

### 6 线程的休眠和恢复
有些时候，需要在某一个预期的时间中断线程的执行。例如，程序的一个线程每隔一分钟检查一次传感器状态，其余时间什么都不做。
在这段空闲时间，线程不占用计算机的任何资源。当它继续执行的CPU时钟来临时，
JVM会选中它继续执行。可以通过线程的sleep()方 法来达到这个目标  

sleep()方法接受整型数值作为参数，以表明线程挂起执行的毫秒数。当线程休眠的时间结束了，
JVM会分给它CPU时钟，线程将继续执行它的指令  

sleep()方法的另一种使用方式是通过TimeUnit枚举类元素进行调用。这个方法也使
用Thread类的sleep()方法来使当前线程休眠，但是它接收的参数单位是秒，最后会被转化成毫秒

### 7 等待线程的终止
在一些情形下，我们必须等待线程的终止。例如，我们的程序在执行其他的任务时，必须先初始化一些必须的资源。
可以使用线程来完成这些初始化任务，等待线程终止，再执行程序的其他任务。
为了达到这个目的，我们使用Thread类的join()方法。当一个线程对象的join()方法被
调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务  
相当于当前线程，让别的线程加入到它之前去执行，让别的线程执行完，再轮到自己执行

### 8 守护线程的创建和运行
Java里有一种特殊的线程叫做守护(Daemon)线程。这种线程的优先级很低，通常来
说，当同一个应用程序里没有其他的线程运行的时候，守护线程才运行。当守护线程是程;
序中唯一运行的线程时，守护线程执行结束后，JVM也就结束了这个程序  

因为这种特性，守护线程通常被用来做为同一程序中普通线程(也称为用户线程)的
服务提供者。它们通常是无限循环的，以等待服务请求或者执行线程的任务。它们不能做
重要的工作，因为我们不可能知道守护线程什么时候能够获取CPU时钟，并且，在没有其
他线程运行的时候，守护线程随时可能结束。一个典型的守护线程是Java的垃圾回收器
(Garbage Collector)

### 9 线程中不可控异常的处理
在Java中有两种异常  
- 非运行时异常( Checked Exception):  
    这种异常必须在方法声明的throws语句指定，或者在方法体内捕获。例如: IOException 和ClassNotFoundException  
- 运行时异常(Unchecked Exception):  
    这种异常不必在方法声明中指定，也不需要在方法体中捕获。例如: NumberFormatException  

因为run()方法不支持throws语句，所以当线程对象的run()方法抛出非运行异常时，
我们必须捕获并且处理它们。当运行时异常从run()方法中抛出时，默认行为是在控制台输
出堆栈记录并且退出程序

### 10 线程局部变量的使用
共享数据是并发程序最核心的问题之一，对于继承了Thread类或者实现了Runnable接口的对象来说尤其重要

如果创建的对象是实现了Runnable接口的类的实例，用它作为传入参数创建多个线程
对象并启动这些线程，那么所有的线程将共享相同的属性。也就是说，如果你在一个线程
中改变了一个属性，所有线程都会被这个改变影响。在某种情况下，这个对象的属性不需要被所有线程共享

Java并发API提供了一个干净的机制，即线程局部变量(Thread-LocalVariable)，其具有很好的性能。

### 11 线程的分组
Java并发API提供了一个有趣的功能，它能够把线程分组。这允许我们把一个组的线
程当成一个单一的单元，对组内线程对象进行访问并操作它们。例如，对于一些执行同样
任务的线程，你想控制它们，不管多少线程在运行，只需要一个单一的调用， 所有这些线
程的运行都会被中断

Java提供ThreadGroup类表示一组线程。线程组可以包含线程对象，也可以包含其他
的线程组对象，它是一个树形结构

### 12 线程中不可控异常的处理
提供应用程序中对错误情景的管理，是编程语言很重要的一面。和几乎所有的现代编
程语言一样，Java 语言也实现了通过异常管理机制来处理错误情景，它提供了很多类来表
示不同的错误。当错误情景发生时，Java 类将抛出这些异常。你可以使用这些异常，或者
实现自己的异常，来管理类中的错误

Java也提供了捕获和处理这些异常的机制。有的异常必须被捕获，或者必须使用方法
的throws声明再次抛出，这类异常叫做非运行时异常。还有一类异常叫做运行时异常，
它们不需要被捕获或者声明抛出

另一种可行的做法是，建立一个方法来捕获线程组中的任何线程对象抛出的非捕获异常


