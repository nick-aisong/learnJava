并发集合
========

- 使用非阻塞式线程安全列表
- 使用阻塞式线程安全列表
- 使用按优先级排序的阻塞式线程安全列表
- 使用带有延迟元素的线程安全列表
- 使用线程安全可遍历映射
- 生成并发随机数
- 使用原子变量
- 使用原子数组

### 1 简介
数据结构(Data Structure)是编程中的基本元素，几乎每个程序都使用一种或多种数据结构来存储和管理数据。
Java API提供了包含接口、类和算法的Java集合框架(Java Collection Framework)，它实现了可用在程序中的大量数据结构。
当需要在并发程序中使用数据集合时，必须要谨慎地选择相应的实现方式。
大多数集合类不能直接用于并发应用，因为它们没有对本身数据的并发访问进行控制。
如果一些并发任务共享了一个不适用于并发任务的数据结构，将会遇到数据不一致的错误，并将影响程序的准确运行。
这类数据结构的一个例子是ArrayList类。

Java提供了一些可以用于并发程序中的数据集合，它们不会引起任何问题。
一般来说，Java提供了两类适用于并发应用的集合
- 阻塞式集合(Blocking Collection)：这类集合包括添加和移除数据的方法。
当集合已满或为空时，被调用的添加或者移除方法就不能立即被执行，那么调用这个方法的线程将被阻塞，一直到该方法可以被成功执行
- 非阻塞式集合(Non-Blocking Collection):这类集合也包括添加和移除数据的方法。
如果方法不能立即被执行，则返回null或抛出异常，但是调用这个方法的线程不会被阻塞

可以在并发应用中使用一些Java集合
- 非阻塞式列表对应的实现类: ConcurrentLinkedDeque类
- 阻塞式列表对应的实现类: LinkedBlockingDeque类
- 用于数据生成或消费的阻塞式列表对应的实现类: LinkedTransferQueue类
- 按优先级排序列表元素的阻塞式列表对应的实现类: PriorityBlockingQueue类
- 带有延迟列表元素的阻塞式列表对应的实现类: DelayQueue类
- 非阻塞式可遍历映射对应的实现类: ConcurrentSkipListMap类
- 随机数字对应的实现类: ThreadLocalRandom类
- 原子变量对应的实现类: AtomicLong和AtomicIntegerArray类

### 2 使用非阻塞式线程安全列表
最基本的集合类型是列表(List)。
一个列表包含的元素数量不定，可以在任何位置添加、读取或移除元素。
并发列表允许不同的线程在同一时间添加或移除列表中的元素，而不会造成数据不一致。
在本节，将会学到如何在并发程序中使用非阻塞式列表。
非阻塞式列表提供了一些操作，如果被执行的操作不能够立即运行(例如，在列表为空时，从列表取出一个元素)，方法会抛出异常或返回null。
Java 7引入了ConcurrentLinkedDeque类来实现非阻塞式并发列表

### 3 使用阻塞式线程安全列表
最基本的集合类型是列表。一个列表包含的元素数量不定，可以在任何位置添加、读取或移除元素。
并发列表允许不同的线程在同一时间添加或移除列表中的元素，而不会造成数据不一致。
阻塞式列表与非阻塞式列表的主要差别是：阻塞式列表在插入和删除操作时，如果列表已满或为空，操作不会被立即执行，而是将调用这个操作的线程阻塞队列直到操作可以执行成功。
Java引入了LinkedBlockingDeque类来实现阻塞式列表

### 4 使用按优先级排序的阻塞式线程安全列表
数据结构应用中的一个经典需求是实现一个有序列表。
Java引入了PriorityBlockingQueue类来满足这类需求。
所有添加进PriorityBlockingQueue的元素必须实现Comparable接口。
这个接口提供了compareTo()方法，它的传入参数是一个同类型的对象。
这样就有了两个同类型的对象并且相互比较：其中一个是执行这个方法的对象，另一个是参数传入的对象。
这个方法必须返回一个数字值，如果当前对象小于参数传入的对象，那么返回一个小于0的值；
如果当前对象大于参数传入的对象，那么返回一个大于0的值；如果两个对象相等就返回0。
当插入元素时，PriorityBlockingQueue使用compareTo()方法来决定插入元素的位置。元素越大越靠后。

PriorityBlockingQueue的另一个重要的特性是：它是阻塞式数据结构(BlockingDataStructure)。
当它的方法被调用并且不能立即执行时，调用这个方法的线程将被阻塞直到方法执行成功

### 5 使用带有延迟元素的线程安全列表
JavaAPI提供了一种用于并发应用的有趣的数据结构，即DelayQueue类。
这个类可以存放带有激活日期的元素。当调用方法从队列中返回或提取元素时，未来的元素日期将被忽略。
这些元素对于这些方法是不可见的。
为了具有调用行为，存放到DelayQueue类中的元素必须继承Delayed接口。
Delayed接口使对象成为延迟对象，它使存放在DelayQueue类中的对象具有了激活日期，即到激活日期的时间

该接口强制执行下列两个方法
- compareTo(Delayed o)：Delayed接口继承了Comparable接口，因此有了这个方法。
如果当前对象的延迟值小于参数对象的值，将返回一个小于0的值；如果当前对象的延迟值大于参数对象的值，将返回一个大于0的值；如果两者的延迟值相等则返回0
- getDelay(TimeUnit unit):这个方法返回到激活日期的剩余时间，单位由单位参数指定

TimeUnit类是一个由下列常量组成的枚举类型: DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS

### 6 使用线程安全可遍历映射
Java API还提供了一种用于并发应用程序中的有趣数据结构，即ConcurrentNavigableMap接口及其实现类。
实现这个接口的类以如下两部分存放元素：
- 一个键值(Key)，它是元素的标识并且是唯一的
- 元素其他部分数据

每一个组成部分都必须在不同的类中实现。
Java API也提供了一个实现ConcurrentSkipListMap接口的类，ConcurrentSkipListMap接口实现了与ConcurrentNavigableMap接口有相同行为的一个非阻塞式列表。
从内部实现机制来讲，它使用了一个SkipList来存放数据。
SkipList是基于并发列表的数据结构，效率与二叉树相近。有了它，就有了一个数据结构，比有序列表在添加、搜索或删除元素时耗费更少的访问时间。

备注: Skip List由William Pugh在1990 年引入，详见```http://www.cs.umd.edu/~pugh```

当你插入元素到映射中时，ConcurrentSkipListMap接口类使用键值来排序所有元素。
除了提供返回一个具体元素的方法之外，这个类也提供获取子映射的方法

### 7 生成并发随机数
Java并发API提供了一个特殊类用以在并发程序中生成伪随机数(Pseudo-RandomNumber)，即Java 7新引入的ThreadLocalRandom类。
它是线程本地变量。每个生成随机数的线程都有一个不同的生成器，但是都在同一个类中被管理，对程序员来讲是透明的。
相比于使用共享的Random对象为所有线程生成随机数，这种机制具有更好的性能

### 8 使用原子变量





