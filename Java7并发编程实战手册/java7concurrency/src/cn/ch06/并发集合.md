并发集合
========

- 使用非阻塞式线程安全列表
- 使用阻塞式线程安全列表
- 使用按优先级排序的阻塞式线程安全列表
- 使用带有延迟元素的线程安全列表
- 使用线程安全可遍历映射
- 生成并发随机数
- 使用原子变量
- 使用原子数组

### 1 简介
数据结构(Data Structure)是编程中的基本元素，几乎每个程序都使用一种或多种数据结构来存储和管理数据。
Java API提供了包含接口、类和算法的Java集合框架(Java Collection Framework)，它实现了可用在程序中的大量数据结构。
当需要在并发程序中使用数据集合时，必须要谨慎地选择相应的实现方式。
大多数集合类不能直接用于并发应用，因为它们没有对本身数据的并发访问进行控制。
如果一些并发任务共享了一个不适用于并发任务的数据结构，将会遇到数据不一致的错误，并将影响程序的准确运行。
这类数据结构的一个例子是ArrayList类。

Java提供了一些可以用于并发程序中的数据集合，它们不会引起任何问题。
一般来说，Java提供了两类适用于并发应用的集合
- 阻塞式集合(Blocking Collection)：这类集合包括添加和移除数据的方法。
当集合已满或为空时，被调用的添加或者移除方法就不能立即被执行，那么调用这个方法的线程将被阻塞，一直到该方法可以被成功执行
- 非阻塞式集合(Non-Blocking Collection):这类集合也包括添加和移除数据的方法。
如果方法不能立即被执行，则返回null或抛出异常，但是调用这个方法的线程不会被阻塞

可以在并发应用中使用一些Java集合
- 非阻塞式列表对应的实现类: ConcurrentLinkedDeque类
- 阻塞式列表对应的实现类: LinkedBlockingDeque类
- 用于数据生成或消费的阻塞式列表对应的实现类: LinkedTransferQueue类
- 按优先级排序列表元素的阻塞式列表对应的实现类: PriorityBlockingQueue类
- 带有延迟列表元素的阻塞式列表对应的实现类: DelayQueue类
- 非阻塞式可遍历映射对应的实现类: ConcurrentSkipListMap类
- 随机数字对应的实现类: ThreadLocalRandom类
- 原子变量对应的实现类: AtomicLong和AtomicIntegerArray类

### 2 使用非阻塞式线程安全列表
最基本的集合类型是列表(List)。
一个列表包含的元素数量不定，可以在任何位置添加、读取或移除元素。
并发列表允许不同的线程在同一时间添加或移除列表中的元素，而不会造成数据不一致。
在本节，将会学到如何在并发程序中使用非阻塞式列表。
非阻塞式列表提供了一些操作，如果被执行的操作不能够立即运行(例如，在列表为空时，从列表取出一个元素)，方法会抛出异常或返回null。
Java 7引入了ConcurrentLinkedDeque类来实现非阻塞式并发列表

### 3 使用阻塞式线程安全列表
最基本的集合类型是列表。一个列表包含的元素数量不定，可以在任何位置添加、读取或移除元素。
并发列表允许不同的线程在同一时间添加或移除列表中的元素，而不会造成数据不一致。
阻塞式列表与非阻塞式列表的主要差别是：阻塞式列表在插入和删除操作时，如果列表已满或为空，操作不会被立即执行，而是将调用这个操作的线程阻塞队列直到操作可以执行成功。
Java引入了LinkedBlockingDeque类来实现阻塞式列表

### 4 使用按优先级排序的阻塞式线程安全列表
数据结构应用中的一个经典需求是实现一个有序列表。
Java引入了PriorityBlockingQueue类来满足这类需求。
所有添加进PriorityBlockingQueue的元素必须实现Comparable接口。
这个接口提供了compareTo()方法，它的传入参数是一个同类型的对象。
这样就有了两个同类型的对象并且相互比较：其中一个是执行这个方法的对象，另一个是参数传入的对象。
这个方法必须返回一个数字值，如果当前对象小于参数传入的对象，那么返回一个小于0的值；
如果当前对象大于参数传入的对象，那么返回一个大于0的值；如果两个对象相等就返回0。
当插入元素时，PriorityBlockingQueue使用compareTo()方法来决定插入元素的位置。元素越大越靠后。

PriorityBlockingQueue的另一个重要的特性是：它是阻塞式数据结构(BlockingDataStructure)。
当它的方法被调用并且不能立即执行时，调用这个方法的线程将被阻塞直到方法执行成功

### 5 使用带有延迟元素的线程安全列表
JavaAPI提供了一种用于并发应用的有趣的数据结构，即DelayQueue类。
这个类可以存放带有激活日期的元素。当调用方法从队列中返回或提取元素时，未来的元素日期将被忽略。
这些元素对于这些方法是不可见的。
为了具有调用行为，存放到DelayQueue类中的元素必须继承Delayed接口。
Delayed接口使对象成为延迟对象，它使存放在DelayQueue类中的对象具有了激活日期，即到激活日期的时间

该接口强制执行下列两个方法
- compareTo(Delayed o)：Delayed接口继承了Comparable接口，因此有了这个方法。
如果当前对象的延迟值小于参数对象的值，将返回一个小于0的值；如果当前对象的延迟值大于参数对象的值，将返回一个大于0的值；如果两者的延迟值相等则返回0
- getDelay(TimeUnit unit):这个方法返回到激活日期的剩余时间，单位由单位参数指定

TimeUnit类是一个由下列常量组成的枚举类型: DAYS、HOURS、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDS和SECONDS

### 6 使用线程安全可遍历映射
Java API还提供了一种用于并发应用程序中的有趣数据结构，即ConcurrentNavigableMap接口及其实现类。
实现这个接口的类以如下两部分存放元素：
- 一个键值(Key)，它是元素的标识并且是唯一的
- 元素其他部分数据

每一个组成部分都必须在不同的类中实现。
Java API也提供了一个实现ConcurrentSkipListMap接口的类，ConcurrentSkipListMap接口实现了与ConcurrentNavigableMap接口有相同行为的一个非阻塞式列表。
从内部实现机制来讲，它使用了一个SkipList来存放数据。
SkipList是基于并发列表的数据结构，效率与二叉树相近。有了它，就有了一个数据结构，比有序列表在添加、搜索或删除元素时耗费更少的访问时间。

备注: Skip List由William Pugh在1990 年引入，详见```http://www.cs.umd.edu/~pugh```

当你插入元素到映射中时，ConcurrentSkipListMap接口类使用键值来排序所有元素。
除了提供返回一个具体元素的方法之外，这个类也提供获取子映射的方法

### 7 生成并发随机数
Java并发API提供了一个特殊类用以在并发程序中生成伪随机数(Pseudo-RandomNumber)，即Java 7新引入的ThreadLocalRandom类。
它是线程本地变量。每个生成随机数的线程都有一个不同的生成器，但是都在同一个类中被管理，对程序员来讲是透明的。
相比于使用共享的Random对象为所有线程生成随机数，这种机制具有更好的性能

### 8 使用原子变量
原子变量(Atomic Variable)是从Java 5开始引入的，它提供了单个变量上的原子操作。
在编译程序时，Java代码中的每个变量、每个操作都将被转换成机器可以理解的指令。
例如，当给一个变量赋值时，在Java代码中只使用一个指令，但是编译这个程序时，指令被转换成JVM语言中的不同指令。
当多个线程共享同一个变量时，就会发生数据不一致的错误

为了避免这类错误，Java 引入了原子变量。当一个线程在对原子变量操作时，如果其他线程也试图对同一原子变量执行操作，原子变量的实现类提供了一套机制来检查操作是否在一步内完成。
一般来说，这个操作先获取变量值，然后在本地改变变量的值，然后试图用这个改变的值去替换之前的值。
如果之前的值没有被其他线程改变，就可以执行这个替换操作。
否则，方法将再执行这个操作。这种操作称为CAS原子操作(Compare and Set)

原子变量不使用锁或其他同步机制来保护对其值的并发访问。
所有操作都是基于CAS原子操作的。它保证了多线程在同一时间操作一个原子变量而不会产生数据不一致的错误，并且它的性能优于使用同步机制保护的普通变量

### 9 使用原子数组
当实现一个并发应用时，将不可避免地会有多线程共享一个或多个对象的现象，为了避免数据不一致错误，需要使用同步机制(如锁或synchronized关键字)来保护对这些共享属性的访问

但是，这些同步机制存在下列问题  
- 死锁：一个线程被阻塞，并且试图获得的锁正被其他线程使用，但其他线程永远不会释放这个锁。这种情况使得应用不会继续执行，并且永远不会结束
- 即使只有一个线程访问共享对象，它仍然需要执行必须的代码来获取和释放锁

针对这种情况，为了提供更优的性能，Java于是引入了比较和交换操作(Compare-and-Swap Operation)

这个操作使用以下三步修改变量的值  
- 1.取得变量值，即变量的旧值  
- 2.在一个临时变量中修改变量值，即变量的新值  
- 3.如果上面获得的变量旧值与当前变量值相等，就用新值替换旧值  

如果已有其他线程修改了这个变量的值，上面获得的变量的旧值就可能与当前变量值不同。
采用比较和交换机制不需要使用同步机制，不仅可以避免死锁并且性能更好。
Java在原子变量(Atomic Variable)中实现了这种机制。
这些变量提供了实现比较和交换操作的compareAndSet()方法，其他方法也基于它展开。
Java也引入了原子数组(Atomic Array)提供对integer或long数字数组的原子操作
