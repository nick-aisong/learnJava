线程执行器
========

- 创建线程执行器
- 创建固定大小的线程执行器
- 在执行器中执行任务并返回结果
- 运行多个任务并处理第一个结果
- 运行多个任务并处理所有结果
- 在执行器中延时执行任务
- 在执行器中周期性执行任务
- 在执行器中取消任务
- 在执行器中控制任务的完成
- 在执行器中分离任务的启动与结果的处理
- 处理在执行器中被拒绝的任务

### 1 简介
通常，使用Java来开发一个简单的并发应用程序时，会创建一些Runnable对象，然后创建对应的Thread对象来执行它们。
但是，如果需要开发一个程序来运行大量的并发任务，这个方法将突显以下劣势:
- 必须实现所有与Thread对象管理相关的代码，比如线程的创建、结束以及结果获取
- 需要为每一个任务创建一个Thread对象。如果需要执行大量的任务，这将大大地影响应用程序的处理能力
- 计算机的资源需要高效地进行控制和管理，如果创建过多的线程，将会导致系统负荷过重

自从Java5开始，Java并发API提供了一套意在解决这些问题的机制。
这套机制称之为执行器框架(ExecutorFramework)，围绕着Executor接口和它的子接口ExecutorService，以及实现这两个接口的ThreadPoolExecutor类展开。

这套机制分离了任务的创建和执行。通过使用执行器，仅需要实现Runnable接口的对象，然后将这些对象发送给执行器即可。
执行器通过创建所需的线程，来负责这些Runnable对象的创建、实例化以及运行。但是执行器功能不限于此，它使用了线程池来提高应用程序的性能。
当发送一个任务给执行器时，执行器会尝试使用线程池中的线程来执行这个任务，避免了不断地创建和销毁线程而导致系统性能下降。
执行器框架另一个重要的优势是Callable接口。它类似于Runnable接口，但是却提供了两方面的增强。
这个接口的主方法名称为call() ，可以返回结果。
当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象。
可以使用这个对象来控制Callable对象的状态和结果

### 2 创建线程执行器
使用执行器框架(Executor Framework)的第一步是创建ThreadPoolExecutor对象。
可以ThreadPoolExecutor类提供的四个构造器或者使用Executors工厂类来创建ThreadPoolExecutor对象。
一旦有了执行器，就可以将Runnable或Callable对象发送给它去执行了

### 3 创建固定大小的线程执行器
当使用Executors类的newCachedThreadPool()方法创建基本的ThreadPoolExecutor时，执行器运行过程中将碰到线程数量的问题。
如果线程池里没有空闲的线程可用，那么执行器将为接收到的每一个任务创建一个新线程，当发送大量的任务给执行器并且任务需要持续较长的时间时，系统将会超负荷，应用程序也将随之性能不佳。
为了避免这个问题，Executors工厂类提供了一个方法来创建一个固定大小的线程执行器。这个执行器有一个线程数的最大值，如果发送超过这个最大值的任务给执行器，执行器将不再创建额外的线程，剩下的任务将被阻塞直到执行器有空闲的线程可用。
这个特性可以保证执行器不会给应用程序带来性能不佳的问题

### 4 在执行器中执行任务并返回结果
执行器框架(Executor Framework)的优势之一是，可以运行并发任务并返回结果。
Java并发API通过以下两个接口来实现这个功能。
Callable:这个接口声明了call()方法。可以在这个方法里实现任务的具体逻辑操作。
Callable接口是一个泛型接口，这就意味着必须声明call()方法返回的数据类型。
Future:这个接口声明了一些方法来获取由Callable对象产生的结果，并管理它们的状态

### 5 运行多个任务并处理第一个结果
并发编程比较常见的一个问题是，当采用多个并发任务来解决一个问题时，往往只关心这些任务中的第-一个结果。
比如，对一个数组进行排序有很多种算法，可以并发启动所有算法，但是对于一个给定的数组，第一个得到排序结果的算法就是最快的排序算法

### 6 运行多个任务并处理所有结果
执行器框架(Executor Framework)允许执行并发任务而不需要去考虑线程创建和执行。
它还提供了可以用来控制在执行器中执行任务的状态和获取任务运行结果的Future类。

如果想要等待任务结束，可以使用如下两种方法：
- 如果任务执行结束，那么Future接口的isDone()方法将返回true
- 在调用shutdown()方法后，ThreadPoolExecutor类的awaitTermination()方法会将线程休眠，直到所有的任务执行结束

这两个方法有一些缺点：
第一个方法，仅可以控制任务的完成与否
第二个方法，必须关闭执行器来等待一个线程，否则调用这个方法线程将立即返回

ThreadPoolExecutor类还提供一个方法，它允许发送一个任务列表给执行器，并等待列表中所有任务执行完成


