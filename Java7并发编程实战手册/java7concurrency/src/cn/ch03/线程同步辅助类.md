线程同步辅助类
========

- 资源的并发访问控制
- 资源的多副本的并发访问控制
- 等待多个并发事件的完成
- 在集合点的同步
- 并发阶段任务的运行
- 并发阶段任务中的阶段切换
- 并发任务间的数据交换

### 1 简介
使用高级的同步机制来实现多线程间的同步  
- 信号量(Semaphore):是一种计数器，用来保护一个或者多个共享资源的访问。它是并发编程的一种基础工具，大多数编程语言都提供了这个机制
- CountDownLatch:是Java语言提供的同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许线程一直等待
- CyclicBarrier:也是Java语言提供的同步辅助类，它允许多个线程在某个集合点(common point)处进行相互等待
- Phaser:也是Java语言提供的同步辅助类。它把并发任务分成多个阶段运行，在开始下一阶段之前，当前阶段中的所有线程都必须执行完成，这是Java7 API中的新特性
- Exchanger:也是Java语言提供的同步辅助类。它提供了两个线程之间的数据交换点

在应用程序中，任何时候都可以使用Semaphore来保护临界区，因为它是一个基础的同步机制。
而其他的同步机制，则需要根据各自的上述特性来对其选择使用。所以我们需要根据应用程序的特性来选择合适的同步机制

### 2 资源的并发访问控制
Java语言提供了信号量(Semaphore)机制。信号量是一种计数器，用来保护一个或者多个共享资源的访问。
如果线程要访问一个共享资源，它必须先获得信号量。如果信号量的内部计数器大于0，信号量将减1，然后允许访问这个共享资源。
计数器大于0意味着有可以使用的资源，因此线程将被允许使用其中一个资源。
否则，如果信号量的计数器等于0，信号量将会把线程置入休眠直至计数器大于0。
计数器等于0的时候意味着所有的共享资源已经被其他线程使用了，所以需要访问这个共享资源的线程必须等待。
当线程使用完某个共享资源时，信号量必须被释放，以便其他线程能够访问共享资源。
释放操作将使信号量的内部计数器增加1

### 3 资源的多副本的并发访问控制
Semaphore信号量可以保护对单一共享资源，或者单一临界区的访问，从而使得保护的资源在同一个时间内只能被一个线程访问。
然而，信号量也可以用来保护一个资源的多个副本，或者被多个线程同时执行的临界区

### 4 等待多个并发事件的完成
Java并发API提供了CountDownLatch类，它是一个同步辅助类。
在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。
这个类使用一个整数进行初始化，这个整数就是线程要等待完成的操作的数目。
当一个线程要等待某些操作先执行完时，需要调用await()方法，这个方法让线程进入休眠直到等待的所有操作都完成。
当某一个操作完成后，它将调用countDown()方法将CountDownLatch类的内部计数器减1。
当计数器变成0 的时候，CountDownLatch类将唤醒所有调用await()方法而进入休眠的线程。

### 5 在集合点的同步
Java并发API提供了CyclicBarrier类，它也是一个同步辅助类。它允许两个或者多个线程在某个点上进行同步。
这个类与，上一节所讲述的CountDownLatch类类似，但也有不同之处，使之成为更强大的类。
CyclicBarrier类使用一个整型数进行初始化,这个数是需要在某个点上同步的线程数

当一个线程到达指定的点后，它将调用await()方 法等待其他的线程。当线程调用await()
方法后，CyclicBarrier类将阻塞这个线程并使之休眠直到所有其他线程到达。当最后一个
线程调用CyclicBarrier类的await()方法时，CyclicBarrier对象将唤醒所有在等待的线程，
然后这些线程将继续执行

CyclicBarrier类有一个很有意义的改进，即它可以传入另一个Runnable 对象作为初
始化参数。当所有的线程都到达集合点后，CyclicBarrier类将这个Runnable对象作为线
程执行。这个特性使得这个类在并行任务上可以媲美分治编程技术(DivideandConquer
Programming Technique)

### 6 并发阶段任务的运行
Java并发API还提供了一个更复杂、更强大的同步辅助类，即Phaser，它允许执行并发多阶段任务。
当我们有并发任务并且需要分解成几步执行时，这种机制就非常适用。
Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才允许执行下一步。
跟其他同步工具一样，必须对Phaser类中参与同步操作的任务数进行初始化，不同的是，我们可以动态地增加或者减少任务数。

### 7 并发阶段任务中的阶段切换
Phaser类提供了onAdvance()方法，它在phaser阶段改变的时候会被自动执行。
onAdvance()方法需要两个int型的传入参数：当前的阶段数以及注册的参与者数量
它返回的是boolean值，如果返回false表示phaser在继续执行，返回true表示phaser已经完成执行并且进入了终止态。
这个方法默认实现如下：如果注册的参与者数量是0就返回true,否则就返回false。
但是我们可以通过继承Phaser类覆盖这个方法。一般来说，当必须在从一个阶段到另一个阶段过渡的时候执行一些操作，那么我们就得这么做

### 8 并发任务间的数据交换
Java并发API还提供了一个同步辅助类，它就是Exchanger，它允许在并发任务之间交换数据。
具体来说，Exchanger类允许在两个线程之间定义同步点(SynchronizationPoint)。
当两个线程都到达同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程中。
Exchanger类在生产者消费者问题情境中很有用。这是一个经典的并发场景，包含一个数据缓冲区，一个或者多个数据生产者，一个或者多个数据消费者。
Exchanger 类只能同步两个线程，如果有类似的只有一个生产者和消费者的问题，就可以使用Exchanger类