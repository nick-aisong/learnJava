线程同步基础
========

- 使用synchronized实现同步方法
- 使用非依赖属性实现同步
- 在同步代码块中使用条件
- 使用锁实现同步
- 使用读写锁同步数据访问
- 修改锁的公平性
- 在锁中使用多条件

### 1 简介
多个执行线程共享一个资源的情景，是最常见的并发编程情景之一。在并发应用中常
常遇到这样的情景：多个线程读或者写相同的数据，或者访问相同的文件或数据库连接。
为了防止这些共享资源可能出现的错误或数据不一致，我们必须实现一些机制来防止这些错误的发生

为了解决这些问题，人们引入了临界区（Critical Section）概念。临界区是一个用以访
问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行

为了帮助编程人员实现这个临界区，Java（以及大多数编程语言）提供了同步机制。
当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已经有其他线程
进入临界区。如果没有其他线程进入临界区，它就可以进入临界区；如果已经有线程进入
了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界
区的线程不止一个，JVM会选择其中的一个，其余的将继续等待

Java语言提供的两种基本同步机制：
- synchronized 关键字机制
- Lock接口及其实现机制

### 2 使用synchronized实现同步方法
如果一个对象已用synchronized关键字声明，那么只有一
个执行线程被允许访问它。如果其他某个线程试图访问这个对象的其他方法,它将被挂起，
直到第一个线程执行完正在运行的方法。

换句话说，每一个用synchronized关键字声明的方法都是临界区。在Java中，同一个
对象的临界区，在同一时间只有一个允许被访问。

静态方法则有不同的行为。用synchronized关键字声明的静态方法，同时只能够被一
个执行线程访问，但是其他线程可以访问这个对象的非静态方法。必须非常谨慎这一点，
因为两个线程可以同时访问一个对象的两个不同的synchronized方法，即其中一个是静态
方法，另一个是非静态方法。如果两个方法都改变了相同的数据，将会出现数据不一致的错误

### 3 使用非依赖属性实现同步
当使用synchronized关键字来保护代码块时，必须把对象引用作为传入参数。通常情
况下，使用this关键字来引用执行方法所属的对象，也可以使用其他的对象对其进行引用。
一般来说，这些对象就是为这个目的而创建的。例如，在类中有两个非依赖属性，它们被
多个线程共享，你必须同步每一个变量的访问，但是同一时刻只允许一个线程访问一个属
性变量，其他某个线程访问另一个属性变量

### 4 在同步代码中使用条件
在并发编程中一个典型的问题是生产者-消费者(Producer-Consumer)问题

我们有一个数据缓冲区，一个或者多个数据生产者将把数据存入这个缓冲区，一个或者多个数据消费者将数据从缓冲区中取走

这个缓冲区是一个共享数据结构，必须使用同步机制控制对它的访问，例如使用
synchronized关键字，但是会受到更多的限制。如果缓冲区是满的，生产者就不能再放入数据，
如果缓冲区是空的，消费者就不能读取数据

对于这些场景，Java在Object类中提供了wait()、 notify()和 notifyAll()方法
线程可以在同步代码块中调用wait()方法。 如果在同步代码块之外调用wait()方法，JVM将抛出
IllegalMonitorStateException异常。当一线程调用wait()方法时，JVM将这个线程置入
休眠，并且释放控制这个同步代码块的对象，同时允许其他线程执行这个对象控制的其他
同步代码块。为了唤醒这个线程，必须在这个对象控制的某个同步代码块中调用notify()或者notifyAll()方法

### 5 使用锁实现同步
Java提供了同步代码块的另一种机制，它是一种比synchronized关键字更强大也更灵活的机制。
这种机制基于Lock接口及其实现类(例如 ReentrantLock),提供了更多的好处
- 支持更灵活的同步代码块结构  
使用synchronized关键字时，只能在同一个synchronized块结构中获取和释放控制Lock接口允许实现更复杂的临界区结构
- 相比 synchronized关键字，Lock接口提供了更多的功能  
其中一个新功能是tryLock()方法的实现。这个方法试图获取锁，如果锁已被其他线程获取，它将返回false并继续往下执行代码。
使用synchronized关键字时，如果线程A试图执行一个同步代码块，而线程B已在执行这个同步代码块,则线程A就会被挂起直到线程B运行完这个同步代码块。
使用锁的tryLock()方法，通过返回值将得知是否有其他线程正在使用这个锁保护的代码块

- Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程
- 相比synchronized关键字，Lock接口具有更好的性能

### 6 使用读写锁实现同步数据访问
锁机制最大的改进之一就是ReadWriteLock接口和它的唯一实现类ReentrantReadWriteLock。
这个类有两个锁，一个是读操作锁，另一个是写操作锁。
使用读操作锁时可以允许多个线程同时访问，但是使用写操作锁时只允许一个线程进行。
在一个线程执行写操作时，其他线程不能够执行读操作

### 7 修改锁的公平性
ReentrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，它允许你控制这两个类的行为。
默认fair值是false，它称为非公平模式(Non-Fair Mode)。
在非公平模式下，当有很多线程在等待锁(ReentrantLock和ReentrantReadWriteLock)时,锁将选择它们中的一个来访问临界区,这个选择是没有任何约束的。
如果fair值是true，则称为公平模式(Fair Mode)。
在公平模式下，当有很多线程在等待锁(ReentrantLock和ReentrantReadWriteLock)时，锁将选择它们中的一个来访问临界区，而且选择的是等待时间最长的。
这两种模式只适用于lock()和unlock()方法。而Lock接口的tryLock()方法没有将线程置于休眠，fair属性并不影响这个方法

### 8 在锁中使用多条件（Multiple Condition）
一个锁可能关联一个或者多个条件，这些条件通过Condition接口声明。
目的是允许线程获取锁并且查看等待的某一个条件是否满足，如果不满足就挂起直到某个线程唤醒它们。
Condition接口提供了挂起线程和唤起线程的机制。

并发编程中的一个典型问题是生产者-消费者(Producer Consumer)问题。
我们使用一个数据缓冲区，一个或者多个数据生产者(Producer)将数据保存到缓冲区，一个或者多个数据消费者(Consumer)将数据从缓冲区中取走
