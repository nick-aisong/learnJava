线程同步基础
========

- 使用synchronized实现同步方法
- 使用非依赖属性实现同步
- 在同步代码块中使用条件
- 使用锁实现同步
- 使用读写锁同步数据访问
- 修改锁的公平性
- 在锁中使用多条件

### 1 简介
多个执行线程共享一个资源的情景，是最常见的并发编程情景之一。在并发应用中常
常遇到这样的情景：多个线程读或者写相同的数据，或者访问相同的文件或数据库连接。
为了防止这些共享资源可能出现的错误或数据不一致，我们必须实现一些机制来防止这些错误的发生

为了解决这些问题，人们引入了临界区（Critical Section）概念。临界区是一个用以访
问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行

为了帮助编程人员实现这个临界区，Java（以及大多数编程语言）提供了同步机制。
当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已经有其他线程
进入临界区。如果没有其他线程进入临界区，它就可以进入临界区；如果已经有线程进入
了临界区，它就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界
区的线程不止一个，JVM会选择其中的一个，其余的将继续等待

Java语言提供的两种基本同步机制：
- synchronized 关键字机制
- Lock接口及其实现机制

### 2 使用synchronized实现同步方法
如果一个对象已用synchronized关键字声明，那么只有一
个执行线程被允许访问它。如果其他某个线程试图访问这个对象的其他方法,它将被挂起，
直到第一个线程执行完正在运行的方法。

换句话说，每一个用synchronized关键字声明的方法都是临界区。在Java中，同一个
对象的临界区，在同一时间只有一个允许被访问。

静态方法则有不同的行为。用synchronized关键字声明的静态方法，同时只能够被一
个执行线程访问，但是其他线程可以访问这个对象的非静态方法。必须非常谨慎这一点，
因为两个线程可以同时访问一个对象的两个不同的synchronized方法，即其中一个是静态
方法，另一个是非静态方法。如果两个方法都改变了相同的数据，将会出现数据不一致的错误

### 3 使用非依赖属性实现同步
当使用synchronized关键字来保护代码块时，必须把对象引用作为传入参数。通常情
况下，使用this关键字来引用执行方法所属的对象，也可以使用其他的对象对其进行引用。
一般来说，这些对象就是为这个目的而创建的。例如，在类中有两个非依赖属性，它们被
多个线程共享，你必须同步每一个变量的访问，但是同一时刻只允许一个线程访问一个属
性变量，其他某个线程访问另一个属性变量

### 4 在同步代码中使用条件
在并发编程中一个典型的问题是生产者-消费者(Producer-Consumer)问题

我们有一个数据缓冲区，一个或者多个数据生产者将把数据存入这个缓冲区，一个或者多个数据消费者将数据从缓冲区中取走

这个缓冲区是一个共享数据结构，必须使用同步机制控制对它的访问，例如使用
synchronized关键字，但是会受到更多的限制。如果缓冲区是满的，生产者就不能再放入数据，
如果缓冲区是空的，消费者就不能读取数据

对于这些场景，Java在Object类中提供了wait()、 notify()和 notifyAll()方法
线程可以在同步代码块中调用wait()方法。 如果在同步代码块之外调用wait()方法，JVM将抛出
IllegalMonitorStateException异常。当一线程调用wait()方法时，JVM将这个线程置入
休眠，并且释放控制这个同步代码块的对象，同时允许其他线程执行这个对象控制的其他
同步代码块。为了唤醒这个线程，必须在这个对象控制的某个同步代码块中调用notify()或者notifyAll()方法



