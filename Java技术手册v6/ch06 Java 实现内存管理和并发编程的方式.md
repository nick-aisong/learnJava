#### 第 6 章 Java实现内存管理和并发编程的方式

本章介绍 Java 平台处理并发（多线程）编程和内存管理的方式。这两个话题有内在联系，所以放在一起介绍。本章包含以下内容：

- 介绍 Java 管理内存的方式；
- 标记清除垃圾回收（Garbage Collection，GC）算法基础；
- HotSpot JVM 根据对象的生命周期优化垃圾回收的方式；
- Java 的并发基元；
- 数据的可见性和可变性。

##### 6.1 Java 内存管理的基本概念

在 Java 中，对象占用的内存在不需要使用对象时会自动回收。这个过程叫作垃圾回收（或自动内存管理）。垃圾回收这项技术在 Lisp 等语言中已经存在好多年了，习惯使用 C 和 C++ 等语言的程序员要花点儿时间适应，因为在这些语言中必须调用 free() 函数或使用 delete 运算符才能回收内存。

> Java 是一门用起来很舒心的语言，原因之一是，不用动手销毁自己创建的每一个对象。也是基于这个原因，较之不支持自动垃圾回收机制的语言，使用 Java 编写的程序较少存在缺陷。

不同的虚拟机使用不同的方式实现垃圾回收，而且规范没有对如何实现垃圾回收做强制要求。本章后面会讨论 HotSpot JVM，这虽然不是你会用到的唯一一个 JVM，但部署在服务器端的应用最常使用这个 JVM，而且 HotSpot 是现代化生产环境使用的典型 JVM。

###### 6.1.1 Java 中的内存泄露

Java 支持垃圾回收，因此可以显著减少内存泄露的发生几率。分配的内存没有回收，就会发生内存泄露。乍看起来，垃圾回收似乎能避免一切内存泄露的发生，因为这个机制能回收所有不再使用的对象。

但是，在 Java 中，如果不再使用的对象存在有效（但不再使用）的引用，仍然会发生内存泄露。例如，如果某个方法运行的时间很长（或者一直运行下去），那么这个方法中的局部变量会一直保存对象的引用，远超实际所需的时间，如下述代码所示：
```java
public static void main(String args[]) {
    int bigArray[] = new int[100000];
    
    // 对bigArray做些计算，得到一个结果
    int result = compute(bigArray);
    
    // 不再需要使用bigArray了。如果没有引用指向bigArray，就会被垃圾回收
    // 但是bigArray是局部变量，在方法返回之前始终指向那个数组
    // 可是这个方法还没有返回，因此我们要自己动手销毁引用
    // 告知垃圾回收程序回收这个数组
    bigArray = null;
    
    // 无限循环，处理用户的输入
    for(;;) handle_input(result);
}
```
使用 HashMap 或类似的数据结构关联两个对象时，也可能会发生内存泄露。就算有一个对象不再需要使用了，哈希表中仍然存有两个对象之间的关联，因此在回收哈希表之前，这两个对象一直存在。如果哈希表的生命周期比其中的对象长得多，就可能导致内存泄露。

###### 6.1.2 标记清除算法简介

JVM 确切知道它分配了哪些对象和数组，这些对象和数组存储在某种内部数据结构中，我们称这种数据结构为分配表（allocation table）。JVM 还能区分每个栈帧（stack frame）里的局部变量指向堆（heap）里的哪个对象或数组。最后，JVM 能追踪堆中对象和数组保存的引用，不管引用多么迂回，都能找到所有仍然被引用的对象和数组。

因此，运行时能判断已经分配内存的对象什么时候不再被其他活动对象或变量引用。遇到这种对象时，解释器知道它可以放心地回收这个对象的内存，然后回收内存。注意，垃圾回收程序还能检测到相互引用的对象，如果没有其他活动对象引用这些对象，就将其内存回收。

在应用线程的堆栈跟踪中，从其中一个方法的某个局部变量开始，沿着引用链，如果最终能找到一个对象，我们称这个对象为可达对象（reachable object）。这种对象也叫活性对象。

> 注 1：从 GC Roots 对象开始向下穷根揭底的探索过程称为活性对象的传递闭包（transitive closure）——这个术语从图论抽象数学中借用而来。

> 除了局部变量之外，引用链还可以从其他几个地方开始。通向可达对象的引用链根部一般称为 GC Root。

知道这些简单的定义之后，我们来看一种基于这些原则回收垃圾的简单方式。

###### 6.1.3 基本标记清除算法

垃圾回收过程经常使用（也是最简单）的算法是标记清除（mark and sweep）。整个过程分为三步。

(1) 迭代分配表，把每个对象都标记为“已死亡”。

(2) 从指向堆的局部变量开始，顺着遇到的每个对象的全部引用向下，每遇到一个之前没见过的对象或数组，就把它标记为“存活”。像这样一直向下，直到找出能从局部变量到达的所有引用为止。

(3) 再次迭代分配表，回收所有没标记为“存活”的对象在堆中占用的内存，然后把这些内存放回可用内存列表中，最后把这些对象从分配表中删除。

> 上面概述的标记清除过程是这个算法理论上最简单的形式。在后面的几节中会看到，真正的垃圾回收程序做的事情比这要多。上面的概述是为了打好理论基础，目的就是易于理解。

因为所有对象的内存都由分配表分配，所以用完堆内存之前会触发垃圾回收程序。在上述对标记清除算法的描述中，垃圾回收程序需要互斥存取整个堆，因为应用代码一直在运行中，会不断创建和修改对象，导致结果腐化。

图 6-1 展示了在应用线程运行过程中尝试回收对象的后果。

<img src="img\图 6-1：堆内存的变化.png" />

为了避免发生这种问题，在上述简单的垃圾回收过程中，应用线程会停顿一下（这个停顿叫 Stop-The-World，STW）——先停止所有应用线程，然后回收垃圾，最后继续运行应用线程。应用线程执行到一个安全点（safepoint）时，例如循环的开始处或即将调用方法时，运行时会让应用线程停顿一下，因为运行时知道在安全点可以放心地停止运行应用线程。

开发者有时会担心这种停顿，但是对大多数主流应用场景来说，Java 都运行在操作系统之上，进程会不断交替进出处理器内核，因此一般无需担心这些短暂的额外停顿。HotSpot 会做大量工作来优化垃圾回收，减少 STW 时间，这一点对减轻应用的工作负担来说十分重要。下一节会介绍一些优化措施。

##### 6.2 JVM 优化垃圾回收的方式

对第 1 章介绍的软件来说，运行时会对其做些处理，其中一个很好的例子是弱代假设（Weak Generational Hypothesis，WGH）。简单来说，在这个假设中，对象常常处于少数几个预期生命周期之一（这些预期生命周期叫“代”）。

一般来说，对象的生命期非常短（有时把这种对象叫瞬时对象），不久就会当作垃圾回收。然而，有些少量对象会存在得久一点，因此注定会成为程序长期状态的一部分（程序的长期状态有时称为程序的工作集）。这种现象可通过图 6-2 表示，这幅图绘制的是预期生命周期中内存用量的变化。

<img src="img\图 6-2：弱代假设.png" style="zoom:50%;" />

这种变化趋势不是由静态分析推知的，在监测软件运行时行为时可以看出，在不同的应用场景中，这明显都是事实。

HotSpot JVM 有一个垃圾回收子系统，专门利用弱代假设。本节，我们要讨论如何在生命期短的对象（大多数情况下对象的寿命都短）上使用这些技术。这些论述默认针对 HotSpot，不过其他服务器端使用的 JVM 一般也都使用类似或相关的技术。

最简单的分代垃圾回收程序只会留意弱代假设，因为分代垃圾回收程序认为，较之充分使用弱代假设，做额外的簿记来监控内存，投入少收效大。在最简单的分代垃圾回收程序中，往往只有两代，这两代一般称为新生代和老年代。

筛选回收

在上述标记清理算法的清理阶段，一个一个回收对象，然后把各个对象占用的空间放回可用内存列表。然而，如果弱代假设成立，而且在任何一个垃圾回收循环中大多数对象都已“死亡”，那么使用另一种方式回收空间似乎更合理。

新的回收方式把堆内存分成多个独立的内存空间，每次回收垃圾时，只为活性对象分配空间，并把这些对象移到另一个内存空间。这个过程叫作筛选回收（evacuation），执行这个过程的回收程序叫作筛选回收程序。这种回收程序回收完毕后会清理整个内存空间，供以后重复使用。图 6-3 展示了筛选回收程序的工作方式。

<img src="img\图 6-3：筛选回收程序.png" style="zoom:50%;" />

这种回收方式可能比上述简单的回收方式高效得多，因为根本不用管已死对象。垃圾回收循环执行的时间长短和活性对象的数量成正比，而不是已分配空间的对象数量。这种回收方式唯一的缺点是，要稍微花点儿时间簿记，因为要复制活性对象，但这点儿时间与获得的巨大收益相比不值一提。

> HotSpot 完全在用户空间中自行管理 JVM 堆，而且分配内存和释放内存时不用执行系统调用。对象一开始在 Eden 区（或叫 Nursery 区）创建，大多数生产环境使用的 JVM（至少 SE/EE 使用的 JVM）都会使用筛选回收策略回收 Eden 区的垃圾。

使用筛选回收程序的话，每个线程都可以单独分配内存。也就是说，每个应用线程都有一块连续的内存（叫线程私有的分配缓冲区），专门供这个线程分配新对象。为新对象分配内存时，只需把指针指向分配缓冲区，非常省事。

如果对象在回收操作即将开始之前创建，那么这个对象没有时间完成使命，在垃圾回收循环开始前就会“死亡”。在只有两代的回收程序中，这种生命期短的对象会被移入长存区，几乎相当于宣布“死刑”，然后等待下次回收循环将其回收。因为这种情况很少见（往往也很费事），执行上述操作似乎相当浪费资源。

为了缓和这种浪费，HotSpot 引入了 Survivor 区。Survivor 区用于保存前一次回收新生对象后存活下来的对象。筛选回收程序会在多个 Survivor 区之间来回复制存活下来的对象，直到超过保有阈值后，再把这些对象推给老年代。

详述 Survivor 区和调校垃圾回收程序的方式已经超出本书范畴。如果要把应用部署到生产环境，应该参阅专门的资料。

###### 6.3 HotSpot 堆

HotSpot JVM 的代码相当复杂，由一个解释器、一个即时编译器和一个用户空间内存管理统组成。HotSpot JVM 的代码使用 C 和 C++ 编写，还有相当多针对特定平台的汇编代码。

现在，我们来总结一下什么是 HotSpot 堆，再回顾一下它的基本特性。Java 堆是一块连续的内存，在启动 JVM 时创建，但一开始只会把部分堆分配给各个内存池。在应用运行的过程中，内存池会按需扩容。扩容由垃圾回收子系统完成。

```
堆中的对象

应用线程在 Eden 区创建对象，不确定性垃圾回收循环会移除这些对象。这个垃圾回收循环在需要时（即内存不够用时）才会运行。堆分为两代：新生代和老年代。新生代由三个区组成：Eden 区和两个 Survivor 区；而老年代只有一个内存空间。

多次垃圾回收循环后存活下来的对象，最终会推给老年代。只回收新生代的回收操作消耗（所需计算）往往不大。HotSpot 使用的标记清除算法比目前为止我们见到的要高级，而且还会做额外的簿记，提升垃圾回收的性能。下一节介绍老年代，以及 HotSpot 如何处理生命期较长的对象。
```

###### 6.3.1 回收老年代

讨论垃圾回收程序时，开发者还要知道两个重要的术语。

- 并行回收程序

使用多个线程执行回收操作的垃圾回收程序。

- 并发回收程序

可以和应用线程同时运行的垃圾回收程序。

到目前为止，我们见到的回收程序都是并行回收程序，而不是并发回收程序。默认情况下，老年代使用的回收程序也是并行标记清除回收程序（而不是并发回收程序），但是，HotSpot 允许植入不同的回收程序。例如，稍后在本节会见到 HotSpot 内置的 CMS 回收程序，这是并行回收程序，但基本上也是并发回收程序。

乍看起来，老年代默认使用的回收程序和新生代使用的回收程序类似，但二者有个重要的区别：老年代默认使用的回收程序不是筛选回收程序。回收老年代时，回收程序会整理老年代。这一点很重要，这样内存空间在使用的过程中不会产生碎片。

###### 6.3.2 其他回收程序

这一节完全针对 HotSpot，但不会深入介绍，因为超出本书范畴了。不过你要知道，还有其他一些回收程序存在。如果不使用 HotSpot，你应该阅读 JVM 的文档，看看有什么其他选择。

1. 并发标记清除

HotSpot 中最常使用的替代回收程序是并发标记清除（Concurrent Mark and Sweep，CMS）回收程序。这个回收程序只能用来回收老年代，与一个回收新生代的并行回收程序配合使用。

> CMS 只适用于需要短暂停顿的应用，这些应用的停顿时间不能超过 STW 的几毫秒。这类应用极少，除了金融贸易类应用之外，很少有应用真正需要这么短的停顿时间。

CMS 是个很复杂的回收程序，往往很难有效调校。CMS 是个非常有用的工具，但部署时不能掉以轻心。CMS 有一些基本特性（如下所示）你要知道，但详细说明已经超出本书范畴。有兴趣的读者可以阅读专门的博客和邮件列表（例如，“Friends of jClarity”邮件列表经常讨论 GC 性能方面的问题）。

- CMS 只能回收老年代；
- 在多数 GC 循环中，CMS 都和应用线程一起运行，以便减少停顿时间；
- 应用线程不会像之前那样停顿很久；
- 分为六个阶段，都是为了缩减 STW 停顿时间；
- 把一次 STW 长停顿变成两次（往往很短的）STW 停顿；
- 簿记工作更多，CPU 时间也更长；
- 总体来说，GC 循环的时间更长；
- 默认情况下，并发运行时，GC 使用一半 CPU；
- 除了需要短暂停顿的应用之外，不要使用 CMS；
- 绝对不能在吞吐量大的应用中使用；
- 不会整理内存，如果内存碎片很多，会回滚到默认的（并行）回收程序。

2. G1

Garbage First 回收程序（简称 G1）是一个新的垃圾回收程序，在 Java 7 时代开发（Java 6 时代完成了部分准备工作）。G1 是一种短暂停顿回收程序，目的是取代 CMS。而且 G1 允许用户设定停顿指标，指定回收垃圾时停顿多久，以及多久停顿一次。和 CMS 不同的是，G1 适用于吞吐量较高的应用场合。

G1 使用粗粒度方式管理内存，把内存分成多个区，集中精力管理几乎充满垃圾的区，因为这些区释放的内存最多。G1 是一种筛选回收程序，筛选各区时，会不断整理内存。

新开发一个通用的生产级回收程序，不是个简单的过程。因此，虽然 G1 已经开发了数年，但在 2014 年年初，多数评测仍显示 G1 没有 CMS 效率高。话虽如此，不过二者之间的差距在稳步减小，而且在某些应用场合中，G1 已经处于领先地位。在未来数月或数年中，G1 完全可能会变成最常用的短暂停顿回收程序。

最后，HotSpot 还有一个 Serial 回收程序（和 SerialOld 回收程序），以及一个“增量式 CMS”回收程序。这些回收程序都废弃了，不要再使用。

##### 6.4 终结机制

有一种古老的资源管理技术叫终结（finalization），开发者应该知道有这么一种技术。然而，这种技术几乎完全废弃了，任何情况下，大多数 Java 开发者都不应该直接使用。

> 只有少数应用场景适合使用终结，而且只有少数 Java 开发者会遇到这种场景。如果有任何疑问，就不要使用终结，处理资源的 try 语句往往是正确的替代品。

终结机制的作用是自动释放不再使用的资源。垃圾回收自动释放的是对象使用的内存资源，不过对象可能会保存其他类型的资源，例如打开的文件和网络连接。垃圾回收程序不会为你释放这些额外的资源，因此，终结机制的作用是让开发者执行清理任务，例如关闭文件、中断网络连接、删除临时文件，等等。

终结机制的工作方式是这样的：如果对象有 finalize() 方法（一般叫作终结方法），那么不再使用这个对象（或对象不可达）后的某个时间会调用这个方法，但要在垃圾回收程序回收分配给这个对象的空间之前调用。终结方法用于清理对象使用的资源。

在 Oracle/OpenJDK 中，按照下述方式使用这种技术。

(1) 如果可终结的对象不可达了，会在内部终结队列中放一个引用，指向这个对象；而且，为了回收垃圾，这个对象会被标记为“存活”。

(2) 对象一个接着一个从终结队列中移除，然后调用各自的 finalize() 方法。

(3) 调用终结方法后，不会立即释放对象，因为终结方法可能会把 this 引用存储在某个地方（例如在某个类的公开静态字段中），让对象再次拥有引用，复活对象。

(4) 因此，调用 finalize() 方法后，垃圾回收子系统在回收对象之前，必须重新判断对象是否可达。

(5) 不过，就算对象复活了，也不会再次调用终结方法。

(6) 综上所述，定义了 finalize() 方法的对象一般（至少）会多存活一个 GC 循环（如果是生命期长的对象，会再多存活一个完整的 GC 循环）。

终结机制的主要问题是，Java 不确定什么时候回收垃圾，或者以什么顺序回收对象。因此，Java 平台无法确认什么时候（甚至是否）调用终结方法，或者以什么顺序调用终结方法。

因此，作为一种防止资源（例如文件句柄）稀少的自动清理机制，其设计是有缺陷的，因不能保证终结机制运行得足够快，避免耗尽资源。

终结方法唯一真正有用的场景是，在一个类中使用本地方法，打开某个非 Java 资源。就算遇到这种情况，也更适合使用处理资源的块状 try 语句，但也可以声明一个 public native finalize() 方法（close() 方法会调用这个方法）——这个方法可以释放本地资源，包括不受 Java 垃圾回收程序控制的堆外内存。

终结机制的细节

为了少数适合使用终结机制的场景，下面列出一些额外细节，以及使用过程中的注意事项。

- 在没有回收全部重要的对象之前，JVM 可能就会退出，所以根本不会调用某些终结方法。遇到这种情况，操作系统会关闭网络连接等资源，并将其回收。然而，要注意，如果要删除文件的终结方法没有运行，操作系统不会删除那个文件。

- 为了确保在虚拟机退出前执行某些操作，Java 提供了 Runtime::addShutdownHook 钩子，在 JVM 退出前安全执行任意代码。

- finalize() 方法是实例方法，作用在实例上。没有等效的机制用来终结类。

- 终结方法是实例方法，没有参数，也不返回值。每个类只能有一个终结方法，而且必须命名为 finalize()。

- 终结方法可以抛出任何类型的异常或错误，但垃圾回收子系统自动调用终结方法时，终结方法抛出的任何异常或错误都会被忽略，这些异常或错误只会导致终结方法返回。

###### 6.5 Java 对并发编程的支持

线程的作用是提供一个轻量级执行单元——虽比进程小，但仍能执行任何 Java 代码。一般情况下，对操作系统来说，一个线程是一个完整的执行单元，但仍属于一个进程，进程的地址空间在组成该进程的所有线程之间共享。也就是说，每个线程都可以独立调度，而且有自己的栈和程序计数器，但会和同个进程中的其他线程共享内存和对象。

Java 平台从第一版开始就支持多线程编程，并向开发者开放了创建新线程的功能。创建新线程往往很简单，如下所示：
```java
Thread t = new Thread(() -> {System.out.println("Hello Thread");});
t.start();
```
这段简短的代码创建并启动一个新线程，然后执行 lambda 表达式的主体，最后退出。如果你是使用过旧版 Java 的程序员，我告诉你，lambda 表达式其实会被转换成 Runnable 接口的实例，然后再传给 Thread 类的构造方法。

线程机制允许新线程和原有的应用线程以及 JVM 为了不同目的而创建的多个线程一起并发运行。

> 在大多数 Java 平台的实现中，应用线程都能访问操作系统调度程序控制的 CPU。调度程序是操作系统原生的一部分，用于管理处理器时间的时间片（也能禁止应用线程超出分配给它的时间）。

在最近几版 Java 中，越来越流行使用运行时管理的并发。因为基于很多原因，由开发者自行管理线程已经不能满足需求了。而运行时应该提供“发后不理”能力，让程序指定需要做什么，但怎么做这样的低层细节交给运行时完成。

这种观点从 java.util.concurrent 包含的并发工具包中可以窥探一二，本书不会详细介绍这个包，有兴趣的读者可以阅读 Brian Goetz 等人写的 Java Concurrency in Practice 一书（Addison-Wesley 出版）。

本章剩下的内容会介绍 Java 平台提供的低层并发机制，每个 Java 开发者都应该对此有所了解。

###### 6.5.1 线程的生命周期

我们先来看看应用线程的生命周期。不同的操作系统看待线程的视角有所不同，因此在某些细节上可能有所不能（不过，站在一定高度上，大多数情况下基本类似）。Java 做了很多工作，力求把这些细节抽象化。Java 提供了一个名为 Thread.State 的枚举类型，囊括了操作系统看到的线程状态。Thread.State 中的值概述了一个线程的生命周期。

- NEW

已经创建线程，但还没在线程对象上调用 start() 方法。所有线程一开始都处于这个状态。

- RUNNABLE

线程正在运行，或者当操作系统调度线程时可以运行。

- BLOCKED

线程中止运行，因为它在等待获得一个锁，以便进入声明为 synchronized 的方法或代码块。本节后面会详细介绍声明为 synchronized 的方法和代码块。

- WAITING

线程中止运行，因为它调用了 Object.wait() 或 Thread.join() 方法。

- TIMED_WAITING

线程中止运行，因为它调用了 Thread.sleep() 方法，或者调用了 Object.wait() 或 Thread.join() 方法，而且传入了超时时间。

- TERMINATED

线程执行完毕。线程对象的 run() 方法正常退出，或者抛出了异常。

这些是常见的线程状态（至少对主流操作系统来说如此），线程的生命周期如图 6-4 所示。

<img src="img\图 6-4：线程的生命周期.png" style="zoom:50%;" />

使用 Thread.sleep() 方法可以让线程休眠。这个方法有一个参数，指定线程休眠的时长，单位为毫秒，如下所示：
```java
try {
    Thread.sleep(2000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```
> 参数中指定的休眠时长是对操作系统的请求，而不是要求。例如，休眠的时间可能比请求的长。具体休眠多久，取决于负载和运行时环境相关的其他因素。

本章后面会介绍 Thread 类的其他方法，不过在此之前，我们要介绍一些重要的理论，学习线程如何访问内存，了解为什么多线程编程如此之难，会给开发者带来很多问题。

###### 6.5.2 可见性和可变性

在 Java 中，其实一个进程中的每个 Java 应用线程都有自己的栈（和局部变量），不过这些线程共用同一个堆，因此可以轻易在线程之间共享对象，毕竟需要做的只是把引用从一个线程传到另一个线程，如图 6-5 所示。

<img src="img\图 6-5：在线程之间共享内存.png" style="zoom:70%;" />

由此引出 Java 的一个一般设计原则——对象默认可见。如果我有一个对象的引用，就可以复制一个副本，然后将其交给另一个线程，不受任何限制。Java 中的引用其实就是类型指针，指向内存中的一个位置，而且所有线程都共用同一个地址空间，所以默认可见符合自然规律。

除了默认可见之外，Java 还有一个特性对理解并发很重要——对象是可变的（mutable），对象的内容（实例字段的值）一般都可以修改。使用 final 关键字可以把变量或引用声明为常量，但这种字段不属于对象的内容。

在阅读本章剩下内容的过程中，我们会发现，这两个特性（跨线程可见性和对象可变性）结合在一起，大大增加了理解 Java 并发编程的难度。

并发编程的安全性

如果我们想编写正确的多线程代码，得让程序满足一个重要的条件，即：

在一个程序中，不管调用什么方法，也不管操作系统如何调度应用线程，一个对象看到的任何其他对象都不处于非法或不一致的状态，这样的程序才称得上是安全的多线程程序。

在第 5 章，我们把安全的面向对象程序定义为，通过调用对象的存取方法，把对象从一个合法状态变成另一个合法状态。这个定义对单线程代码来说没问题，但延伸到并发程序，会遇到一个特别的难题。

在大多数主流场合中，操作系统会根据负载和系统中运行的其他程序作出决策，在不同的时期把线程调度到不同的处理器内核中运行。如果负载高，说明还有其他进程需要运行。

如果需要，操作系统会把 Java 线程从 CPU 内核中强制移出，不管线程正在做什么，哪怕某个方法正执行一半，都会立即挂起。可是，第 5 章说过，在方法执行的过程中，可以临时先把对象变成非法状态，等方法退出后再变成合法状态。

因此，即便程序遵守了安全规则，如果一个长时间运行的方法还没退出线程就被踢出了，也可能会让对象处于不一致状态。也就是说，虽然为单线程正确建模了数据类型，还是要考虑如何避免并发的影响。添加这层额外的保护措施之后，才能称为并发安全的代码。

下一节介绍获取这层安全性的主要方式，本章末尾还会介绍在某些情况下有用的其他机制。

###### 6.5.3 互斥和状态保护

只要修改或读取对象的过程中，对象的状态可能不一致，这段代码就要受到保护。为了保护这种代码，Java 平台只提供了一种机制：互斥。

假如一个方法包含一连串操作，那么在执行过程中中断，就可能会导致某个对象处于不一致或非法状态。如果这个非法状态对另一个对象可见，代码的行为可能就会错乱。

例如，在 ATM 或其他柜员机的系统中可能有如下代码：
```java
public class Account {
    private double balance = 0.0; // 必须>= 0
    // 假设还有其他字段，例如name，以及其他方法
    // 例如deposit()、checkBalance()和dispenseNotes()
    
    public Account(double openingBal) {
        balance = openingBal;
    }
    
    public boolean withdraw(double amount) {
        if (balance >= amount) {
        try {
            Thread.sleep(2000); // 模拟风险检查
        } catch (InterruptedException e) {
            return false;
        }
            balance = balance - amount;
            dispenseNotes(amount);
            return true;
        }
        return false;
    }
}
```
withdraw() 方法中的一连串操作就可能会让对象处于不一致状态。具体来说是这样的，查看余额之后，在模拟风险检查阶段，第一个线程休眠时，可能会出现第二个线程继续执行代码，导致账户透支，违背 balance >= 0 这个约束条件。

在这个例子中，系统对对象的操作虽然在单线程中安全（因为在单线程中对象不可能变成非法状态，即 balance < 0），但并发时却不安全。

为了让这种代码在并发运行时也安全，Java 为开发者提供了 synchronized 关键字。这个关键字可以用在代码块或方法上，使用时，Java 平台会限制访问代码块或方法中的代码。

> 因为 synchronized 关键字把代码包围起来，所以很多开发者认为，Java 的并发和代码有关。有些资料甚至把 synchronized 修饰的块或方法中的代码称为临界区，还认为临界区是并发的关键所在。其实不然，稍后会看到，其实我们要防范的是数据的不一致性。

Java 平台会为它创建的每个对象记录一个特殊的标记，这个标记叫监视器（monitor）。synchronized 使用这些监视器（或叫锁）指明，随后的代码可以临时把对象渲染成不一致的状态。synchronized 修饰的代码块或方法会发生一系列事件，详述如下：

(1) 线程需要修改对象时，会临时把对象变成不一致状态；

(2) 线程获取监视器，指明它需要临时互斥存储这个对象；

(3) 线程修改对象，修改完毕后对象处于一致的合法状态；

(4) 线程释放监视器。

如果在修改对象的过程中，其他线程尝试获取锁，Java 会阻塞这次尝试，直到拥有锁的线程释放锁为止。

注意，如果程序没有创建共享数据的多个线程，就无需使用 synchronized 语句。如果自始至终只有一个线程访问某个数据结构，就无需使用 synchronized 保护这个结构。

获取监视器不能避免访问对象，只能避免其他线程声称拥有这个锁——这一点至关重要。为了正确编写并发安全的代码，开发者要确保，修改或读取可能处于不一致状态的对象之前，得先获取对象的监视器。

换个角度来说，如果 synchronized 修饰的方法正在处理一个对象，并且把这个对象变成非法状态，那么读取这个对象的另一个方法（没使用 synchronized 修饰）仍能看到这个不一致的状态。

> 同步是保护状态的一种协助机制，因此非常脆弱。一个缺陷（需要使用 synchronized 修饰的方法却没有使用）就可能为系统的整体安全性带来灾难性的后果。

之所以使用 synchronized 这个词作为“需要临时互斥存储”的关键词，除了说明需要获取监视器之外，还表明进入代码块时，JVM 会从主内存中重新读取对象的当前状态。类似地，退出 synchronized 修饰的代码块或方法时，JVM 会刷新所有修改过的对象，把新状态存入主内存。

如果不同步，系统中不同的 CPU 内核看到的内存状态可能不一样，而这种差异可能会破坏运行中程序的状态。前面的 ATM 示例就可能出现这种情况。

###### 6.5.4 volatile 关键字

Java 还提供了另一个关键字，用来并发访问数据——volatile。这个关键字指明，应用代码使用字段或变量前，必须重新从主内存读取值。同样，修改使用 volatile 修饰的值后，在写入变量之后，必须存回主内存。

volatile 关键字的主要用途之一是在“关闭前一直运行”模式中使用。编写多线程程序时，如果外部用户或系统需要向处理中的线程发出信号，告诉线程在完成当前作业后优雅关闭线程，那么就要使用 volatile。这个过程有时叫作“优雅结束”模式。下面看个典型示例，假设处理中的线程里有下述代码，而这段代码在一个实现 Runnable 接口的类中定义：
```java
private volatile boolean shutdown = false;

public void shutdown() {
    shutdown = true;
}

public void run() {
    while (!shutdown) {
        // ……处理其他任务
    }
}
```
只要没有其他线程调用 shutdown() 方法，处理中的线程就会继续处理任务（经常和非常有用的 BlockingQueue 一起使用，BlockingQueue 接口用于分配工作）。一旦有其他线程调用 shutdown() 方法，处理中的线程就会发现 shutdown 的值变成了 true。这个变化并不影响运行中的作业，不过一旦这个任务结束，处理中的线程就不会再接受其他任务，而会优雅关闭。

###### 6.5.5 Thread 类中有用的方法

创建新应用线程时，程序员可以使用 Thread 类中的许多方法，减少劳动量。这里没有列出全部方法，Thread 类还有一些其他方法，但本节主要介绍较常用的方法。

- getId()

这个方法返回线程的 ID 值，类型为 long。线程的 ID 在线程的整个生命周期中都不变。

- getPriority()和setPriority()

这两个方法控制线程的优先级。调度程序处理线程优先级的策略之一是，如果有优先级高的线程在等待，就不运行优先级低的线程。不过，大多数情况下都无法影响调度程序解释优先级的方式。线程的优先级使用 1~10 之间的整数表示。

- setName()和getName()

开发者使用这两个方法设定或取回单个线程的名称。为线程起名字是个好习惯，因为这样调试时更方便，尤其是使用 jvisualvm 等工具。13.2 节会介绍如何使用 jvisualvm。

- getState()

返回一个 Thread.State 对象，说明线程处于什么状态。表示状态的各个值在 6.5.1 节介绍过。

- isAlive()

用来测试线程是否还“活着”。

- start()

这个方法用来创建一个新应用线程，然后再调用 run() 方法调度这个线程，开始执行。正常情况下，执行到 run() 方法的末尾或者执行 run() 方法中的一个 return 语句后，线程就会结束运行。

- interrupt()

如果调用 sleep()、wait() 或 join() 方法时阻塞了某个线程，那么在表示这个线程的 Thread 对象上调用 interrupt() 方法，会让这个线程抛出 InterruptedException 异常（并把线程唤醒）。如果线程中涉及可中断的 I/O 操作，那么这个 I/O 操作会终止，而且线程会收到 ClosedByInterruptException 异常。即便线程没有从事任何可中断的操作，线程的中断状态也会被设为 true。

- join()

在调用 join() 方法的 Thread 对象“死亡”之前，当前线程一直处于等待状态。可以把这个方法理解为一个指令，在其他线程结束之前，当前线程不会继续向前运行。

- setDaemon()

用户线程是这样一种线程，只要它还“活着”，进程就无法退出——这是线程的默认行为。有时，程序员希望线程不阻止进程退出——这种线程叫守护线程。一个线程是守护线程还是用户线程，由 setDaemon() 方法控制。

- setUncaughtExceptionHandler()

线程因抛出异常而退出时，默认的行为是打印线程的名称、异常的类型、异常消息和堆栈跟踪。如果这么做还不够，可以在线程中安装一个自定义的处理程序，处理未捕获的异常。例如：
```java
// 这个线程直接抛出一个异常
Thread handledThread = new Thread(() -> { throw new UnsupportedOperationException(); });
// 给线程起个名字，有利于调试
handledThread.setName("My Broken Thread");
// 处理这个异常的处理程序
handledThread.setUncaughtExceptionHandler((t, e) -> {
    System.err.printf("Exception in thread %d '%s':" + "%s at line %d of %s%n",
    t.getId(), // 线程的ID
    t.getName(), // 线程的名称
    e.toString(), // 异常名称和消息
    e.getStackTrace()[0].getLineNumber(),
    e.getStackTrace()[0].getFileName()); });
handledThread.start();
```
这个方法在某些情况下很有用，例如，如果一个线程在监管一组其他工作线程，那么可以使用这种模式重启“死亡”的线程。

Thread类弃用的方法

Thread 类除了有一些有用的方法之外，还有一些危险的方法，开发者不应该使用。这些方法是 Java 线程 API 原来提供的，但很快就发现不适合开发者使用。可惜的是，因为 Java 要向后兼容，所以不能把这些方法从 API 中移除。开发者要知道有这些方法，而且在任何情况下都不能使用。

- stop()

如若不违背并发安全的要求，几乎不可能正确使用 Thread.stop()，因为 stop() 方法会立即“杀死”线程，不会给线程任何机会把对象恢复成合法状态。这和并发安全等原则完全相悖，因此绝对不能使用 stop() 方法。

- suspend()、resume()和countStackFrames()

调用 suspend() 方法挂起线程时，不会释放这个线程拥有的任何一个监视器，因此，如果其他线程试图访问这些监视器，这些监视器会变成死锁。其实，这种机制会导致死锁之间的条件竞争，而且 resume() 会导致这几个方法不能使用。

- destroy()

这个方法一直没有实现，如果实现了，会遇到与 suspend() 方法一样的条件竞争。

开发者始终应该避免使用这些弃用的方法。为了达到上述方法的预期作用，Java 开发了一些安全的替代模式。前面提到的“关闭前一直运行”模式就是这些模式的一例。

##### 6.6 使用线程

若想有效使用多线程代码，要对监视器和锁有些基本的认识。你需要知道的要点如下。

- 同步是为了保护对象的状态和内存，而不是代码。
- 同步是线程间的协助机制。一个缺陷就可能破坏这种协助模型，导致严重的后果。
- 获取监视器只能避免其他线程再次获取这个监视器，而不能保护对象。
- 即便对象的监视器锁定了，不同步的方法也能看到（和修改）不一致的状态。
- 锁定 Object[] 不会锁定其中的单个对象。
- 基本类型的值不可变，因此不能（也无需）锁定。
- 接口中声明的方法不能使用 synchronized 修饰。
- 内部类只是语法糖，因此内部类的锁对外层类无效（反过来亦然）。
- Java 的锁可重入（reentrant）。这意味着，如果一个线程拥有一个监视器，这个线程遇到具有同一个监视器的同步代码块时，可以进入这个代码块。

我们还说过，线程可以休眠一段时间。但有时不需要指定具体休眠多久，而是等到满足某个条件时才唤醒。在 Java 中，这种操作通过 wait() 和 notify() 方法完成，这两个方法都在 Object 类中定义。

就像每个 Java 对象都关联一个锁一样，每个对象还会维护一个等待线程列表。在一个线程中，如果某个对象调用了 wait() 方法，那么这个线程会临时释放它拥有的所有锁，而且这个线程会被添加到这个对象的等待线程列表中，然后停止运行。其他线程在这个对象上调用 notifyAll() 方法时，这个对象会唤醒等待线程，让这些线程继续运行。

> 注 2：除了 Java，其他语言实现的锁并不都有这种特性。

例如，下面是一个简化版队列，在多线程环境中可以安全使用：
```java
/*
 * 一个线程调用push()方法，把一个对象存入队列。
 * 另一个线程调用pop()方法，从队列中取出一个对象。
 * 如果队列中没有数据，pop()方法使用wait()/notify()，一直等待，直到有数据。
 */
public class WaitingQueue<E> {
    LinkedList<E> q = new LinkedList<E>(); // 仓库
    public synchronized void push(E o) {
        q.add(o); // 把对象添加到链表的末端
        this.notifyAll(); // 告诉等待的线程，数据准备好了
    }
    public synchronized E pop() {
        while(q.size() == 0) {
            try { this.wait(); }
            catch (InterruptedException ignore) {}
        }
        return q.remove();
    }
}
```
这个类在队列为空时（此时 pop() 操作会失败）在 WaitingQueue 实例上调用 wait() 方法。等待的线程会临时释放监视器，允许其他线程声称拥有这个监视器，然后这个线程可能会调用 push() 方法，把新对象添加到队列中。原来的线程被唤醒时，会从它之前开始休眠的地方继续运行，而且会重新获取监视器。

> wait() 和 notify() 方法必须在 synchronized 修饰的方法或代码块中使用，因为只有临时把锁放弃，这两个方法才能正常工作。

一般来说，大多数开发者都不需要自己编写类似这个示例的类，使用 Java 平台提供的库和组件即可。

##### 6.7 小结

本章介绍了 Java 实现内存管理和并发编程的方式，以及这两个话题之间的内在联系。处理器的内核数量越来越多，因此我们要使用并发编程技术合理利用这些内核。未来，并发决定着应用的性能。

Java 的线程模型基于三个基本概念。

- 状态是共享的，可变的，而且默认可见

意思是，在同一个进程中，对象可在不同的线程间轻易共享，而且只要线程中有对象的引用，就可以修改对象。

- 抢先式线程调度

几乎任何时候，操作系统的线程调度程序都能把线程调入和调出内核。

- 对象的状态只能由锁保护

锁很难正确使用，而且状态十分脆弱，即便是读取操作也可能会得到不可思议的结果。

Java 实现并发的这三个方面放在一起，解释了为什么多线程编程会让开发者如此头痛。
