#### 第 2 章 Java 基本句法

本章简练而全面地介绍 Java 句法，主要针对之前有些编程经验但刚接触这门语言的读者，对完全没有编程经验的新手也有一些帮助。如果已经了解 Java，可以把这一章当成语言参考。为了方便学过其他编程语言的读者，本章还对 Java 与 C 和 C++ 进行了比较。

本章先介绍非常低层的 Java 句法，然后以此为基础，介绍高级结构。本章包含以下内容。

- 编写 Java 程序的字符，以及这些字符的编码。
- 组成 Java 程序的字面量、标识符和其他标记。
- Java 能处理的数据类型。
- 在 Java 中把单独的标记放在一起组成复杂表达式的运算符。
- 语句：把表达式和其他语句放在一起组成 Java 代码逻辑块。
- 方法：一系列 Java 语句，有名字，可被其他 Java 代码调用。
- 类：由一系列方法和字段组合而成。类是 Java 程序的核心元素，也是面向对象编程的基础。第 3 章专门介绍类和对象。
- 包：由一系列相关的类组合而成。
- Java 程序：由一个或多个交互的类组成，这些类可能来自一个或多个包。

大多数编程语言的句法都很复杂， Java 也不例外。一般来说，介绍一门语言的某些元素时，难免会提到一些尚未接触的元素。例如，介绍 Java 支持的运算符和语句时，不可避免地要提到对象；类似地，介绍对象时也不能不提 Java 的运算符和语句。在学习 Java 或任何其他语言的过程中，都要这样交叉学习。

##### 2.1 Java 程序概览

在详细介绍 Java 句法之前，我们先花点儿时间概述 Java 程序。 Java 程序由一个或多个Java 源码文件（或叫编译单元）组成。本章末尾会介绍 Java 文件的结构，并且会讲解如何编译和运行 Java 程序。每个编译单元都以可选的 package 声明开始，后面跟着零个或多个 import 声明。这些声明指定一个命名空间，编译单元中定义的名称都在这个命名空间里，而且还指定了编译单元从哪些命名空间中导入名称。 2.10 节会介绍 package 和 import 声明。

在可选的 package 和 import 声明之后，是零个或多个引用类型定义。第 3 章和第 4 章会介
绍各种可用的引用类型，现在你只需要知道，这些往往都是 class 或 interface 定义。

在引用类型的定义体中有一些成员，例如字段、 方法和构造方法。其中，方法是最重要的成员类型。方法是一段由语句组成的 Java 代码。

了解这些基本术语之后，下面开始详细介绍 Java 程序的基本句法单元。句法单元经常被称为词法标记（ lexical token）。

##### 2.2 词法结构

本节说明 Java 程序的词法结构，首先介绍编写 Java 程序的 Unicode 字符集，然后介绍组成 Java 程序的标记，包括注释、标识符、保留字和字面量等。

###### 2.2.1 Unicode 字符集

Java 程序使用 Unicode 字符编写。在 Java 程序中，任何地方都能使用 Unicode 字符，包括注释和标识符，例如变量名。 7 位 ASCII 字符集只对英语有用， 8 位 ISO Latin-1 字符集只对大多数西欧语言有用，而 Unicode 字符集能表示世界上几乎所有常用的书写语言。

> 如果使用不支持 Unicode 的文本编辑器，或者不想强制查看或编辑你代码的程序员使用支持 Unicode 的编辑器，你可以使用特殊的 Unicode 转义序列\uxxxx，把 Unicode 字符嵌入 Java 程序。 Unicode 转义序列由反斜线、小写的字母 u 和四个十六进制字符组成。例如， \u0020 是空格， \u03c0 是字符 π。

Java 投入了大量时间和工程努力，确保能最好地支持 Unicode。如果业务应用面向全球用户，特别是西方之外的市场， Java 平台是很好的选择。

###### 2.2.2 区分大小写与空白

Java 语言区分大小写，关键字使用小写，而且必须这么用；也就是说， While 和 WHILE 与 while 关键字不是一回事。类似地，如果在程序中把变量命名为 i，就不能使用 I 引用这个变量。

> 一般来说，通过大小写来区分标识符是非常糟糕的主意。在代码中不要这么做，尤其不要使用和关键字同名但大小写不同的标识符。

Java 会忽略空格、制表符、换行符和其他空白，除非这些符号出现在引号或字符串字面量中。为了易读，程序员一般会使用空白格式化和缩进代码。本书的示例代码会使用一些常用的缩进约定。

###### 2.2.3 注释

注释是使用自然语言编写的文本，供某一程序的人类读者阅读。 Java 编译器会忽略注释。Java 支持三种注释。第一种是单行注释，以 // 字符开始，直到行尾结束。例如：
```java
int i = 0; // 初始化循环变量
```
第二种是多行注释，以 `/*` 字符开始，不管有多少行，直到 `*/` 字符结束。 javac 会忽略 `/*`和 `*/` 之间的所有文本。虽然这种形式一般用于多行注释，但也可以用于单行注释。

这种注释不能嵌套，即 `/* */` 中不能再有 `/* */`。编写多行注释时，程序员经常使用额外的 * 字符，突出注释的内容。下面是个典型的多行注释：
```java
/*
* 首先，连接服务器。
* 如果尝试连接失败，立即退出。
*/
```
第三种注释是第二种的一个特例。如果注释以 `/**` 开头，会被当成特殊的文档注释。和普通的多行注释一样，文档注释也以 `*/` 结尾，而且不能嵌套。如果你编写了一个 Java 类，希望让其他程序员使用，可以直接在源码中嵌入关于这个类和其中每个方法的文档。名为javadoc 的程序会提取这些文档，经过处理后生成这个类的在线文档。文档注释中可以包含 HTML 标签和 javadoc 能理解的其他句法。例如：
```java
/**
* 把文件上传到Web服务器中。
*
* @param file要上传的文件。
* @return <tt>true</tt>表示上传成功，
* <tt>false</tt>表示上传失败。
* @author David Flanagan
*/
```
第 7 章会详细介绍文档注释的句法，第 13 章会详细介绍 javadoc 程序。

注释可以出现在 Java 程序中的任何标记之间，但不能出现在标记中。注释尤其不能出现在双引号字符串字面量中。字符串字面量中的注释就是这个字符串的一部分。

###### 2.2.4 保留字

以下是 Java 的保留字（它们是 Java 语言句法的一部分，不能用来命名变量和类等）：

|||||||
|-|-|-|-|-|-|
|abstract|const|final|int|public|throw|
|assert|continue|finally|interface|return|throws|
|boolean|default|float|long|short|transient|
|break|do|for|native|static|true|
|byte|double|goto|new|strictfp|try|
|case|else|if|null|super|void|
|catch|enum|implements|package|switch|volatile|
|char|extends|import|private|synchronized|while|
|class|false|instanceof|protected|this|

后文还会见到这些保留字，其中有些是基本类型的名称，有些是 Java 语句的名称，这两种保留字稍后都会进行介绍。还有一些用于定义类和成员，第 3 章会介绍。

注意，虽然 Java 语言不使用 const 和 goto，但它们也是保留字； interface 还有另外一种形式——@interface，用来定义注解类型。有些保留字（尤其是 final 和 default）根据不同的上下文有不同的意义。

###### 2.2.5 标识符

标识符就是 Java 程序中某个部分的名称，例如类、类中的方法和方法中声明的变量。标识符的长度不限，可以包含 Unicode 字符集中的任意字母和数字，但是不能以数字开头。一般来说，标识符不能包含标点符号，不过可以包含 ASCII 字符集中的下划线`（_）`和美元符号`（$）`，以及 Unicode 字符集中的其他货币符号，例如`￡`和` ¥`。

> 货币符号主要用在自动生成的源码中，例如 javac 生成的代码。不在标识符中使用货币符号，可以避免自己的标识符和自动生成的标识符冲突。

按 照 规 定， 可 以 出 现 在 标 识 符 开 头 和 之 中 的 字 符 由 java.lang.Character 类 中 的isJavaIdentifierStart() 和 isJavaIdentifierPart() 方法定义。

以下是合法标识符示例：
```java
i    x1    theCurrentTime    the_current_time    獺
```
特别注意，其中有个 UTF-8 标识符——獺。这是一个汉字，英文是“ otter”，完全是个合法的 Java 标识符。在主要是由西方人编写的程序中不常见到使用非 ASCII 字符的标识符，但偶尔也有。

###### 2.2.6 字面量

字面量是直接出现在 Java 源码中的值，包括整数、浮点数、单引号中的单个字符、双引号中的字符串，以及保留字 true、 false 和 null。例如，以下都是字面量：
```java
1    1.0    '1'    "one"    true    false    null
```
2.3 节会详细介绍表示数字、字符和字符串字面量的句法。

###### 2.2.7 标点符号

Java 标记中也有一些是标点符号。 Java 语言规范把这些字符分成两类（有点随意）：分隔符和运算符。分隔符有 12 个：
```java
( )    { }    [ ]
...    @    ::
;    ,    .
```
运算符如下：
```java
+    -    *    /    %    &    |    ^    <<    >>    >>>
+=    -=    *=    /=    %=    &=    |=    ^=    <<=    >>=    >>>=
=    ==    !=    <    <=    >    >=
!    ~    &&    ||    ++    --    ?    :    ->
```
整本书中都会见到分隔符， 2.4 节会分别介绍每个运算符。

##### 2.3 基本数据类型

Java 支持八种基本数据类型，包括一种布尔类型、一种字符类型、四种整数类型和两种浮点数类型，如表 2-1 所示。四种整数类型和两种浮点数类型的区别在于位数不同，因此能表示的数字范围也不同。

表2-1： Java的基本数据类型

|类　　型 |取　　值 |默认值 |大　　小 |范　　围|
|-|-|-|-|-|
|boolean |true 或 false |false |1 位 |NA|
|char |Unicode 字符 |\u0000 |16 位 |\u0000~\uFFFF|
|byte |有符号的整数 |0 |8 位 |-128~127|
|short |有符号的整数 |0 |16 位 |-32768~32767|
|int |有符号的整数 |0 |32 位 |-2147483648~2147483647|
|long |有符号的整数 |0 |64 位 |-9223372036854775808~9223372036854775807|
|float |IEEE 754 浮点数 |0.0 |32 位 |1.4E-45~3.4028235E+38|
|double |IEEE 754 浮点数 |0.0 |64 位 |4.9E-324~1.7976931348623157E+308|

下面几节简要介绍这些基本数据类型。除了基本数据类型之外， Java 还支持称为引用类型的非基本数据类型， 2.9 节会介绍。

###### 2.3.1 布尔类型

布尔类型（ boolean）表示真值，只有两个可选值，表示两种逻辑状态：开或关，是或否，真或假。 Java 使用保留字 true 和 false 表示这两个布尔值。

从其他编程语言，尤其是 JavaScript，转到 Java 的程序员要注意， Java 比其他语言对布尔值的要求严格得多：布尔类型既不是整数类型也不是对象类型，而且不能使用不兼容的值代替布尔类型。也就是说，在 Java 中不能使用下面的简写形式：
```java
Object o = new Object();
int i = 1;
if (o) {
    while(i) {
       // ...
    }
}
```
相反， Java 强制要求编写简洁的代码，明确表明想做什么比较：
```java
if (o != null) {
    while(i != 0) {
        // ...
    }
}
```

###### 2.3.2 字符类型

字符类型（ char）表示 Unicode 字符。 Java 使用一种稍微独特的方式表示字符：在传给javac 的输入中，标识符使用 UTF-8 编码（一种变长编码方式），但在内部使用定长编码（16 位）表示字符。

不过，开发者一般无需担心这个区别。大多数情况下，只需记住，如果想在 Java 程序中使用字符字面量，只需把字符放在单引号中即可：
```java
char c = 'A';
````
当然，字符字面量可以使用任何一个 Unicode 字符，也可以使用 Unicode 转义序列 \u。而且， Java 还支持一些其他转义序列，用来表示常用的非打印 ASCII 字符，例如换行符以及转义 Java 中某些有特殊意义的标点符号。例如：
```java
char tab = '\t', nul = '\000', aleph = '\u05D0', slash = '\\';
```
表 2-2 列出了可在字符字面量中使用的转义字符。这些字符也可以在字符串字面量中使用，下一节会介绍。

表2-2： Java转义字符

|转义序列 |字符值|
|-|-|
|\b |退格符|
|\t |水平制表符|
|\n |换行符|
|\f |换页符|
|\r |回车符|
|\" |双引号|
|\' |单引号|
|\\ |反斜线|
|\xxx |xxx 编码的 Latin-1 字符，其中 xxx 是八进制数，介于 000 到 377 之间。 \x 和 \xx 两种形式也是合法的，例如 \0，但不推荐这么用，因为转义序列只有一个数字，在字符串常量中会导致歧义。这种用法在 \uxxxx 中也不鼓励使用|
|\uxxxx |xxxx 编码的 Unicode 字符，其中 xxxx 是四个十六进制数。 Unicode 转义序列可以出现在Java 程序的任意位置，而不只局限于字符和字符串字面量|

字符可以转换成整数类型，也可以从整数类型转换而来。字符类型对应的是 16 位整数类型。字符类型与 byte、 short、 int 和 long 不同，没有符号。 Character 类定义了一些有用的静态方法（static method），用于处理字符，例如 isDigit()、 isJavaLetter()、isLowerCase() 和 toUpperCase()。

设计 Java 语言和字符类型时考虑到了 Unicode。 Unicode 标准一直在发展，每一个 Java 新版本都会使用最新版 Unicode。 Java 7 使用的是 Unicode 6.0， Java 8 使用的是 Unicode 6.2。

最近的几版 Unicode 收录了 16 位编码（或叫码位， codepoint）无法容纳的字符。这些追加的字符是十分少见的汉字象形文字，占用了 21 位，无法使用单个字符表示，必须使用 int 类型表示，或者必须使用“代理对”（ surrogate pair）通过两个字符表示。

除非经常使用亚洲语言编写程序，否则很少会遇到这些追加的字符。如果预计要处理无法使用单个字符类型表示的字符，就可以使用 Character 和 String 等相关类中提供的方法，使用 int 类型表示码位，然后再处理文本。

字符串字面量

除了字符类型之外， Java 还有一种用于处理字符串的数据类型。不过， String 类型是类，
不是基本类型。因为字符串很常用，所以 Java 提供了一种句法，可以直接在程序中插入字
符串。字符串字面量是包含在双引号中的任意文本（字符字面量使用单引号）。 例如：
```java
"Hello, world"
"'This' is a string!"
```
字符串字面量中可以包含能在字符字面量中使用的任何一个转义序列（参见表 2-2）。如果想在字符串字面量中插入双引号，可以使用 \" 转义序列。 String 是引用类型，本章后面的 2.7.4 节还会深入介绍字符串字面量。第 9 章会更详细地介绍在 Java 中处理 String 对象的一些方式。

###### 2.3.3 整数类型

Java 中的整数类型有 byte、 short、 int 和 long 四种。如表 2-1 所示，这四种类型之间唯一的区别是位数，即能表示的数字范围有所不同。所有整数类型都表示有符号的数字，Java 没有 C 和 C++ 中的 unsigned 关键字。

这四种类型的字面量形式正如你设想的那样，使用十进制数字，前面还可以加上负号。 1 下面是一些合法的整数字面量：
```java
0 1
123
-42000
```
> 注 1：严格来说，负号是作用在字面量上的运算符，而不是字面量的一部分。

整数字面量还可以使用十六进制、二进制和八进制形式来表示。以 0x 或 0X 开头的字面量是十六进制数，使用字母 A 到 F（或 a 到 f）表示数字的十六进制形式。

整数字面量的二进制形式以 0b 开头，当然，只能使用数字 1 或 0。字面量的二进制形式可能很长，所以经常在字面量中使用下划线。在任何数字字面量中，下划线都会被忽略。下划线纯粹是为了提升字面量的可读性。

Java 还支持使用八进制表示整数字面量，以 0 开头，而且不能使用数字 8 或 9。这种字面量不常用，除非有必要，否则应该避免使用。下面是一些合法的十六进制、二进制和八进制字面量：
```java
0xff // 使用十六进制表示的十进制数255
0377 // 使用八进制表示的十进制数255
0b0010_1111 // 使用二进制表示的十进制数47
0xCAFEBABE // 用来识别Java类文件的魔法数
```
整数字面量是 32 位 int 类型，如果以 L 或 l 结尾，就表示 64 位 long 类型：
```java
1234 // int类型
1234L // long类型
0xffL // 还是long类型
```
在 Java 中，如果整数运算超出了指定整数类型的范围，不会上溢或下溢，而是直接回绕。例如：
```java
byte b1 = 127, b2 = 1; // byte类型的最大值是127
byte sum = (byte)(b1 + b2); // 加法运算的结果直接回绕到-128，即byte类型的最小值
```
如果发生了这种情况， Java 编译器和解释器都不会发出任何形式的警告。进行整数运算时，必须确保使用的类型取值范围能满足计算需要。整数除以零，或者计算除以零后得到的余数，都是非法操作，会抛出 ArithmeticException 异常。

每一种整数类型都有对应的包装类： Byte、 Short、 Integer 和 Long。这些类都定义了 MIN_VALUE 和 MAX_VALUE 常量，表示相应的取值范围。而且还定义了一些有用的静态方法，例如Byte.parseByte() 和 Integer.parseInt()，作用是把字符串转换成整数。

###### 2.3.4 浮点数类型

在 Java 中，实数使用 float 和 double 数据类型表示。如表 2-1 所示， float 类型是 32 位单精度浮点数， double 是 64 位双精度浮点数。这两种类型都符合 IEEE 754-1985 标准。这个标准规定了浮点数的格式和运算方式。

浮点数可以以字面量形式插入 Java 程序，其格式为一些可选的数字，后跟一个小数点和一些数字。下面是几个示例：
```java
123.45
0.0
.01
```
浮点数字面量还可以使用指数形式（也叫科学记数法）表示，其格式为一个数后面跟着字母 e 或 E 和一个数。第二个数表示 10 的次方，是第一个数的乘数。例如：
```java
1.2345E02 // 1.2345 * 10^2或123.45
1e-6 // 1 * 10^-6或0.000001
6.02e23 // 阿伏加德罗常数：6.02 * 10^23
```
默认情况下，浮点数是 double 类型。若想在程序中插入 float 类型的字面量，要在数字后面加上 f 或 F：
```java
double d = 6.02E23;
float f = 6.02e23f;
```
浮点数字面量不能使用十六进制、二进制或八进制表示。
```
浮点数表示的值

由于本质上的限制，大多数实数都不能使用有限的位数进行精确表示。因此，要记住，float 和 double 类型都只能表示实际值的近似值。 float 类型是 32 位近似值，至少有 6 个有效数字； double 是 64 位近似值，至少有 15 个有效数字。第 9 章会更详细地说明浮点数表示的值。
```
除了表示普通的数字之外， float 和 double 类型还能表示四个特殊的值：正无穷大、负无穷大、零和 NaN。如果浮点数运算的结果超出了 float 或 double 能表示的范围上限，得到的是无穷大。如果浮点数的运算结果超出了 float 或 double 能表示的范围下限，得到的是零。

Java 的浮点类型区分正零和负零，具体是哪个值取决于从哪个方向出现的下溢。在实际使用中，正零和负零的表现基本一样。最后一种特殊的浮点数 NaN，是“ Not-a-Number”的简称，表示“不是数字”。如果浮点数运算不合法，例如 0.0/0.0，得到的就是 NaN。以下几个例子得到的结果就是这些特殊的值：
```java
double inf = 1.0/0.0; // 无穷大
double neginf = -1.0/0.0; // 负无穷大
double negzero = -1.0/inf; // 负零
double NaN = 0.0/0.0; // NaN
```
Java 浮点数类型能处理到无穷大的上溢以及到零的下溢，因此浮点数运算从不抛出异常，就算执行非法运算也没事，例如零除以零，或计算负数的平方根。

float 和 double 基本类型都有对应的类，分别为 Float 和 Double。这两个类都定义了一些
有用的常量： MIN_VALUE、 MAX_VALUE、 NEGATIVE_INFINITY、 POSITIVE_INFINITY 和 NaN。

无穷大浮点数的表现和设想的一样，例如，无穷大之间的加减运算得到的还是无穷大。负零的表现几乎和正零一样，而且事实上，相等运算符 == 会告诉你，负零和正零是相等的。区分负零、正零和普通的零有一种方法——把它作为被除数： 1.0/0.0 得到的是正无穷大，但是 1.0 除以负零得到的是负无穷大。因为 NaN 不是数字，所以 == 运算符会告诉我们它不等于任何其他数字，甚至包括它自己。若想检查某个 float 或 double 值是否为 NaN，必须使用 Float.isNaN() 或 Double.isNaN() 方法。

###### 2.3.5 基本类型之间的转换

Java 允许整数和浮点数之间相互转换。而且，由于每个字符都对应 Unicode 编码中的一个数字，所以字符与整数和浮点数之间也可以相互转换。其实，在 Java 中，布尔值是唯一一种不能和其他基本类型之间相互转换的基本类型。

类型转换有两种基本方式。把某种类型的值转换成取值范围更广的类型，此时执行的是放大转换（widening conversion）。例如，把 int 字面量赋值给 double 类型的变量和把字符字面量赋值给 int 类型的变量时， Java 会执行放大转换。

另一种方式是缩小转换（narrowing conversion）。把一个值转换成取值范围没那么广的类型时执行的就是缩小转换。缩小转换并不总是安全的，例如把整数 13 转换成 byte 类型是合理的，但把 13 000 转换成 byte 类型就不合理，因为 byte 类型只能介于 -128 和 127 之间。缩小转换可能丢失数据，所以试图缩小转换时 Java 编译器会发出警告，就算转换后的值能落在更窄的取值范围内也会警告：
```java
int i = 13;
byte b = i; // 编译器不允许这么做
```
不过有个例外，如果整数字面量（int 类型）的值落在 byte 和 short 类型的取值范围内，就能把这个字面量赋值给 byte 或 short 类型的变量。

如果需要执行缩小转换，而且确信这么做不会丢失数据或精度，可以使用一种称为“校正”（cast）的语言结构强制 Java 转换。若想执行类型校正，可以在想转换的值前面加一个括号，在括号里写上希望转换成哪种类型。例如：
```java
int i = 13;
byte b = (byte) i; // 把int类型强制转换成byte类型
i = (int) 13.456; // 把double字面量强制转换成int类型，得到的是13
```
基本类型的校正最常用于把浮点数转换成整数。执行这种转换时，浮点数的小数部分会被直接截掉，即浮点数向零而不是临近的整数舍入。静态方法 Math.round()、 Math.floor() 和 Math.ceil() 执行的是另一些舍入方式。

大多数情况下，字符类型的表现都和整数类型类似，所以需要 int 或 long 类型的地方都可以使用字符。不过，还记得吗，字符类型没有符号，所以即便字符和 short 类型都是 16 位，表现上也有差异：
```java
short s = (short) 0xffff; // 这些比特表示数字-1
char c = '\uffff'; // 还是这些比特，表示一个Unicode字符
int i1 = s; // 把short类型转换成int类型，得到的是-1
int i2 = c; // 把字符转换成int类型，得到的是65535
```
表 2-3 列出了各种基本类型能转换成何种其他类型，以及转换的方式。其中，字母 N 表示无法转换；字母 Y 表示放大转换，由 Java 自动隐式转换；字母 C 表示缩小转换，需要显式校正。

最后， `Y*` 表示自动执行的放大转换，但在转换过程中最低有效位可能丢失。把 int 或 long 类型转换成浮点类型时可能会出现这种情况，详情参见下表。浮点类型的取值范围比整数类型广，所以 int 或 long 类型都能用 float 或 double 类型来表示。然而，浮点类型是近似值，所以有效数字不一定总与整数类型一样多（浮点数的详细介绍参见第 9 章）。

表2-3： Java基本类型转换

|基本类型  转换为|boolean|byte|short|char|int|long|float|double|
|-|-|-|-|-|-|-|-|-|
|boolean|-|N|N|N|N|N|N|N|
|byte|N|-|Y|C|Y|Y|Y|Y|
|short|N|C|-|C|Y|Y|Y|Y|
|char|N|C|C|-|Y|Y|Y|Y|
|int|N|C|C|C|-|Y|Y*|Y|
|long|N|C|C|C|C|-|Y*|Y*|
|float|N|C|C|C|C|C|-|Y|
|double|N|C|C|C|C|C|C|-|

##### 2.4 表达式和运算符

到目前为止，我们学习了 Java 程序能处理的基本类型，以及如何在 Java 程序中使用基本类型的字面量。还使用了变量作为值的符号名称。字面量和变量都是组成 Java 程序的标记。

表达式是 Java 程序更高一级的结构。 Java 解释器会求出表达式的值。最简单的表达式叫基本表达式，由字面量和变量组成。例如，下面几个例子都是表达式：
```java
1.7 // 一个浮点数字面量
true // 一个布尔字面量
sum // 一个变量
```
Java 解释器计算字面量表达式得到的结果是字面量本身；计算变量表达式得到的结果是存储在变量中的值。

基本表达式没什么意思。使用运算符把基本表达式连在一起可以组成复杂的表达式。例如，下面的表达式使用赋值运算符把两个基本表达式（一个变量，一个浮点数字面量）连在一起，组成赋值表达式：
```java
sum = 1.7
```
不过，运算符不仅能连接基本表达式，也能在任意复杂度的表达式中使用。如下都是合法的表达式：
```java
sum = 1 + 2 + 3 * 1.2 + (4 + 8)/3.0
sum/Math.sqrt(3.0 * 1.234)
(int)(sum + 33)
```

###### 2.4.1 运算符概述

一门编程语言能编写什么样的表达式，完全取决于可用的运算符。 Java 提供了丰富的运算符，但在有效使用它们之前，要弄清两个重要的概念： 优先级和结合性。下面几节详细说明这两个概念和运算符。

1. 优先级

在表 2-4 中， P 列是运算符的优先级。优先级指定运算符执行的顺序。优先级高的运算符在优先级低的运算符之前运算。例如，有如下的表达式：
```
a + b * c
```
乘号的优先级比加号的优先级高，所以 a 和 b 乘以 c 的结果相加，这与小学数学课上学到的一样。运算符的优先级可以理解为运算符和操作数之间绑定的紧密程度，优先级越高，绑定得越紧密。

运算符默认的优先级可以使用括号改变，括号能明确指定运算的顺序。前面那个表达式可以像下面这样重写，先相加再相乘：
```
(a + b) * c
```
Java 采用的默认运算符优先级和 C 语言兼容， C 语言的设计者选定的优先级无需使用括号就能流畅地写出大多数表达式。只有少量的 Java 惯用句法需要使用括号，例如：
```java
// 类校正和成员访问结合在一起
((Integer) o).intValue();

// 赋值和比较结合在一起
while((line = in.readLine()) != null) { ... }

// 位运算符和比较结合在一起
if ((flags & (PUBLIC | PROTECTED)) != 0) { ... }
```
2. 结合性

结合性是运算符的一个属性，定义如何计算有歧义的表达式。如果表达式中有多个优先级相同的运算符，结合性尤其重要。

大多数运算符由左至右结合，即从左向右计算。不过，赋值和一元运算符由右至左结合。在表 2-4 中， A 列是运算符或运算符组的结合性， L 表示由左至右， R 表示由右至左。

加号和减号的结合性都是由左至右，所以表达式 a+b-c 从左向右计算，即 (a+b)-c。一元运算符和赋值运算符从右向左计算。例如下面这个复杂的表达式：
```
a = b += c = -~d
```
计算的顺序是：
```
a = (b += (c = -(~d)))
```
和运算符的优先级一样，运算符的结合性也建立了计算表达式的默认顺序。这个默认的顺序可以使用括号改变。然而， Java 选定的默认运算符结合性是为了使用流畅的句法编写表达式，几乎不需要改变。

3. 运算符总结表

表 2-4 总结了 Java 提供的运算符。 P 列和 A 列分支表示每类相关运算符的优先级和结合性。这张表可以作为运算符（特别是优先级）的快速参考指南。

表2-4： Java运算符

<img src="img\表2-4 Java运算符.png" style="zoom:50%;" />

4. 操作数的数量和类型

在表 2-4 中，第 4 列是每种运算符能处理的操作数数量和类型。有些运算符只有一个操作数，这种运算符叫一元运算符。例如，一元减号的作用是改变单个数字的符号：
```
-n // 一元减号
```
不过，大多数运算符都是二元运算符，有两个操作数。- 运算符其实还有一种用法：
```
a – b // 减法运算符是二元运算符
```
Java 还定义了一个三元运算符，经常称作条件运算符，就像是表达式中的 if 语句。它的三个操作数由问号和冒号分开，第二个和第三个操作数必须能转换成同一种类型：
```
x > y ? x : y // 三元表达式；计算x和y哪个大
```
除了需要特定数量的操作数之外，每个运算符还需要特定类型的操作数。表 2-4 中的第 4 列是操作数的类型，其中使用的文本需要进一步说明。

- 数字

整数、浮点数或字符（即除了布尔类型之外的任何一种基本类型）。因为这些类型对应的包装类（例如 Character、Integer 和 Double）能自动拆包（参见 2.9.4 节），所以在这些地方也能使用相应的包装类。

- 整数

byte、short、int、long 或 char 类型的值（获取数组元素的运算符 [ ] 不能使用 long 类型的值）。因为能自动拆包，所以也能使用 Byte、Short、Integer、Long 和 Character 类型的值。

- 引用类型

对象或数组。

- 变量

变量或其他符号名称（例如数组中的元素），只要能赋值就行。

5. 返回类型

就像运算符只能处理特定类型的操作数一样，运算得到的结果也是特定类型的值。对算术运算符、递增和递减、位运算符和位移运算符来说，如果至少有一个操作数是 double 类型，返回值就是 double 类型；如果至少有一个操作数是 float 类型，返回值是 float 类型；如果至少有一个操作数是 long 类型，返回值是 long 类型；除此之外都返回 int 类型的值，就算两个操作数都是 byte、short 或 char 类型，也会放大转换成 int 类型。

比较、相等性和逻辑运算符始终返回布尔值。各种赋值运算符都返回赋予的值，类型和表达式左边的变量兼容。条件运算符返回第二个或第三个操作数（二者的类型必须相同）。

6. 副作用

每个运算符都会计算一个或多个操作数，得到一个结果。但是，有些运算符除了基本的计算之外还有副作用。如果表达式有副作用，计算时会改变 Java 程序的状态，即再次执行时会得到不同的结果。

例如，++ 递增运算符的副作用是递增变量中保存的值。表达式 ++a 会递增变量 a 中的值，返回递增后得到的值。如果再次计算这个表达式，会得到不同的值。各种赋值运算符也有副作用。例如，表达式 a\*=2 也可以写成 a=a\*2，这个表达式的结果是乘于 2 后得到的值，但是有副作用——把计算结果重新赋值给 a。

如果调用的方法有副作用，方法调用运算符 () 也有副作用。有些方法，例如 Math.sqrt()，只是计算后返回一个值，没有任何副作用。可是，一般情况下，方法都有副作用。最后，new 运算符有重大的副作用，它会创建一个新对象。

7. 计算的顺序

Java 解释器计算表达式时，会按照表达式中的括号、运算符的优先级和结合性指定的顺序运算。不过，在任何运算之前，解释器会先计算运算符的操作数（&&、|| 和 ?: 例外，不会总是计算这些运算符的全部操作数）。解释器始终使用从左至右的顺序计算操作数。如果操作数是有副作用的表达式，这种顺序就很重要了。例如下面的代码：
```
int a = 2;
int v = ++a + ++a * ++a;
```
虽然乘法的优先级比加法高，但是会先计算 + 运算符的两个操作数。因为这两个操作数都是 ++a，所以得到的计算的结果分别是 3 和 4，因此这个表达式计算的是 3 + 4 * 5，结果为 23。

###### 2.4.2 算术运算符

算术运算符可用于整数、浮点数和字符（即除了布尔类型之外的所有基本类型）。如果其中有个操作数是浮点数，就按浮点算术运算；否则，按整数算术运算。这一点很重要，因为整数算术和浮点算术是有区别的，例如除法的运算方式，以及上溢和下溢的处理方式。算术运算符如下。

- 加法（`+`）

`+` 号计算两个数之和。稍后会看到，+ 号还能连接字符串。如果 + 号的操作数中有一个是字符串，另一个也会转换成字符串。如果想把加法和连接放在一起使用，一定要使用括号。例如：
```java
System.out.println("Total: " + 3 + 4); // 打印“Total: 34”，不是7！
```
- 减法（`-`）

`-` 号当成二元运算符使用时，计算第一个操作数减去第二个操作数得到的结果。例如，7-3 的结果是 4。- 号也可执行一元取负操作。

- 乘法（`*`）

`*` 号计算两个操作数的乘积。例如，7*3 的结果是 21。

- 除法（`/`）

`/` 号用第一个操作数除以第二个操作数。如果两个操作数都是整数，结果也是整数，丢掉余数。如果有一个操作数是浮点数，结果就是浮点数。两个整数相除时，如果除数是零，抛出 ArithmeticException 异常。不过，对浮点数计算来说，如果除以零，得到的是无穷大或 NaN：
```java
7/3 // 计算结果为2
7/3.0f // 计算结果为2.333333f
7/0 // 抛出ArithmeticException异常
7/0.0 // 计算结果为正无穷大
0.0/0.0 // 计算结果为NaN
```
- 求模（`%`）

`%` 运算符计算第一个操作数和第二个操作数的模数，即返回第一个操作数除去第二个操作数的整倍数之后剩下的余数。例如，7%3 的结果是 1。结果的符号和第一个操作数的符号一样。虽然求模运算符的操作数一般是整数，但也可以使用浮点数。例如，4.3%2.1 的结果是 0.1。如果操作数是整数，计算零的模数会抛出 ArithmeticException 异常。如果操作数是浮点数，计算 0.0 的模数得到的结果是 NaN；计算无穷大和任何数的模数得到的结果也是 NaN。

`-` 负号（`-`）

如果把 `-` 号当成一元运算符使用，即放在单个操作数之前，执行的是一元取负运算。也就是说，会把正数转换成对应的负数，或把负数转换成对应的正数。

###### 2.4.3 字符串连接运算符

+ 号（以及相关的 += 运算符）除了能计算数字之和以外，还能连接字符串。如果 + 号的两个操作数中有一个是字符串，另一个操作数也会转换成字符串。例如：
```java
// 打印“Quotient: 2.3333333”
System.out.println("Quotient: " + 7/3.0f);
```
因此，如果加法和字符串连接结合在一起使用，要把加法表达式放在括号中。如果不这么做，加号会被理解成连接运算符。

Java 解释器原生支持把所有基本类型转换成字符串。对象转换成字符串时，调用的是对象的 toString() 方法。有些类自定义了 toString() 方法，所以这些类的对象可以使用这种方式轻易地转换成字符串。数组转换成字符串时会调用原生的 toString() 方法，不过可惜，这个方法没有为数组的内容提供有用的字符串形式。

###### 2.4.4 递增和递减运算符

++ 运算符把它的单个操作数增加 1，这个操作数必须是变量、数组中的元素或对象的字段。这个运算符的行为取决于它相对于操作数的位置。放在操作数之前，是前递增运算符，递增操作数的值，并返回递增后的值。放在操作数之后，是后递增运算符，递增操作数的值，但返回递增前的值。

例如，下面的代码把 i 和 j 的值都设为 2：
```java
i = 1;
j = ++i;
```
但是，下面的代码把 i 的值设为 2，j 的值设为 1：
```java
i = 1;
j = i++;
```
类似地，-- 运算符把它的单个数字操作数减小 1，这个操作数必须是变量、数组中的元素或对象的字段。和 ++ 运算符一样，-- 的行为也取决于它相对于操作数的位置。放在操作数之前，递减操作数的值，并返回递减后的值。放在操作数之后，递减操作数的值，但返回递减前的值。

表达式 x++ 和 x-- 分别等效于 x=x+1 和 x=x-1，不过使用递增和递减运算符时，只会计算一次 x 的值。如果 x 是有副作用的表达式，情况就大不相同了。例如，下面两个表达式不等效：
```java
a[i++]++; // 递增数组中的一个元素
// 把数组中的一个元素增加1，然后把新值存储在另一个元素中
a[i++] = a[i++] + 1;
```
这些运算符，不管放在前面还是后面，最常用来递增或递减控制循环的计数器。

###### 2.4.5 比较运算符

比较运算符包括测试两个值是否相等的相等运算符和测试有序类型（数字和字符）数据之间大小关系的关系运算符。这两种运算符计算的结果都是布尔值，因此一般用于 if 语句、while 和 for 循环，作为分支和循环的判定条件。例如：
```java
if (o != null) ...; // 不等运算符
while(i < a.length) ...; // 小于运算符
```
Java 提供了下述相等运算符。

等于（==）

如果 == 运算符的两个操作数相等，计算结果为 true；否则计算结果为 false。如果操作数是基本类型，这个运算符测试两个操作数的值是否一样。如果操作数是引用类型，这个运算符测试两个操作数是否指向同一个对象或数组。尤其要注意，这个运算符不能测试两个字符串是否相等。

如果使用 == 比较两个数字或字符，而且两个操作数的类型不同，在比较之前会把取值范围窄的操作数转换成取值范围宽的操作数类型。例如，比较 short 类型的值和 float 类型的值时，在比较之前会先把 short 类型的值转换成 float 类型。对浮点数来说，特殊的负零和普通的正零相等；特殊的 NaN 和任何数，包括 NaN 自己，都不相等。如果想测试浮点数是否为 NaN，要使用 Float.isNan() 或 Double.isNan() 方法。












###### 2.4.6 逻辑运算符



###### 2.4.7 位运算符和位移运算符



###### 2.4.8 赋值运算符



###### 2.4.9 条件运算符



###### 2.4.10 instanceof 操作符



##### 2.4.11 特殊运算符



##### 2.5 语句



###### 2.5.1 表达式语句



###### 2.5.2 复合语句



###### 2.5.3 空语句



###### 2.5.4 标注语句



###### 2.5.5 局部变量声明语句



###### 2.5.6 if/else 语句



###### 2.5.7 switch 语句



###### 2.5.8 while 语句



###### 2.5.9 do 语句



###### 2.5.10 for 语句



###### 2.5.11 遍历语句



###### 2.5.12 break 语句



###### 2.5.13 continue 语句



###### 2.5.14 return 语句



###### 2.5.15 synchronized 语句



###### 2.5.16 throw 语句



###### 2.5.17 try/catch/finally 语句



###### 2.5.18 处理资源的 try 语句



###### 2.5.19 assert 语句



##### 2.6 方法



###### 2.6.1 定义方法



###### 2.6.2 方法修饰符



###### 2.6.3 已检异常和未检异常



###### 2.6.4 变长参数列表



##### 2.7 介绍类和对象



###### 2.7.1 定义类



###### 2.7.2 创建对象



###### 2.7.3 使用对象



###### 2.7.4 对象字面量



###### 2.7.5 lambda 表达式



##### 2.8 数组



###### 2.8.1 数组的类型



###### 2.8.2 创建和初始化数组



###### 2.8.3 使用数组



###### 2.8.4 多维数组



##### 2.9 引用类型



###### 2.9.1 引用类型与基本类型比较



###### 2.9.2 处理对象和引用副本



###### 2.9.3 比较对象



###### 2.9.4 装包和拆包转换



##### 2.10 包和 Java 命名空间

包由一些具名的类、接口和其他引用类型组成，目的是把相关的类组织在一起，并为这些类定义命名空间。

Java 平台的核心类放在一些名称以 java 开头的包中。例如， Java 语言最基本的类在 java.lang 包中，各种实用类在 java.util 包中，输入输出类在 java.io 包中，网络类在 java.net 包中。有些包还包含子包，例如 java.lang.reflect 和 java.util.regex。甲骨文标准化的 Java 平台扩展一般在名称以 javax 开头的包中。有些扩展，例如 javax.swing 及其各种子包，后来集成到了核心平台中。最后， Java 平台还包含几个被认可的标准，这些包以标准制定方命名，例如 org.w3c 和 org.omg。

每个类都有两个名称：一个是简称，定义时指定；另一个是完全限定名称，其中包含所在包的名称。例如， String 类是 java.lang 包的一部分，因此它的完全限定名称是 java.lang.String。

本节说明如何把自己的类和接口放到包里，以及如何选择包名，避免和其他人的包名有冲突。然后说明如何有选择性地把类型名称或静态成员导入命名空间，避免每次使用类或接口都要输入包名。

###### 2.10.1 声明包

若想指定类属于哪个包，要使用 package 声明。如果 Java 文件中有 package 关键字，必须是 Java 代码的第一个标记（即除了注释和空格之外的第一个标记）。 package 关键字后面是包的名称和一个分号。例如，有个 Java 文件以下述指令开头：
```java
package org.apache.commons.net;
```
那么，这个文件中定义的所有类都是 org.apache.commons.net 包的一部分。

如果 Java 文件中没有 package 指令，那么这个文件中定义的所有类都是一个默认的无名包
的一部分。此时，类的限定名称和不限定名称相同。

> 包的名称有可能冲突，所以不要使用默认包。项目在增长的过程中越来越复杂，冲突几乎是不可避免的，所以最好从一开始就创建包。

###### 2.10.2 全局唯一的包名

包的重要功能之一是划分 Java 命名空间，避免类名有冲突。例如，只能从包名上区分java.util.List 和 java.awt.List 两个类。不过，因此包名本身就要独一无二。作为 Java 的开发方，甲骨文控制着所有以 java、 javax 和 sun 开头的包名。

常用的命名方式之一是使用自己的域名，倒序排列各部分，作为包名的前缀。例如，Apache 项目开发了一个网络库，是 Apache Commons 项目的一部分。 Commons 项目的网址是http://commons.apache.org/ ， 因此这个网络库的包名是 org.apache.commons.net。

注意， API 开发者以前也使用这种包命名规则。如果其他程序员要把你开发的类和其他未知类放在一起使用，你的包名就要具有全局唯一性。如果你开发了一个 Java 程序，但是不会发布任何类供他人使用，那么你就知道部署这个应用需要使用的所有类，因此无需担心无法预料的命名冲突。此时，可以选择一种自己用着方便的命名方式，而不用考虑全局唯一性。常见的做法之一是，使用程序的名称作为主包的名称（主包里可能还有子包）。

###### 2.10.3 导入类型

默认情况下，在 Java 代码中引用类或接口时，必须使用类型的完全限定名称，即包含包名。如果编写的代码需要使用 java.io 包中的 File 类处理文件，必须把这个类写成 java.io.File。不过这个规则有三个例外：

- java.lang 包中的类型很重要也很常用，因此始终可以使用简称引用；
- p.T 类型中的代码可以使用简称引用 p 包中定义的其他类型；
- 已经使用 import 声明导入命名空间里的类型，可以使用简称引用。

前两个例外叫作“自动导入”。 java.lang 包和当前包中的类型已经导入到命名空间里了，因此可以不加包名。输入不在 java.lang 包或当前包中的常用类型的包名，很快就会变得冗长乏味，因此要能显式地把其他包中的类型导入命名空间。这种操作通过 import 声明实现。

import 声明必须放在 Java 文件的开头，如果有 package 声明的话，要紧随其后，并且在任何类型定义之前。一个文件中能使用的 import 声明数量不限。 import 声明应用于文件中的所有类型定义（但不应用于 import 声明中的类型）。

import 声明有两种格式。若想把单个类型导入命名空间， import 关键字后面是类型的名称和一个分号：
```java
import java.io.File; // 现在不用输入java.io.File了，输入File就行
```
这种格式叫“单个类型导入”声明。

import 声明的另一种格式是“按需类型导入”。在这种格式中，包名后面是 `.*` 字符，表示使用这个包里的任何类型时都不用输入包名。因此，如果除了 File 类之外，还要使用java.io 包中的其他几个类，可以导入整个包：
```java
import java.io.*; // java.io包中的所有类都可以使用简称
```
按需导入句法对子包无效。如果导入了 java.util 包，仍然必须使用完全限定名称 java.util.zip.ZipInputStream 引用这个类。

按需导入类型和一个一个导入包中的所有类型作用不一样。按需导入更像是使用单个类型导入句法把代码中真正用到的各种类型从包中导入命名空间，因此才叫“按需”导入——用到某个类型时才会将其导入。

命名冲突和遮盖

import 声明对 Java 编程极其重要。不过，可能会导致命名冲突。例如， java.util 和java.awt 两个包中都有名为 List 的类型。

java.util.List 是常用的重要接口。 java.awt 包中有很多客户端应用常用的重要类型，但 java.awt.List 已经作废了，不是这些重要类型的其中一个。在同一个 Java 文件中既导入 java.util.List 又导入 java.awt.List 是不合法的。下述单个类型导入声明会导致编译出错：
```java
import java.util.List;
import java.awt.List;
```
使用按需类型导入句法导入这两个包是合法的：
```java
import java.util.*; // 导入集合和其他实用类型
import java.awt.*; // 导入字体，颜色和图形类型
```
可是，如果试图使用 List 类型会遇到困难。这个类型可以从两个包中的任何一个“按需”导入，只要试图使用未限定的类型名引用 List 就会导致编译出错。这种问题的解决方法是，明确指定所需的包名。

因为 java.util.List 比 java.awt.List 常用得多，所以可以在两个按需类型导入声明后使用单个类型导入声明指明从哪个包中导入 List：
```java
import java.util.*; // 导入集合和其他实用类型
import java.awt.*; // 导入字体，颜色和图形类型
import java.util.List; // 与java.awt.List区分开
```
这样，使用 List 时指的是 java.util.List 接口。如果确实需要使用 java.awt.List 类，只要加上包名就行。除此之外， java.util 和 java.awt 之间没有命名冲突了，在不指定包名的情况下使用这两个包中的其他类型时，会“按需”将其导入。

###### 2.10.4 导入静态成员

除了类型之外，还可以使用关键字 import static 导入类型中的静态成员（静态成员在第 3 章说明。如果不熟悉这个概念，可以稍后再读这一节）。和类型导入声明一样，静态成员导入声明也有两种格式：单个静态成员导入和按需静态成员导入。假如你在编写一个基于文本的程序，要向 System.out 输出大量内容，那么可以使用下述单个静态成员导入声明减少输入的代码量：
```java
import static java.lang.System.out;
```
加入这个导入声明后，可以用 out.println() 代替 System.out.println()。又假如你编写的一个程序要使用 Math 类中的很多三角函数和其他函数。在这种明显要大量使用数字处理方法的程序中，重复输入类名“ Math”不会让代码的思路更清晰，反而会起到反作用。遇到这种情况，或许应该按需导入静态成员：
```java
import static java.lang.Math.*
```
加入这个导入声明后，可以编写 sqrt(abs(sin(x))) 这样简洁的表达式，而不用在每个静态方法前都加上类名 Math。

import static 声明另一个重要的作用是把常量导入代码，尤其适合导入枚举类型（参见第 4 章）。假如你想在自己编写的代码中使用下述枚举类型中的值：
```java
package climate.temperate;
enum Seasons { WINTER, SPRING, SUMMER, AUTUMN };
```
那么，可以导入 climate.temperate.Seasons，然后在常量前加上类型名，例如 Seasons.SPRING。如果想编写更简洁的代码，可以导入这个枚举类型中的值：
```java
import static climate.temperate.Seasons.*;
```
使用静态成员导入声明导入常量一般来说比实现定义常量的接口更好。

静态成员导入和重载的方法

静态成员导入声明导入的是“名称”，而不是以这个名称命名的某个具体成员。因为 Java 允许重载方法，也允许类型中的字段和方法同名，所以单个静态成员导入声明可能会导入多个成员。例如下述代码：
```java
import static java.util.Arrays.sort;
```
这个声明把名称“sort”导入命名空间，而没有导入 java.util.Arrays 里定义的 19 个 sort() 方法中的任何一个。如果使用导入的名称 sort 调用方法，编译器会根据方法的参数类型决定调用哪个方法。

从两个或多个不同的类型中导入同名的静态方法也是合法的，只要方法的签名不同就行。下面举个例子：
```java
import static java.util.Arrays.sort;
import static java.util.Collections.sort;
```
你可能觉得上述代码会导致句法错误，其实不然，因为 Collections 类中定义的 sort() 方法和 Arrays 类中定义的所有 sort() 方法签名都不一样。在代码中使用“ sort”这个名称时，编译器会根据参数的类型决定使用这 21 个方法中的哪一个。

##### 2.11 Java 文件的结构



##### 2.12 定义并运行 Java 程序



##### 2.13 小结


