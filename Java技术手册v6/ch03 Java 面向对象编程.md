#### 第 3 章 Java 面向对象编程

介绍 Java 基本句法之后，可以开始介绍 Java 面向对象编程了。所有 Java 程序都使用对象，对象的类型由类或接口定义。每个 Java 程序都定义成类，而复杂的程序会定义很多类和接口。本章说明如何定义新类，以及如何使用类进行面向对象编程。本章还会介绍接口的概念，但接口和 Java 的类型系统的详细介绍将在第 4 章进行。

> 不过，如果你有面向对象编程的经验，要小心。“面向对象”在不同的语言中有不同的含义。不要认为 Java 对面向对象的实现和你最喜欢的面向对象语言一样（C++ 和 Python 程序员尤其要注意）。

这一章的内容很多，下面先简要介绍一些基本概念。

##### 3.1 类简介

类是 Java 程序最基本的元素结构。编写 Java 代码不可能不定义类。所有 Java 语句都在类中，而且所有方法都在类中实现。

###### 3.1.1 面向对象的基本概念

下面是两个重要的概念。

- 类

类由一些保存值的数据字段和处理这些值的方法组成。类定义一种新的引用类型，例如第 2 章定义的 Point 类型。

Point 类定义的类型能表示所有二维点。

- 对象

对象是类的实例。

Point 对象是这个类型的一个值，即表示一个二维点。

对象一般通过实例化类创建，方法是使用 new 关键字并调用构造方法，如下所示：
```java
Point p = new Point(1.0, 2.0);
```
构造方法将在 3.3 节介绍。

一个类的定义包含一个签名和一个主体。类的签名定义类的名称，可能还会指定其他重要信息。类的主体是一些放在花括号里的成员。类的成员一般包含字段和方法，也可以包含构造方法、初始化程序和嵌套类型。

成员可以是静态的，也可以是非静态的。静态成员属于类本身，而非静态成员关联在类的实例上（参见 3.2 节）。

> 常见的成员有四种：类字段、类方法、实例字段和实例方法。Java 的主要工作就是与这些成员交互。

类的签名可能会声明它扩展自其他类。被扩展的类叫作超类，扩展其他类的类叫作子类。子类继承超类的成员，而且可以声明新成员，或者使用新的实现覆盖继承的方法。

类的成员可以使用访问修饰符 public、protected 或 private。这些修饰符指定成员在使用方和子类中是否可见以及能否访问。类通过这种方式控制对非公开 API 成员的访问。隐藏成员是一种面向对象设计技术，叫作数据封装（data encapsulation），3.5 节会介绍。

> 注 1：稍后会见到默认的可见性，即在包中可见。

###### 3.1.2 其他引用类型

类的签名可能还会声明类实现了一个或多个接口。接口是一种类似于类的引用类型，其中定义了方法签名，但一般没有实现方法的方法主体。

不过，从 Java 8 开始，接口可以使用关键字 default 指明其中的方法是可选的。如果方法是可选的，接口文件必须包含默认的实现（因此才选用 default 这个关键词）；所有实现这个接口的类，如果没有实现可选的方法，就使用接口中默认的实现。

实现接口的类必须为接口的非默认方法提供主体。实现某个接口的类的实例，也是这个接口类型的实例。

类和接口是 Java 定义的五种基本引用类型中最重要的两个。另外三个基本引用类型是数组、枚举类型和注解类型（通常直接叫“注解”）。第 2 章已经介绍过数组。枚举是特殊的类，注解是特殊的接口——第 4 章会介绍这两种类型，还会全面说明接口。

###### 3.1.3 定义类的句法

最简单的类定义方式是在关键字 class 后面放上类的名称，然后在花括号中放一些类的成员。class 关键字前面可以放修饰符关键字或注解。如果类扩展其他类，类名后面要加上 extends 关键字和要扩展的类名。如果类实现一个或多个接口，类名或 extends 子句之后要加上 implements 关键字和用逗号分隔的接口名。例如：
```java
public class Integer extends Number implements Serializable, Comparable {
    // 这里是类的成员
}
```
定义泛型类时还可以指定类型参数和通配符（参见第 4 章）。

类声明可以包含修饰符关键字。除访问控制修饰符（public、protected 等）之外，还可以使用：

- abstract

abstract 修饰的类未完全实现，不能实例化。只要类中有 abstract 修饰的方法，这个类就必须使用 abstract 声明。抽象类在 3.6 节介绍。

- final

final 修饰符指明这个类无法被扩展。类不能同时声明为 abstract 和 final。

- strictfp

如果类声明为 strictfp，那么其中所有的方法都声明为 strictfp。这个修饰符极少使用。

##### 3.2 字段和方法

类可以看成是由一些数据（也叫状态）和操作这些状态的代码组成的。数据存储在字段中，操作数据的代码则组织在方法中。

本节介绍两种最重要的类成员：字段和方法。字段和方法有两种不同的类型：关联在类自身上的类成员（也叫静态成员），关联在类的单个实例（即对象）身上的实例成员。因此，成员分为四类：

- 类字段
- 类方法
- 实例字段
- 实例方法

示例 3-1 定义了一个简单的类 Circle，包含所有这四种成员类型。
```java
//示例 3-1：一个简单的类及其成员
public class Circle {
    // 类字段
    public static final double PI= 3.14159; // 有用的常量
    
    // 类方法：基于参数计算得到一个值
    public static double radiansToDegrees(double radians) {
        return radians * 180 / PI;
    }
    
    // 实例字段
    public double r; // 圆的半径
    
    // 两个实例方法：处理对象的实例字段
    public double area() { // 计算圆的面积
        return PI * r * r;
    }
    
    public double circumference() { // 计算圆的周长
        return 2 * PI * r;
    }
}
```

> 一般来说公开 r 字段并不好，最好把 r 声明为私有字段，然后提供 radius()方法，获取它的值。原因在 3.5 节说明。现在，我们使用公开字段只是为了演示如何处理实例字段。

随后的几节说明这四种成员。首先，介绍声明字段的句法。声明方法的句法在 3.5 节介绍。

###### 3.2.1 声明字段的句法

声明字段的句法和声明局部变量的句法很像（参见第 2 章），不过声明字段时还可以使用修饰符。最简单的字段声明包含字段类型和字段名。类型前面可以放零个或多个修饰符关键字或注解，名称后面可以跟着一个等号和初始化表达式，提供字段的初始值。如果两个或多个字段的类型和修饰符都相同，那么可以把一些用逗号分隔的字段名和初始化表达式放在类型后面。如下是一些有效的字段声明：
```java
int x = 1;
private String name;
public static final int DAYS_PER_WEEK = 7;
String[] daynames = new String[DAYS_PER_WEEK];
private int a = 17, b = 37, c = 53;
```
字段的修饰符由零个或多个下述关键字组成。

- public、protected、private

这些访问控制修饰符指明字段是否能在定义它的类之外使用，以及能在何处使用。

- static

如果使用，这个修饰符指明字段关联在定义它的类自身上，而不是类的实例身上。

- final

这个修饰符指明，字段一旦初始化，其值就不能改变。如果字段同时使用 static 和 final 修饰，那么这个字段就是编译时常量，javac 会将其内联化。final 修饰的字段也可以用来创建实例不可变的类。

- transient

这个修饰符指明字段不是对象持久状态的一部分，无需跟对象的其他内容一起序列化。

- volatile

这个修饰符指明字段有额外的语义，可被两个或多个线程同时使用。volatile 修饰符的意思是，字段的值必须始终从主存储器中读取和释放，不能被线程缓存（在寄存器或 CPU 缓存中）。详情参见第 6 章。

###### 3.2.2 类字段

类字段关联在定义它的类身上，而不是类的实例身上。下面这行代码声明一个类字段：
```java
public static final double PI = 3.14159;
```
这行代码声明了一个字段，类型为 double，名称为 PI，并且把值设为 3.14159。

static 修饰符表明这个字段是类字段。因为使用了 static 修饰符，所以类字段有时也叫静态字段。final 修饰符表明这个字段的值不会改变。因为字段 PI 表示一个常量，而且声明时加上了 final，所以无法修改它的值。在 Java（以及很多其他语言）中，习惯使用大写字母命名常量，因此这个字段的名称是 PI，而不是 pi。类字段经常用来定义常量，也就是说，static 和 final 修饰符经常放在一起使用。然而，并不是所有类字段都是常量，因此字段可以声明为 static 但不声明为 final。

> 公开的静态字段要尽量声明为 final，因为多个线程都能修改字段的值，会导致极难调试的行为。

公开的静态字段其实就是全局变量。不过，类字段的名称会被定义它的类名限定，因此，如果不同的模块定义了同名的全局变量，Java 不会出现其他语言遇到的名称冲突问题。

关于静态字段，有个重点要理解，即字段的值只有一个副本。字段关联在类自身上，而不是类的实例身上。看一下 Circle 类中的各个方法，它们都使用了同一个字段。在 Circle 类内部，可以直接使用 PI 引用这个字段。但是在类的外部，既要使用类名也要使用字段名，这样才能引用这个独一无二的字段。Circle 类外部的方法要使用 Circle.PI 才能访问这个字段。

###### 3.2.3 类方法

和类字段一样，类方法也使用 static 修饰符声明：
```java
public static double radiansToDegrees(double rads) {
    return rads * 180 / PI;
}
```
上述代码声明了一个类方法，名为 radiansToDegrees()。这个方法只有一个参数，类型为 double，而且会返回一个 double 类型的值。

和类字段一样，类方法也关联在类身上，而不是对象身上。在类的外部调用类方法时，既
要指定类名也要指定方法名。例如：
```java
// 2.0弧度等于多少角度？
double d = Circle.radiansToDegrees(2.0);
```
如果想在定义类方法的类中调用类方法，则不用指定类名。还可以使用静态成员导入声明，减少输入的代码量（参见第 2 章）。

注意，Circle.radiansToDegrees() 方法的主体使用了类字段 PI。类方法可以使用所在类（或其他类）中的任何类字段和类方法。

类方法不能使用任何实例字段或实例方法，因为类方法不关联在类的实例身上。也就是说，虽然 radiansToDegrees() 方法在 Circle 类中定义，但它不能使用 Circle 对象的任何实例成员。

> 可以这样理解：在任何实例中，总有一个 this 引用指向当前对象，但类方法不关联在具体的实例身上，所以没有 this 引用，因此不能访问实例字段。

前面说过，类字段其实就是全局变量。类似地，类方法是全局方法，或全局函数。虽然 radiansToDegrees() 方法不处理 Circle 对象，但还是在 Circle 类中定义，因为它是一个实用方法，处理圆时有时会用到，因此可以把它和 Circle 类的其他功能放在一起。

###### 3.2.4 实例字段

声明时没使用 static 修饰符的字段是实例字段：
```java
public double r; // 圆的半径
```
实例字段关联在类的实例身上，所以创建的每个 Circle 对象都有自己的一个 double 类型 r 字段副本。在这个例子中，r 表示某个圆的半径。每个 Circle 对象的半径和其他所有 Circle 对象的都不同。

在类定义内部，实例字段只通过名称引用。在实例方法 circumference() 的主体中有一个例子。在类外部，实例字段的名称前面必须加上包含这个字段的对象的引用。例如，如果变量 c 保存的是一个 Circle 对象的引用，那么可以使用表达式 c.r 引用这个圆的半径：
```java
Circle c = new Circle(); // 创建一个Circle对象，把引用存储在c中
c.r = 2.0; // 把一个值赋值给实例字段r
Circle d = new Circle(); // 再创建一个Circle对象
d.r = c.r * 2; // 让这个圆是前一个的两倍大
```
实例字段是面向对象编程的关键。实例字段保存对象的状态，实例字段的值把两个对象区分开来。

###### 3.2.5 实例方法

实例方法处理类的具体实例（对象），只要声明方法时没使用 static 关键字，这个方法默认就是实例方法。

实例方法这个特性让面向对象编程开始变得有趣。示例 3-1 中定义的 Circle 类包含两个实例方法，area() 和 circumference()，分别计算指定 Circle 对象表示的圆的面积和周长。

若想在定义实例方法的类之外使用实例方法，必须在方法名前加上要处理的实例引用。例如：
```java
// 创建一个Circle对象，存储在变量c中
Circle c = new Circle();
c.r = 2.0; // 设定这个对象的实例字段
double a = c.area(); // 调用这个对象的实例方法
```

> 这就是叫面向对象编程的原因，这里对象是重点，而不是函数调用。

在实例方法内部，可以自然地访问属于调用这个方法的对象的实例字段。前面说过，经常可以把对象理解为包含状态（通过对象的字段表示）和行为（处理状态的方法）的包（bundle）。

实现所有实例方法时都使用了一个隐式参数，方法签名里没显示这个参数。这个隐式参数是 this，它的值是调用这个方法的对象引用。在我们的例子中，是一个 Circle 对象。

> area() 和 circumference() 两个方法的主体都使用了类字段 PI。前面说过，类方法只能使用类字段和类方法，而不能使用实例字段或实例方法。实例方法没有这种限制，不管类中的成员有没有声明为 static，实例方法都可以使用。

###### 3.2.6 this 引用的工作方式

方法签名中不显示隐式参数 this，是因为往往用不到。只要 Java 方法在类中访问实例字段，都默认访问 this 参数指向的对象中的字段。实例方法调用同一个类中的其他实例方法时也一样，可以理解为“在当前对象上调用实例方法”。

不过，如果想明确表明方法访问的是自己的字段或方法，可以显式使用 this 关键字。例如，可以改写 area() 方法，显式使用 this 引用实例字段：
```java
public double area() { return Circle.PI * this.r * this.r; }
```
上述代码还显式使用类名引用类字段 PI。在这样简单的方法中，一般无需如此明确。然而，遇到复杂情况时，在不强制要求使用 this 的地方使用 this，有时可以让代码的意图更明确。

不过，有些情况下必须使用 this 关键字。例如，如果方法的参数或方法中的局部变量和类中的某个字段同名，那么就必须使用 this 引用这个字段，因为只使用字段名的话，引用的是方法的参数或局部变量。

例如，可以把下述方法添加到 Circle 类中：
```java
public void setRadius(double r) {
    this.r = r; // 把参数r的值赋值给字段this.r
    // 注意，不能写成r = r
}
```
有些开发者会谨慎选择方法的参数名，避免和字段名冲突，因此可以最大限度地少使用 this。

最后，注意，实例方法可以使用 this 关键字，但类方法不能使用。这是因为类方法不关联在单个对象身上。

##### 3.3 创建和初始化对象

介绍字段和方法之后，接下来要介绍类的其他重要成员。具体而言，我们要介绍构造方法。构造方法是类成员，作用是初始化新建实例中的字段。

再看一下创建 Circle 对象的方式：
```java
Circle c = new Circle();
```
这行代码的意思是，调用看起来有点儿像方法的东西创建一个新 Circle 实例。其实，Circle() 是一种构造方法，是类中的成员，和类同名，而且像方法一样，有主体。

构造方法的工作方式是这样的：new 运算符表明我们想创建类的一个新实例。首先，分配内存存储新建的对象实例；然后，调用构造方法的主体，并传入指定的参数；最后，构造方法使用这些参数执行初始化新对象所需的一切操作。

Java 中的每个类都至少有一个构造方法，其作用是执行初始化新对象所需的操作。示例 3-1 定义的 Circle 类没有显式定义构造方法，因此 javac 编译器自动为我们提供了一个构造方法（叫作默认构造方法）。这个构造方法没有参数，而且不执行任何特殊的初始化操作。

###### 3.3.1 定义构造方法

可是 Circle 对象显然要做些初始化操作，下面就来定义一个构造方法。示例 3-2 重新定义了 Circle 类，包含一个构造方法，指定新建 Circle 对象的半径。借此机会，我们还把 r 字段改成了受保护的（禁止对象随意访问）。

```java
//示例 3-2：为 Circle 类定义一个构造方法
public class Circle {
    public static final double PI = 3.14159; // 常量
    // 实例字段，保存圆的半径
    protected double r;
    
    // 构造方法：初始化r字段
    public Circle(double r) { this.r = r; }
    
    // 实例方法：基于半径计算得到值
    public double circumference() { return 2 * PI * r; }
    public double area() { return PI * r*r; }
    public double radius() { return r; }
}
```
如果依赖编译器提供的默认构造方法，就要编写如下的代码显式初始化半径：
```java
Circle c = new Circle();
c.r = 0.25;
```
添加上述构造方法后，初始化变成创建对象过程的一部分：
```java
Circle c = new Circle(0.25);
```
下面是一些关于命名、声明和编写构造方法的基本注意事项。

- 构造方法的名称始终和类名一样。
- 声明构造方法时不指定返回值类型，连 void 都不用。
- 构造方法的主体初始化对象。可以把主体的作用想象为设定 this 引用的内容。
- 构造方法不能返回 this 或任何其他值。

###### 3.3.2 定义多个构造方法

有时，根据遇到的情况，可能想在多个不同的方式中选择一个最便利的方式初始化对象。例如，我们可能想使用指定的值初始化圆的半径，或者使用一个合理的默认值初始化。为 Circle 类定义两个构造方法的方式如下：
```java
public Circle() { r = 1.0; }
public Circle(double r) { this.r = r; }
```
Circle 类只有一个实例字段，由此并没有太多的初始化方式。不过在复杂的类中，经常会定义不同的构造方法。

只要构造方法的参数列表不同，为一个类定义多个构造方法完全是合法的。编译器会根据提供的参数数量和类型判断你想使用的是哪个构造方法。定义多个构造方法和方法重载的原理类似。

###### 3.3.3 在一个构造方法中调用另一个构造方法

如果类有多个构造方法，会用到 this 关键字的一种特殊用法。在一个构造方法中可以使用 this 关键字调用同一个类中的另一个构造方法。因此，前面 Circle 类的两个构造方法可以改写成：
```java
// 这是基本构造方法：初始化半径
public Circle(double r) { this.r = r; }
// 这个构造方法使用this()调用前一个构造方法
public Circle() { this(1.0); }
```
如果一些构造方法共用大量的初始化代码，这种技术是有用的，因为能避免代码重复。如果构造方法执行很多初始化操作，在这种复杂的情况下，这种技术十分有用。

使用 this() 时有个重大的限制：只能出现在构造方法的第一个语句中。但是，调用这个方法后，可以执行构造方法所需的任何其他初始化操作。这个限制的原因涉及自动调用超类的构造方法，本章后面会说明。

###### 3.3.4 字段的默认值和初始化程序

类中的字段不一定要初始化。如果没有指定初始值，字段自动使用默认值初始化：false、\u0000、0、0.0 或 null。具体使用哪个值，根据字段的类型而定（详情参见表 2-1）。这些默认值由 Java 语言规范规定，实例字段和类字段都适用。

如果字段的默认值不适合字段，可以显式提供其他的初始值。例如：
```java
public static final double PI = 3.14159;
public double r = 1.0;
```

> 字段声明不是任何方法的一部分。Java 编译器会自动为字段生成初始化代码，然后把这些代码放在类的所有构造方法中。这些初始化代码按照字段在源码中出现的顺序插入构造方法，因此，字段的初始化程序可以使用在其之前声明的任何字段的初始值。

例如下述代码片段是一个假设类，定义了一个构造方法和两个实例字段：
```java
public class SampleClass {
    public int len = 10;
    public int[] table = new int[len];
    
    public SampleClass() {
       for(int i = 0; i < len; i++) table[i] = i;
    }
    // 类余下的内容省略了……
}
```
对这个例子来说，javac 生成的构造方法其实和下述代码等效：
```java
public SampleClass() {
    len = 10;
    table = new int[len];
    for(int i = 0; i < len; i++) table[i] = i;
}
```
如果某个构造方法的开头使用 this() 调用其他构造方法，那么字段的初始化代码不会出现在这个构造方法中。此时，初始化由 this() 调用的构造方法处理。

既然实例字段在构造方法中初始化，那么类字段在哪初始化呢？就算从不创建类的实例，类字段也关联在类身上。这意味着，类字段要在调用构造方法之前初始化。

为此，javac 会为每个类自动生成一个类初始化方法。类字段在这个方法的主体中初始化。这个方法只在首次使用类之前调用一次（经常是在 Java 虚拟机首次加载类时）。

和实例字段的初始化一样，类字段的初始化表达式按照类字段在源码中的顺序插入类初始化方法。因此，类字段的初始化表达式可以使用在其之前声明的类字段。类初始化方法是内部方法，对 Java 程序员不可见。在类文件中，它的名称是 \<clinit\>（例如，使用 javap检查类文件时可以看到这个方法。第 13 章会详细介绍如何使用 javap 执行这项操作）。

初始化程序块

至此，我们知道对象可以通过字段的初始化表达式和构造方法中的任何代码初始化。类有一个类初始化方法，这个方法和构造方法不一样，不能像构造方法那样显式定义主体。不过，Java 允许编写用于初始化类字段的代码，所用的结构叫静态初始化程序。静态初始化程序由 static 关键字及随后的花括号中的代码块组成。在类定义中，静态初始化程序可以放在字段和方法定义能出现的任何位置。例如，下述代码为两个类字段执行一些重要的初始化操作：
```java
// 我们可以使用三角函数画出圆的轮廓
// 不过，三角函数很慢，所以预先算出一些值
public class TrigCircle {
    // 这是静态查找表和各自的初始化程序
    private static final int NUMPTS = 500;
    private static double sines[] = new double[NUMPTS];
    private static double cosines[] = new double[NUMPTS];
    
    // 这是一个静态初始化程序，填充上述数组
    static {
       double x = 0.0;
       double delta_x = (Circle.PI/2)/(NUMPTS-1);
       for(int i = 0, x = 0.0; i < NUMPTS; i++, x += delta_x) {
           sines[i] = Math.sin(x);
           cosines[i] = Math.cos(x);
       }
    }
    // 类余下的内容省略了……
}
```
一个类可以有任意多个静态初始化程序。各个初始化程序块的主体会和所有静态字段的初始化表达式一起合并到类初始化方法中。静态初始化程序和类方法的相同点是，不能使用 this 关键字，也不能使用类中的任何实例字段或实例方法。

类还可以有实例初始化程序。实例初始化程序和静态初始化程序类似，不过初始化的是对象而不是类。一个类可以有任意多个实例初始化程序，而且实例初始化程序可以放在字段和方法定义能出现的任何位置。各个实例初始化程序的主体和所有实例字段初始化表达式一起，放在类中每个构造方法的开头。实例初始化程序的外观和静态初始化程序类似，不过不使用 static 关键字。也就是说，实例初始化程序只是放在花括号里的任意 Java 代码。

实例初始化程序可以初始化数组或其他需要复杂初始化操作的字段。实例初始化程序有时很有用，因为它们把初始化代码放在字段后面，而不是单独放在构造方法中。例如：
```java
private static final int NUMPTS = 100;
private int[] data = new int[NUMPTS];
{ for(int i = 0; i < NUMPTS; i++) data[i] = i; }
```
不过，现实中很少使用实例初始化程序。

##### 3.4 子类和继承

前面定义的 Circle 是个简单的类，只通过半径区分不同的圆。假设我们要同时使用大小和位置表示圆。例如，在笛卡儿平面中，圆心在 (0, 0)、半径为 1.0 的圆，与圆心在 (1, 2)、半径为 1.0 的圆不同。为此，需要一个新类，我们称其为 PlaneCircle。

我们想添加表示圆所在位置的功能，但不想失去 Circle 类的任何现有功能。为此，可以把 PlaneCircle 类定义为 Circle 类的子类，让 PlaneCircle 类继承超类 Circle 的字段和方法。通过定义子类或扩展超类向类中添加功能的能力，是面向对象编程范式的核心。

###### 3.4.1 扩展类

示例 3-3 展示了如何把 PlaneCircle 类定义为 Circle 类的子类。
```java
//示例 3-3：扩展 Circle 类
public class PlaneCircle extends Circle {
    // 自动继承了Circle类的字段和方法，
    // 因此只要在这里编写新代码
    // 新实例字段，存储圆心的位置
    private final double cx, cy;
    
    // 新构造方法，用于初始化新字段
    // 使用特殊的句法调用构造方法Circle()
    public PlaneCircle(double r, double x, double y) {
        super(r); // 调用超类的构造方法Circle()
        this.cx = x; // 初始化实例字段cx
        this.cy = y; // 初始化实例字段cy
    }
    
    public double getCentreX() {
        return cx;
    }
    
    public double getCentreY() {
        return cy;
    }
    
    // area()和circumference()方法继承自Circle类
    // 新实例方法，检查点是否在圆内
    // 注意，这个方法使用了继承的实例字段r
    public boolean isInside(double x, double y) {
        double dx = x - cx, dy = y - cy; // 到圆心的距离
        double distance = Math.sqrt(dx*dx + dy*dy); // 勾股定理
        return (distance < r); // 返回true或false
    }
}
```
注意示例 3-3 第一行中使用的 extends 关键字。这个关键字告诉 Java，PlaneCircle 类扩展 Circle 类（或者说是 Circle 类的子类），这意味着 PlaneCircle 类会继承 Circle 类的字段和方法。

> 有多种方式能表达新对象类型具有 Circle 的特征，而且有位置。这或许是最简单的方式，但不一定是最合适的方式，尤其是在大型系统中。

isInside() 方法的定义展示了字段继承：这个方法使用了字段 r（由 Circle 类定义），就像这个字段是在 PlaneCircle 中定义的一样。PlaneCircle 还继承了 Circle 的方法。因此，如果变量 pc 保存的值是一个 PlaneCircle 对象引用，那么可以编写如下代码：
```java
double ratio = pc.circumference() / pc.area();
```
这么做就好像 area() 和 circumference() 两个方法是在 PlaneCircle 中定义的一样。

子类的另一个特性是，每个 PlaneCircle 对象都是完全合法的 Circle 对象。如果 pc 是一个 PlaneCircle 对象的引用，那么可以把这个引用赋值给 Circle 类型的变量，忽略它表示的位置：
```java
// 位置在原点的单位圆
PlaneCircle pc = new PlaneCircle(1.0, 0.0, 0.0);
Circle c = pc; // 无需校正，赋值给Circle类型的变量
```
把 PlaneCircle 对象赋值给 Circle 类型的变量时无需校正。第 2 章说过，这种转换完全合法。Circle 类型的变量 c 中保存的值仍然是有效的 PlaneCircle 对象，但编译器不确定这一点，因此不校正无法反向（缩小）转换：
```java
// 缩小转换需要校正（虚拟机还要做运行时检查）
PlaneCircle pc2 = (PlaneCircle) c;
boolean origininside = ((PlaneCircle) c).isInside(0.0, 0.0);
```
4.5 节介绍编译时和运行时对象类型的区别时会详细说明这两种转换之间的不同。

final类

如果声明类时使用了 final 修饰符，那么这个类无法被扩展或定义子类。java.lang.String 是 final 类的一个示例。把类声明为 final 可以避免不需要的类扩展：在 String 对象上调用方法时，就算 String 类来自某个未知的外部源，你也知道这个方法是在 String 类中定义的。

###### 3.4.2 超类、对象和类层次结构

在这个示例中，PlaneCircle 是 Circle 的子类，也可以说 Circle 是 PlaneCircle 的超类。类的超类在 extends 子句中指定：
```java
public class PlaneCircle extends Circle { ... }
```
你定义的每个类都有超类。如果没使用 extends 子句指定超类，那么超类是 java.lang.Object。Object 是特殊的类，原因有如下两个：

- 它是 Java 中唯一一个没有超类的类；
- 所有 Java 类都从 Object 类中继承方法。

因为每个类（除了 Object 类）都有超类，所以 Java 中的类组成一个类层次结构。这个体系可以使用一个根为 Object 类的树状图表示。

> Object 类没有超类，而且其他每个类都只有一个超类。子类扩展的超类不能超过一个。第 4 章会详细说明如何实现类似的效果。

图 3-1 展示的是类层次结构的一部分，包含我们定义的 Circle 和 PlaneCircle 类，以及 Java API 中的一些标准类。

<img src="img\图 3-1：类层次结构图.png" style="zoom:80%;" />

###### 3.4.3 子类的构造方法

再看一下示例 3-3 中的 PlaneCircle() 构造方法：
```java
public PlaneCircle(double r, double x, double y) {
    super(r); // 调用超类的构造方法Circle()
    this.cx = x; // 初始化实例字段cx
    this.cy = y; // 初始化实例字段cy
}
```
虽然这个构造方法显式初始化了 PlaneCircle 类中新定义的字段 cx 和 cy，但仍使用超类的 Circle() 构造方法初始化继承的字段。为了调用超类的构造方法，这个构造方法调用了 super() 方法。

super 是 Java 的保留字。它的用法之一是，在子类的构造方法中调用超类的构造方法。这种用法和在一个构造方法中使用 this() 调用同一个类中的其他构造方法类似。使用 super() 调用构造方法和使用 this() 调用构造方法有同样的限制：

- 只能在构造方法中像这样使用 super()；
- 必须在构造方法的第一个语句中调用超类的构造方法，甚至要放在局部变量声明之前。

传给 super() 的实参必须与超类构造方法的形参匹配。如果超类定义了多个构造方法，那么 super() 可以调用其中任何一个，具体是哪个，由传入的参数决定。

###### 3.4.4 构造方法链和默认构造方法

创建类的实例时，Java 保证一定会调用这个类的构造方法；创建任何子类的实例时，Java 还保证一定会调用超类的构造方法。为了保证第二点，Java 必须确保每个构造方法都会调用超类的构造方法。

因此，如果构造方法的第一个语句没有使用 this() 或 super() 显式调用另一个构造方法，javac 编译器会插入 super()（即调用超类的构造方法，而且不传入参数）。如果超类没有无需参数的可见构造方法，这种隐式调用会导致编译出错。

以 PlaneCircle 类为例，创建这个类的新实例时会发生下述事情：

- 首先，调用 PlaneCircle 类的构造方法；
- 这个构造方法显示调用了 super(r)，调用 Circle 类的一个构造方法；
- Circle() 构造方法会隐式调用 super()，调用 Circle 的超类 Object 的构造方法（Object 只有一个构造方法）；
- 此时，到达层次结构的顶端了，接下来开始运行构造方法；
- 首先运行 Object 构造方法的主体；
- 返回后，再运行 Circle() 构造方法的主体；
- 最后，对 super(r) 的调用返回后，接着执行 PlaneCircle() 构造方法中余下的语句。

这个过程表明，构造方法链在一起调用；只要创建对象，就会调用一系列构造方法，从子类到超类，一直向上，直到类层次结构的顶端 Object 类为止。因为超类的构造方法始终在子类的构造方法的第一个语句中调用，所以 Object 类的构造方法的主体始终最先运行，然后运行 Object 的子类的构造方法，就这样沿着类层次结构一直向下，直到实例化的那个类为止。

> 调用构造方法时，超类中的字段也会被初始化。

默认构造方法

前面对构造方法链的说明漏了一点。如果构造方法没有调用超类的构造方法，Java 会隐式调用。那么，如果类没有声明构造方法呢？此时，Java 会为类隐式添加一个构造方法。这个默认的构造方法什么也不做，只是调用超类的构造方法。

例如，如果没为 PlaneCircle 类声明构造方法，那么 Java 会隐式插入下述构造方法：
```java
public PlaneCircle() { super(); }
```
如果超类 Circle 没有声明无参数的构造方法，那么在这个自动插入 PlaneCircle() 类的默认构造方法中调用 super() 会导致编译出错。一般来说，如果类没有定义无参数的构造方法，那么它的所有子类必须定义显式调用超类构造方法的构造方法，而且要传入所需的参数。

如果类没有定义任何构造方法，默认会为其提供一个无参数的构造方法。声明为 public 的类，提供的构造方法也声明为 public。提供给其他类的默认构造方法则不使用任何可见性修饰符，这些构造方法具有默认的可见性。（本章后面会说明指定可见性的方式。）

如果创建的 public 类不能公开实例化，就应该至少声明一个非 public 的构造方法，以此避免插入默认的 public 构造方法。从来不会实例化的类（例如 java.lang.Math 或 java.lang.System），应该定义一个 private 构造方法。这种构造方法不能在类外部调用，但可以避免自动插入默认的构造方法。

###### 3.4.5 遮盖超类的字段

假如 PlaneCircle 类需要知道圆心到原点 (0, 0) 的距离，我们可以再添加一个实例字段保存这个值：
```java
public double r;
```
在构造方法中添加下述代码可以算出这个字段的值：
```java
this.r = Math.sqrt(cx*cx + cy*cy); // 勾股定理
```
但是等一下，这个新添加的字段 r 和超类 Circle 中表示半径的字段 r 同名了。发生这种情况时，我们说，PlaneCircle 类的 r 字段遮盖了 Circle 类的 r 字段。（当然，这个例子是故意这么做的。新字段其实应该命名为 distanceFromOrigin。）

> 在你编写的代码中，为字段命名时应该避免遮盖超类的字段。如果遮盖了，几乎就表明代码写得不好。

这样定义 PlaneCircle 类之后，表达式 r 和 this.r 都引用 PlaneCircle 类中的这个字段。那么，如何引用 Circle 类中保存圆的半径的 r 字段呢？有一种特殊的句法可以实现这个需求——使用 super 关键字：
```java
r // 引用PlaneCircle的字段
this.r // 引用PlaneCircle的字段
super.r // 引用Circle的字段
```
引用被遮盖的字段还有一种方式——把 this（或类的实例）校正为适当的超类，然后再访问字段：
```java
((Circle) this).r // 引用Circle类的字段
```
如果想引用的遮盖字段不是在类的直接超类中定义的，这种校正技术特别有用。假如有三个类 A、B 和 C，它们都定义了一个名为 x 的字段，而且 C 是 B 的子类，B 是 A 的子类。那么，在 C 类的方法中可以按照下面的方式引用这些不同的字段：
```java
x // C类的x字段
this.x // C类的x字段
super.x // B类的x字段
((B)this).x // B类的x字段
((A)this).x // A类的x字段
super.super.x // 非法，不能这样引用A类的x字段
```

> 不能使用 super.super.x 引用超类的超类中的遮盖字段 x。这种句法不合法。

类似地，如果 c 是 C 类的实例，那么可以像这样引用这三个字段：
```java
c.x // C类的x字段
((B)c).x // B类的x字段
((A)c).x // A类的x字段
```
目前为止，讨论的都是实例字段。类字段也能被遮盖。引用被遮盖的类字段中的值，可以使用相同的 super 句法，但没必要这么做，因为始终可以把类名放在类字段前引用这个字段。假如 PlaneCircle 的实现方觉得 Circle.PI 字段没有提供足够的小数位，那么他可以自己定义 PI 字段：
```java
public static final double PI = 3.14159265358979323846;
```
现在，PlaneCircle 类中的代码可以通过表达式 PI 或 PlaneCircle.PI 使用这个更精确的值，还可以使用表达式 super.PI 和 Circle.PI 引用精度不高的旧值。不过，PlaneCircle 继承的 area() 和 circumference() 方法是在 Circle 类中定义的，所以，就算 Circle.PI 被 PlaneCircle.PI 遮盖了，这两个方法还是会使用 Circle.PI 的值。

###### 3.4.6 覆盖超类的方法

如果类中定义的某个实例方法和超类的某个方法有相同的名称、返回值类型和参数，那么这个方法会覆盖（override）超类中对应的方法。在这个类的对象上调用这个方法时，调用的是新定义的方法，而不是超类中定义的旧方法。

> 覆盖方法的返回值类型可以是原方法返回值的子类（没必要一模一样）。这叫作协变返回（covariant return）。

方法覆盖是面向对象编程中一项重要且有用的技术。PlaneCircle 没有覆盖 Circle 类定义的任何方法，不过，假设我们要再定义一个 Circle 的子类，名为 Ellipse。

此时，Ellipse 一定要覆盖 Circle 的 area() 和 circumference() 方法，因为计算圆的面积和周长的公式不适用于椭圆。

下面针对方法覆盖的讨论只涉及实例方法。类方法的运作机制完全不同，无法覆盖。和字段一样，类方法也能被子类遮盖，但不能覆盖。本章前面说过，好的编程风格是调用类方法时始终在前面加上定义这个方法的类名。如果把类名当成方法名的一部分，那么这两个方法的名称就不一样，因此其实并没有遮盖什么。

在进一步讨论方法覆盖之前，要理解方法覆盖和方法重载之间的区别。第 2 章说过，方法重载指的是（在同一个类中）定义多个名称相同但参数列表不同的方法。这和方法覆盖十分不同，因此别混淆了。

1. 覆盖不是遮盖

虽然 Java 使用很多类似的方式对待字段和方法，但方法覆盖和字段遮盖一点儿都不一样。为了引用遮盖的字段，只需把对象校正成适当超类的实例，但不能使用这种技术调用覆盖的实例方法。下述代码展示了这个重要区别：
```java
class A { // 定义一个类，名为A
    int i = 1; // 一个实例字段
    int f() { return i; } // 一个实例方法
    static char g() { return 'A'; } // 一个类方法
}

class B extends A { // 定义A的一个子类
    int i = 2; // 遮盖A类的字段i
    int f() { return -i; } // 覆盖A类的方法f
    static char g() { return 'B'; } // 遮盖A类的类方法g()
}

public class OverrideTest {
    public static void main(String args[]) {
        B b = new B(); // 创建一个类型为B的新对象
        System.out.println(b.i); // 引用B.i，打印2
        System.out.println(b.f()); // 引用B.f()，打印-2
        System.out.println(b.g()); // 引用B.g()，打印B
        System.out.println(B.g()); // 调用B.g()更好的方式
        
        A a = (A) b; // 把b校正成A类的实例
        System.out.println(a.i); // 现在引用的是A.i，打印1
        System.out.println(a.f()); // 还是引用B.f()，打印-2
        System.out.println(a.g()); // 引用A.g()，打印A
        System.out.println(A.g()); // 调用A.g()更好的方式
    }
}
```
初看起来，可能觉得方法覆盖和字段遮盖的这种区别有点奇怪，但稍微想想，确实有道理。

假设我们要处理一些 Circle 和 Ellipse 对象。为了记录这些圆和椭圆，我们把它们存储在一个 Circle[] 类型的数组中。这么做是可以的，因为 Ellipse 是 Circle 的子类，所以所有 Ellipse 对象都是合法的 Circle 对象。

遍历这个数组的元素时，不需要知道也无需关心元素是 Circle 对象还是 Ellipse 对象。不过，需要密切关注的是，在数组的元素上调用 area() 方法是否能得到正确的值。也就是说，如果是椭圆对象就不能使用计算圆面积的公式。

我们真正希望的是，计算面积时对象能“做正确的事”：Circle 对象使用自己的方式计算，Ellipse 对象使用对椭圆来说正确的方式计算。

这样理解，就不会对 Java 使用不同的方式处理方法覆盖和字段遮盖感到奇怪了。

2. 虚拟方法查找

如果一个 Circle[] 类型的数组保存的是 Circle 和 Ellipse 对象，那么编译器怎么知道要在具体的元素上调用 Circle 类还是 Ellipse 类的 area() 方法呢？事实上，源码编译器在编译时并不知道要调用哪个方法。

不过，javac 生成的字节码会在运行时使用“虚拟方法查找”（virtual method lookup）。解释器运行代码时，会查找适用于数组中各个对象的 area() 方法。即，解释器解释表达式 o.area() 时，会检查变量 o 引用的对象的真正运行时类型，然后找到适用于这个类型的 area() 方法。

> 某些其他语言（例如 C# 和 C++）默认不使用虚拟查找，如果程序员想在子类中覆盖方法，要显式使用 virtual 关键字。

JVM 不会直接使用关联在变量 o 表示的静态类型身上的 area() 方法，如果这么做，前面详述的方法覆盖机制就不成立了。Java 的实例方法默认使用虚拟查找。第 4 章会详细介绍编译时和运行时类型，以及它们对虚拟方法查找的影响。

3. 调用被覆盖的方法

我们已经说明了方法覆盖和字段遮盖之间的重要区别。然而，调用被覆盖的方法的 Java 句法和访问被遮盖的字段的句法十分类似——都使用 super 关键字。如下述代码所示：
```java
class A {
    int i = 1; // 被子类B遮盖的实例字段
    int f() { return i; } // 被子类B覆盖的实例方法
}
 
class B extends A {
    int i; // 这个字段遮盖A类的字段i
    int f() { // 这个方法覆盖A类的方法f()
        i = super.i + 1; // 可以像这样读取A.i的值
        return super.f() + i; // 可以像这样调用A.f()
    }
}
```
前面说过，使用 super 引用被遮盖的字段时，相当于把 this 校正为超类类型，然后通过超类类型访问字段。不过，使用 super 调用被覆盖的方法和校正 this 引用不是一回事。也就是说，在上述代码中，表达式 super.f() 和 ((A)this).f() 的作用不一样。

解释器使用 super 句法调用实例方法时，会执行一种修改过的虚拟方法查找。第一步和常规的虚拟方法查找一样，确定调用方法的对象属于哪个类。正常情况下，运行时会在这个类中寻找对应的方法定义。但是，使用 super 句法调用方法时，先在这个类的超类中查找。如果超类直接实现了这个方法，那就调用这个方法。如果超类继承了这个方法，那就调用继承的方法。

注意，super 关键字调用的是方法的直接覆盖版本。假设 A 类有个子类 B，B 类有个子类 C，而且这三个类都定义了同一个方法 f()。在 C.f() 方法中使用 super.f() 可以调用方法 B.f()，因为 C.f() 直接覆盖了 B.f()。但是，C.f() 不能直接调用 A.f()，因为 super.super.f() 不是合法的 Java 句法。当然，如果 C.f() 调用了 B.f()，有合理的理由认为，B.f() 可能会调用 A.f()。

使用被覆盖的方法时，这种链式调用相当常见。覆盖方法是增强方法功能，但不完全取代这个方法的一种方式。

> 别把调用被覆盖方法的 super 和构造方法中调用超类构造方法的 super() 搞混了。虽然二者使用的关键字相同，但却是两种完全不同的句法。具体而言，可以在类中的任何位置使用 super 调用超类中被覆盖的方法，但是只能在构造方法的第一个语句中使用 super() 调用超类的构造方法。

还有一点很重要，即记住，只能在覆盖某个方法的类内部使用 super 调用被覆盖的方法。假如 e 引用的是一个 Ellipse 对象，那么无法在 e 上调用 Circle 类中定义的 area() 方法。

##### 3.5 数据隐藏和封装

本章开头说过，类由一些数据和方法组成。目前，我们尚未说明的最重要的面向对象技术之一是，把数据隐藏在类中，只能通过方法获取。这种技术叫作封装（encapsulation），因为它把数据（和内部方法）安全地密封在类这个“容器”中，只能由可信的用户（即这个类中的方法）访问。

为什么要这么做呢？最重要的原因是，隐藏类的内部实现细节。如果避免让程序员依赖这些细节，你就可以放心地修改实现，而无需担心会破坏使用这个类的现有代码。

> 你应该始终封装自己的代码。如果没有封装好，那么几乎无法推知并最终确认代码是否正确，尤其是在多线程环境中（而基本上所有 Java 程序都运行在多线程环境中）。

使用封装的另一个原因是保护类，避免有意或无意做了糊涂事。类中经常包含一些相互依赖的字段，而且这些字段的状态必须始终如一。如果允许程序员（包括你自己）直接操作这些字段，修改某个字段后可能不会修改重要的相关字段，那么类的状态就前后不一致了。然而，如果必须调用方法才能修改字段，那么这个方法可以做一切所需的措施，确保状态一致。类似地，如果类中定义的某些方法仅供内部使用，隐藏这些方法能避免这个类的用户调用这些方法。

封装还可以这样理解：把类的数据都隐藏后，方法就是在这个类的对象上能执行的唯一一种可能的操作。

只要小心测试和调试方法，就可以认为类能按预期的方式运行。然而，如果类的所有字段都可以直接操作，那么要测试的可能性根本数不完。

> 这种想法可以得到一个非常重要的推论，5.5 节介绍 Java 程序的安全性时会说明（Java 程序的安全和 Java 编程语言的类型安全不是同一个概念）。

隐藏类的字段和方法还有一些次要的原因。

- 如果内部字段和方法在外部可见，会弄乱类的 API。让可见的字段尽量少，可以保持类
的整洁，从而更易于使用和理解。
- 如果方法对类的使用者可见，就必须为其编写文档。把方法隐藏起来，可以节省时间和
精力。

###### 3.5.1 访问控制

Java 定义了一些访问控制规则，可以禁止类的成员在类外部使用。在本章的一些示例中，你已经见过字段和方法声明中使用的 public 修饰符。这个 public 关键字，连同 protected 和 private（还有一个特殊的），是访问控制修饰符，为字段或方法指定访问规则。

1. 访问包

Java 语言不直接支持包的访问控制。访问控制一般在类和类的成员这些层级完成。

> 已经加载的包始终可以被同一个包中的代码访问。一个包在其他包中是否能访问，取决于这个包在宿主系统中的部署方式。例如，如果组成包的类文件存储在一个目录中，那么用户必须能访问这个目录和其中的文件才能访问包。

2. 访问类

默认情况下，顶层类在定义它的包中可以访问。不过，如果顶层类声明为 public，那么在任何地方都能访问。

> 第 4 章会介绍嵌套类。嵌套类是定义为其他类的成员的类。因为这种内部类是某个类的成员，因此也遵守成员的访问控制规则。

3. 访问成员

类的成员在类的主体里始终可以访问。默认情况下，在定义这个类的包中也可以访问成员。这种默认的访问等级一般叫作包访问。这只是四个可用的访问等级中的一个。其他三个等级使用 public、protected 和 private 修饰符定义。下面是使用这三个修饰符的示例代码：
```java
public class Laundromat { // 所有人都可以使用这个类
    private Laundry[] dirty; // 不能使用这个内部字段
    public void wash() { ... } // 但能使用这两个公开的方法
    public void dry() { ... } // 处理内部字段
    // 子类可能会想调整这个字段
    protected int temperature;
}
```
下述访问规则适用于类的成员。

- 类中的所有字段和方法在类的主体里始终可以使用。
- 如果类的成员使用 public 修饰符声明，那么可以在能访问这个类的任何地方访问这个成员。这是限制最松的访问控制类型。
- 如果类的成员声明为 private，那么除了在类内部之外，其他地方都不能访问这个成员。这是限制最严的访问控制类型。
- 如果类的成员声明为 protected，那么包里的所有类都能访问这个成员（等同于默认的包访问规则），而且在这个类的任何子类的主体中也能访问这个成员，而不管子类在哪个包中定义。
- 如果声明类的成员时没使用任何修饰符，那么使用默认的访问规则（有时叫包访问），
包中的所有类都能访问这个成员，但在包外部不能访问。

> 默认的访问规则比 protected 严格，因为默认规则不允许在包外部的子类中访问成员。

使用 protected 修饰的成员时要格外小心。假设 A 类使用 protected 声明了一个字段 x，而且在另一个包中定义的 B 类继承 A 类（重点是 B 类在另一包中定义）。因此，B 类继承了这个 protected 声明的字段 x，那么，在 B 类的代码中可以访问当前实例的这个字段，而且引用 B 类实例的代码也能访问这个字段。但是，这并不意味着在 B 类的代码中能读取任何一个 A 类实例的受保护字段。

下面通过代码讲解这个语言细节。A 类的定义如下：
```java
package javanut6.ch03;

public class A {
    protected final String name;
    
    public A(String named) {
        name = named;
    }
    
    public String getName() {
        return name;
    }
}
```
B 类的定义如下：
```java
package javanut6.ch03.different;

import javanut6.ch03.A;

public class B extends A {
    public B(String named) {
        super(named);
    }
    
    @Override
    public String getName() {
        return "B: " + name;
    }
}
```

> Java 的包不能“嵌套”，所以 javanut6.ch03.different 和 javanut6.ch03 是不同的包。javanut6.ch03.different 不以任何方式包含在 javanut6.ch03 中，也和 javanut6.ch03 没有任何关系。

可是，如果我们试图把下面这个新方法添加到 B 类中，会导致编译出错，因为 B 类的实例无法访问任何一个 A 类的实例：
```java
public String examine(A a) {
    return "B sees: " + a.name;
}
```
如果把这个方法改成：
```java
public String examine(B b) {
    return "B sees another B: " + b.name;
}
```
就能编译通过，因为同一类型的多个实例可以访问各自的 protected 字段。当然，如果 B 类和 A 类在同一包中，那么任何一个 B 类的实例都能访问任何一个 A 类实例的全部受保护字段，因为使用 protected 声明的字段对同一个包中的每个类都可见。

4. 访问控制和继承

Java 规范规定：

- 子类继承超类中所有可以访问的实例字段和实例方法；
- 如果子类和超类在同一个包中定义，那么子类继承所有没使用 private 声明的实例字段和方法；
- 如果子类在其他包中定义，那么它继承所有使用 protected 和 public 声明的实例字段和方法；
- 使用 private 声明的字段和方法绝不会被继承；类字段和类方法也一样；
- 构造方法不会被继承（而是链在一起调用，本章前面已经说过）。

不过，有些程序员会对“子类不继承超类中不可访问的字段和方法”感到困惑。这似乎暗示了，创建子类的实例时不会为超类中使用 private 声明的字段分配内存。然而，这不是上述规定想表述的。

> 其实，子类的每个实例都包含一个完整的超类实例，其中包括所有不可访问的字段和方法。

某些成员可能无法访问，这似乎和类的成员在类的主体中始终可以访问相矛盾。为了避免误解，我们要使用“继承的成员”表示那些可以访问的超类成员。

那么，关于成员访问性的正确表述应该是：“所有继承的成员和所有在类中定义的成员都是可以访问的。”这句话还可以换种方式说：

- 类继承超类的所有实例字段和实例方法（但不继承构造方法）；
- 在类的主体中始终可以访问这个类定义的所有字段和方法，而且还可以访问继承自超类的可访问的字段和方法。

5. 成员访问规则总结

表 3-1 总结了成员的访问规则。

<img src="img\表3-1：类中成员的可访问性.png" style="zoom:50%;" />

下面是一些使用可见性修饰符的经验法则。

- 只使用 public 声明组成类的公开 API 的方法和常量。使用 public 声明的字段只能是常量和不能修改的对象，而且必须同时使用 final 声明。
- 使用 protected 声明大多数使用这个类的程序员不会用到的字段和方法，但在其他包中定义子类时可能会用到。

> 严格来说，使用 protected 声明的成员是类公开 API 的一部分，必须为其编写文档，而且不能轻易修改，以防破坏依赖这些成员的代码。

- 如果字段和方法供类的内部实现细节使用，但是同一个包中协作的类也要使用，那么就
使用默认的包可见性。
- 使用 private 声明只在类内部使用，在其他地方都要隐藏的字段和方法。

如果不确定该使用 protected、包还是 private 可见性，那么先使用 private。如果太过严格，可以稍微放松访问限制（如果是字段的话，还可以提供访问器方法）。

设计 API 时这么做尤其重要，因为提高访问限制是不向后兼容的改动，可能会破坏依赖成员访问性的代码。

###### 3.5.2 数据访问器方法

在 Circle 类那个示例中，我们使用 public 声明表示圆半径的字段。Circle 类可能有很好的理由让这个字段可以公开访问；这个类很简单，字段之间不相互依赖。但是，当前实现的 Circle 类允许对象的半径为负数，而半径为负数的圆肯定不存在。可是，只要半径存储在声明为 public 的字段中，任何程序员都能把这个字段的值设为任何想要的值，而不管这个值有多么不合理。唯一的办法是限制程序员，不让他们直接访问这个字段，然后定义 public 方法，间接访问这个字段。提供 public 方法读写字段和把字段本身声明为 public 不是一回事。目前而言，二者的区别是，方法可以检查错误。

例如，我们或许不想让 Circle 对象的半径使用负数——负数显然不合理，但目前的实现没有阻止这么做。示例 3-4 展示了如何修改 Circle 类的定义，避免把半径设为负数。

Circle 类的这个版本使用 protected 声明 r 字段，还定义了访问器方法 getRadius() 和 setRadius()，用于读写这个字段的值，而且限制半径不能为负数。r 字段使用 protected 声明，所以可以在子类中直接（且高效地）访问。
```java
//示例 3-4：使用数据隐藏和封装技术定义的 Circle 类
package shapes; // 为这个类指定一个包

public class Circle { // 这个类还使用public声明
    // 这是通用的常量，所以要保证声明为public
    public static final double PI = 3.14159;
    protected double r; // 半径被隐藏了，但在子类中可见
    
    // 限制半径取值的方法
    // 这是子类可能感兴趣的实现细节
    protected void checkRadius(double radius) {
        if (radius < 0.0)
            throw new IllegalArgumentException("radius may not be negative.");
    }
    
    // 非默认的构造方法
    public Circle(double r) {
        checkRadius(r);
        this.r = r;
    }
    
    // 公开的数据访问器方法
    public double getRadius() { return r; }
    
    public void setRadius(double r) {
        checkRadius(r);
        this.r = r;
    }
    
    // 操作实例字段的方法
    public double area() { return PI * r * r; }
    public double circumference() { return 2 * PI * r; }
}
```
我们在一个名为 shapes 的包中定义 Circle 类。因为 r 字段使用 protected 声明，所以 shapes 包中的任何其他类都能直接访问这个字段，而且能把它设为任何值。这里假设 shapes 包中的所有类都由同一个作者或者协作的多个作者编写，而且包中的类相互信任，不会滥用拥有的访问权限影响彼此的实现细节。

最后，限制半径不能使用负数的代码在一个使用 protected 声明的方法中，这个方法是 checkRadius()。虽然 Circle 类的用户无法调用这个方法，但这个类的子类可以调用，而且如果想修改对半径的限制，还可以覆盖这个方法。

> 在 Java 中，数据访问器方法的命名有个通用约定，即以“get”和“set”开头。但是，如果要访问的字段是 boolean 类型，那么读取字段的方法使用的名称可能会以“is”开头。例如，名为 readable 的 boolean 类型字段对应的访问器方法是 isReadable() 而不是 getReadable()。

###### 3.6 抽象类和方法

在示例 3-4 中，我们把 Circle 类声明为 shapes 包的一部分。假设我们计划实现多个表示形状的类：Rectangle、Square、Ellipse、Triangle 等。我们可以在这些表示形状的类中定义两个基本方法：area() 和 circumference()。那么，为了能方便处理由形状组成的数组，这些表示形状的类最好有个共同的超类 Shape。这样组织类层次结构的话，每个形状对象，不管具体表示的是什么形状，都能赋予类型为 Shape 的变量、字段或数组元素。我们想在 Shape 类中封装所有形状共用的功能（例如，area() 和 circumference() 方法）。但是，通用的 Shape 类不表示任何类型的形状，所以不能为这些方法定义有用的实现。Java 使用抽象方法解决这种问题。

Java 允许使用 abstract 修饰符声明方法，此时只定义方法但不实现方法。abstract 修饰的方法没有主体，只有一个签名和一个分号。以下是 abstract 方法和这些方法所在的 abstract 类相关的规则。

> 注 2： Java 中的抽象方法和 C++ 中的纯虚拟函数（即声明为 = 0 的虚拟函数）有点像。在 C++ 中，包含纯虚拟函数的类是抽象类，不能实例化。包含抽象方法的 Java 类也一样不能实例化。

- 只要类中有一个 abstract 方法，那么这个类本身就自动成为 abstract 类，而且必须声明为 abstract 类，否则会导致编译出错。
- abstract 类无法实例化。
- abstract 类的子类必须覆盖超类的每个 abstract 方法并且把这些方法全部实现（即提供方法主体），才能实例化。这种类一般叫作具体子类（concrete subclass），目的是强调它不是抽象类。
- 如果 abstract 类的子类没有实现继承的所有 abstract 方法，那么这个子类还是抽象类，而且必须使用 abstract 声明。
- 使用 static、private 和 final 声明的方法不能是抽象方法，因为这三种方法在子类中不能覆盖。类似地，final 类中不能有任何 abstract 方法。
- 就算类中没有 abstract 方法，这个类也能声明为 abstract。使用这种方式声明的 abstract 类表明实现的不完整，要交给子类实现。这种类不能实例化。

> 第 11 章会见到 Classloader 类，这个类就没有任何抽象方法。

下面通过一个示例说明这些规则的运作方式。如果定义 Shape 类时把 area() 和 circumference() 声明为 abstract 方法，那么 Shape 的子类必须实现这两个方法才能实例化。也就是说，每个 Shape 对象都要确保实现了这两个方法。示例 3-5 展示了如何编写代码。在这段代码中，定义了一个抽象的 Shape 类和两个具体子类。
```java
//示例 3-5：一个抽象类和两个具体子类
public abstract class Shape {
    public abstract double area(); // 两个抽象方法
    public abstract double circumference(); // 注意，没有主体，只有分号
}

class Circle extends Shape {
    public static final double PI = 3.14159265358979323846;
    protected double r; // 实例字段
    
    public Circle(double r) { this.r = r; } // 构造方法
    public double getRadius() { return r; } // 访问器
    public double area() { return PI*r*r; } // 实现超类中的
    public double circumference() { return 2*PI*r; } // 两个抽象方法
}

class Rectangle extends Shape {
    protected double w, h; // 实例字段
    public Rectangle(double w, double h) { // 构造方法
        this.w = w; this.h = h;
    }
    
    public double getWidth() { return w; } // 访问器方法
    public double getHeight() { return h; } // 另一个访问器
    public double area() { return w*h; } // 实现超类中的
    public double circumference() { return 2*(w + h); } // 两个抽象方法
}
```
Shape 类中每个抽象方法的括号后面都是分号，没有花括号，也没定义方法的主体。使用示例 3-5 中定义的这几个类可以编写如下的代码：
```java
Shape[] shapes = new Shape[3]; // 创建一个保存形状的数组
shapes[0] = new Circle(2.0); // 填充这个数组
shapes[1] = new Rectangle(1.0, 3.0);
shapes[2] = new Rectangle(4.0, 2.0);

double totalArea = 0;
for(int i = 0; i < shapes.length; i++)
    totalArea += shapes[i].area(); // 计算这些形状的面积
```
有两点要注意。

- Shape 类的子类对象可以赋值给 Shape 类型数组中的元素，无需校正。这又是一个放大转换引用类型（第 2 章讨论过）的例子。

- 即便 Shape 类没有定义 area() 和 circumference() 方法的主体，各个 Shape 对象还是能调用这两个方法。调用这两个方法时，使用虚拟方法查找技术找到要调用的方法。因此，圆的面积使用 Circle 类中定义的方法计算，矩形的面积使用 Rectangle 类中定义的方法计算。

转换引用类型

对象可以在不同的引用类型之间转换。和基本类型一样，引用类型转换可以是放大转换（编译器自动完成），也可以是需要校正的缩小转换（或许运行时还要检查）。要想理解引用类型的转换，必须理解引用类型组成的层次结构，这个体系叫作类层次结构。

每个 Java 引用类型都扩展其他类型，被扩展的类型是这个类型的超类。类型继承超类的字段和方法，然后定义属于自己的一些额外的字段和方法。在 Java 中，类层次结构的根是一个特殊的类，名为 Object。所有 Java 类都直接或间接地扩展 Object 类。Object 类定义了一些特殊的方法，所有对象都能继承（或覆盖）这些方法。

预定义的 String 类和本章前面定义的 Point 类都扩展 Object 类。因此，可以说，所有 String 对象也都是 Object 对象。也可以说，所有 Point 对象都是 Object 对象。但是，反过来说就不对了。我们不能说每个 Object 对象都是 String 对象，因为如前所示，有些 Object 对象是 Point 对象。

简单理解类层次结构之后，我们可以定义引用类型的转换规则了。

- 对象不能转换成不相关的类型。例如，就算使用校正运算符，Java 编译器也不允许把 String 对象转换成 Point 对象。
- 对象可以转换成超类类型，或者任何祖先类类型。这是放大转换，因此不用校正。例如，String 对象可以赋值给 Object 类型的变量，或者传入期待 Object 类型参数的方法。

> 其实没有执行转换操作，而是直接把对象当成超类的实例。这种行为有时称为里氏替换原则（Liskov substitution principle），以第一个明确表述这种行为的计算机科学家 Barbara Liskov 的名字命名。

- 对象可以转换成子类类型，但这是缩小转换，需要校正。Java 编译器临时允许执行这种转换，但 Java 解释器在运行时会做检查，确保转换有效。根据程序的逻辑，确认对象的确是子类的实例后才会把对象校正成子类类型。否则，解释器会抛出 ClassCastException 异常。例如，如果把一个 String 对象赋值给 Object 类型的变量，那么后面可以校正这个变量的值，再变回 String 类型：
```java
Object o = "string"; // 把String对象放大转换成Object类型
String s = (String) o; // 程序后面再把这个Object对象缩小转换成String类型
```
数组是对象，而且有自己的一套转换规则。首先，任何数组都能放大转换成 Object 对象。带校正的缩小转换能把这个对象转换回数组。下面是一个示例：
```java
// 把数组放大转换成Object对象
Object o = new int[] {1,2,3};
// 程序后面……

int[] a = (int[]) o; // 缩小转换回数组类型
```
除了能把数组转换成对象之外，如果两个数组的“基类型”是可以相互转换的引用类型，那么数组还能转换成另一个类型的数组。例如：
```java
// 这是一个字符串数组
String[] strings = new String[] { "hi", "there" };
// 可以放大转换成CharSequence[]类型
// 因为String类型可以放大转换成CharSequence类型
CharSequence[] sequences = strings;
// 缩小转换回String[]类型需要校正
strings = (String[]) sequences;
// 这是一个由字符串数组组成的数组
String[][] s = new String[][] { strings };
// 不能转换成CharSequence[]类型，因为String[]类型
// 不能转换成CharSequence类型：维数不匹配

sequences = s; // 不会编译这行代码
// s可以转换成Object类型或Object[]类型，因为所有数组类型
// （包括String[]和String[][]类型）都能转换成Object类型
Object[] objects = s;
```
注意，这些数组转换规则只适用于由对象或数组组成的数组。基本类型的数组不能转换为任何其他数组类型，就算基本基类型之间能相互转换也不行：
```java
// 就算int类型能放大转换成double类型
// 也不能把int[]类型转换成double[]类型
// 这行代码会导致编译出错
double[] data = new int[] {1,2,3};
// 但是，这行代码是合法的，因为int[]类型能转换成Object类型
Object[] objects = new int[][] {{1,2},{3,4}};
```

##### 3.7 修饰符总结

如前所示，类、接口和它们的成员都能使用一个或多个修饰符声明——这些修饰符是 public、static 和 final 等关键字。下面对本章做个总结，列出所有 Java 修饰符，说明各自能修饰的 Java 结构种类和作用。详情如表 3-2 所示。还可以参阅 3.1 节、3.2.1 节和 2.6.2 节。

表3-2：Java修饰符

![](img\表3-2：Java修饰符.png "style="zoom:50%;" )




