#### 第 9 章 处理常见的数据格式

编程的多数任务是处理不同格式的数据。本章介绍 Java 处理两大类数据的方式——文本和数字。后半部分则集中介绍处理日期和时间的方式。这一部分特别有趣，因为 Java 8 提供了处理日期和时间的全新 API。我们会先稍微深入地介绍新接口，然后再简要讨论以前的日期和时间 API。

很多应用仍在使用以前的 API，所以开发者需要知道旧的处理方式。不过，新 API 太好用了，建议尽早转用。在讨论这些复杂的格式之前，先来说说文本数据和字符串。

##### 9.1 文本

我们已经在很多场合见过 Java 的字符串。字符串由一系列 Unicode 字符组成，是 String 类的实例。字符串是 Java 程序最常处理的数据类型之一（可以使用第 13 章介绍的 jmap 工具证实这一点）。

本节会深入介绍 String 类，并弄清为什么字符串在 Java 语言中占据如此重要的地位。本节末尾还会介绍正则表达式，这是十分常用的抽象方式，用于搜索文本中的模式匹配（也是程序员的传统工具）。

###### 9.1.1 字符串的特殊句法

Java 语言使用某种特殊的方式处理 String 类。虽然字符串不是基本类型，但十分常用，所以 Java 的设计者觉得有必要提供一些特殊的句法特性，便于处理字符串。下面通过一些示例介绍 Java 为字符串提供的特殊句法特性。

1. 字符串字面量

第 2 章介绍过，Java 允许把一系列字符放在双引号中创建字面量字符串对象。例如：
```java
String pet = "Cat";
```
如果没有这种特殊的句法，就要编写大量不友好的代码，例如：
```java
char[] pullingTeeth = {'C', 'a', 't'};
String pet = new String(pullingTeeth);
```
这样很快就会把代码变得冗长乏味，因此，Java 像所有现代编程语言一样，提供了简单的字符串字面量句法。字符串字面量是完全有效的对象，所以类似下面这种代码是完全合法的：
```java
System.out.println("Dog".length());
```

2. toString()方法

这个方法在 Object 类中定义，作用是方便把任何对象转换成字符串。有了这个方法，就可以使用 System.out.println() 方法轻易打印任何对象。System.out.println() 方法其实是 PrintStream::println，因为 System.out 是 PrintStream 类型的静态字段。我们来看一下这个方法是如何定义的：
```java
public void println(Object x) {
    String s = String.valueOf(x);
    synchronized (this) {
       print(s);
       newLine();
    }
}
```
这个方法使用静态方法 String::valueOf() 创建了一个新字符串：
```java
public static String valueOf(Object obj) {
    return (obj == null) ? "null" : obj.toString();
}
```
> println() 方 法 没 有 直 接 使 用 toString() 方 法， 而 使 用 了 静 态 方 法 valueOf()，这么做是为了避免 obj 为 null 时抛出 NullPointerException 异常。

这种定义方式让任何对象都能调用 toString() 方法，也十分有利于 Java 提供的另一种重要的句法特性——字符串连接。

3. 字符串连接

在 Java 中，可以把一个字符串“添加”到另一个字符串的末尾，创建新字符串——这是一个语言特性，叫作字符串连接，使用运算符 + 实现。连接字符串时，先创建一个使用 StringBuilder 对象表示的“工作区”，其内容和原始字符串中的字符序列一样。

然 后 更 新 StringBuilder 对 象， 把 另 一 个 字 符 串 中 的 字 符 添 加 到 末 尾。 最 后， 在StringBuilder 对象（现在这个对象包含两个字符串中的字符）上调用 toString() 方法，得到一个包含所有字符的新字符串。使用 + 运算符连接字符串时，javac 会自动创建上述所有代码。

连接后得到的是全新的 String 对象，这一点从下面的示例可以看出：
```java
String s1 = "AB";
String s2 = "CD";

String s3 = s1;
System.out.println(s1 == s3); // 是不是同一个对象？

s3 = s1 + s2;
System.out.println(s1 == s3); // 还是不是同一个对象？
System.out.println(s1);
System.out.println(s3);
```
这个连接字符串的示例直接表明，+ 运算符没有就地修改（或改变）s1。这个示例也体现了一个通用规则：Java 的字符串是不可变的。也就是说，选定组成字符串的字符并创建 String 对象后，字符串的内容就不能改变了。这是 Java 语言的一个重要规则，下面稍微深入地讨论一下。

###### 9.1.2 字符串的不可变性

为了“修改”字符串，就像前面连接字符串那样，其实需要创建一个过渡的 StringBuilder 对象作为暂存区，然后在这个对象上调用 toString() 方法，创建一个新 String 实例。下面通过代码演示这个过程：
```java
String pet = "Cat";
StringBuilder sb = new StringBuilder(pet);
sb.append("amaran");
String boat = sb.toString();
System.out.println(boat);
```
如果编写的是下述代码，javac 就会生成类似上面的代码：
```java
String pet = "Cat";
String boat = pet + "amaran";
System.out.println(boat);
```
当然，除了能由 javac 隐式使用之外，如前所示，也可以直接使用 StringBuilder 类。

> 除了 StringBuilder 类，Java 还有 StringBuffer 类。StringBuffer 类在最早的 Java 版本中出现，新编写的程序不要使用这个类——应该使用 StringBuilder 类，除非确实需要在多个线程之间共享构建的新字符串。

字符串的不可变性是极其有用的语言特性。假如 + 运算符直接修改字符串，而不是创建新字符串，那么，只要某个线程连接了两个字符串，其他所有线程都能看到这个变化。对大多数程序来说，这种行为没什么用，所以不可变性更合理。

哈希码和事实不可变性

第 5 章说明方法必须满足的契约（contract） 时，见过 hashCode() 方法。我们来看一下 String::hashCode() 方法在 JDK 源码中是怎么定义的：

> 注 1：契约指方法的行为所符合的特定标准。

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
     }
    return h;
}
```








###### 9.1.3 正则表达式



##### 9.2 数字和数学运算




###### 9.2.1 Java 表示整数类型的方式




###### 9.2.2 Java 中的浮点数




###### 9.2.3 Java 的数学函数标准库




##### 9.3 在 Java 8 中处理日期和时间

几乎所有商业应用软件都具有一些日期和时间的概念。建模真实世界的事件或活动时，知道事件什么时候发生可以对后续报告和域对象的比较都很重要。Java 8 完全改变了开发者处理日期和时间的方式。本节介绍 Java 8 引入的新概念。在之前的版本中，只能通过 java.util.Date 类处理日期和时间，而且这个类没有建模这些概念。使用旧 API 的代码应该尽早转用新 API。

###### 9.3.1 介绍 Java 8 的日期和时间 API




###### 9.3.2 查询




###### 9.3.3 调节器




###### 9.3.4 过时的日期和时间 API




##### 9.4 小结





