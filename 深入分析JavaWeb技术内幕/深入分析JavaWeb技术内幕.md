深入分析JavaWeb技术内幕
========
#### 第1章 深入Web请求过程
##### 1.1 B/S网络架构概述
##### 1.2 如何发起一个请求
###### 1.3 HTTP解析
###### 1.3.1 查看HTTP信息的工具
###### 1.3.2 浏览器缓存机制
##### 1.4 DNS域名解析
###### 1.4.1 DNS域名解析过程
###### 1.4.2 跟踪域名解析过程
###### 1.4.3 清除缓存的域名
###### 1.4.4 几种域名解析方式
##### 1.5 CDN工作机制
###### 1.5.1 CDN架构
###### 1.5.2 负载均衡
###### 1.5.3 CDN动态加速
##### 1.6 总结

#### 第2章 深入分析Java I/O的工作机制
##### 2.1 Java的I/O类库的基本架构
###### 2.1.1 基于字节的I/O操作接口
###### 2.1.2 基于字符的I/O操作接口
###### 2.1.3 字节与字符的转化接口
##### 2.2 磁盘I/O工作机制
###### 2.2.1 几种访问文件的方式
###### 2.2.2 Java访问磁盘文件
###### 2.2.3 Java序列化技术
##### 2.3 网络I/O工作机制
###### 2.3.1 TCP状态转化
###### 2.3.2 影响网络传输的因素
###### 2.3.3 Java Socket的工作机制
###### 2.3.4 建立通信链路
###### 2.3.5 数据传输
##### 2.4 NIO的工作方式
###### 2.4.1 BIO带来的挑战
###### 2.4.2 NIO的工作机制
###### 2.4.3 Buffer的工作方式
###### 2.4.4 NIO的数据访问方式
##### 2.5 I/O调优
###### 2.5.1 磁盘I/O优化
###### 2.5.2 TCP网络参数调优
###### 2.5.3 网络I/O优化
##### 2.6 设计模式解析之适配器模式
###### 2.6.1 适配器模式的结构
###### 2.6.2 Java I/O中的适配器模式
##### 2.7 设计模式解析之装饰器模式
###### 2.7.1 装饰器模式的结构
###### 2.7.2 Java I/O中的装饰器模式
##### 2.8 适配器模式与装饰器模式的区别
##### 2.9 总结

#### 第3章 深入分析Java Web中的中文编码问题
##### 3.1 几种常见的编码格式
###### 3.1.1 为什么要编码
###### 3.1.2 如何“翻译”
##### 3.2 在Java中需要编码的场景
###### 3.2.1 在I/O操作中存在的编码
###### 3.2.2 在内存操作中的编码
##### 3.3 在Java中如何编解码
###### 3.3.1 按照ISO-8859-1编码
###### 3.3.2 按照GB2312编码
###### 3.3.3 按照GBK编码
###### 3.3.4 按照UTF-16编码
###### 3.3.5 按照UTF-8编码
###### 3.3.6 UTF-8编码代码片段
###### 3.3.7 对几种编码格式的比较
##### 3.4 在Java Web中涉及的编解码
###### 3.4.1 URL的编解码
###### 3.4.2 HTTP Header的编解码
###### 3.4.3 POST表单的编解码
###### 3.4.4 HTTP BODY的编解码
##### 3.5 在JS中的编码问题
###### 3.5.1 外部引入JS文件
###### 3.5.2 JS的URL编码
###### 3.5.3 其他需要编码的地方
##### 3.6 常见问题分析
###### 3.6.1 中文变成了看不懂的字符
###### 3.6.2 一个汉字变成一个问号
###### 3.6.3 一个汉字变成两个问号
###### 3.6.4 一种不正常的正确编码
##### 3.7 一种繁简转换的实现方式
##### 3.8 总结

#### 第4章 Javac编译原理
##### 4.1 Javac是什么
##### 4.2 Javac编译器的基本结构
##### 4.3 Javac工作原理分析
###### 4.3.1 词法分析器
###### 4.3.2 语法分析器
###### 4.3.3 语义分析器
###### 4.3.4 代码生成器
##### 4.4 设计模式解析之访问者模式
###### 4.4.1 访问者模式的结构
###### 4.4.2 Javac中访问者模式的实现
##### 4.5 总结

#### 第5章 深入class文件结构
##### 5.1 JVM指令集简介
###### 5.1.1 与类相关的指令
###### 5.1.2 方法的定义
###### 5.1.3 属性的定义
###### 5.1.4 其他指令集
##### 5.2 class文件头的表示形式
##### 5.3 常量池
###### 5.3.1 UTF8常量类型
###### 5.3.2 Fieldref、Methodref常量类型
###### 5.3.3 Class常量类型
###### 5.3.4 NameAndType常量类型
##### 5.4 类信息
##### 5.5 Fields和Methods定义
##### 5.6 类属性描述
##### 5.7 Javap生成的class文件结构
###### 5.7.1 LineNumberTable
###### 5.7.2 LocalVariableTable
##### 5.8 总结

#### 第6章 深入分析ClassLoader工作机制
##### 6.1 ClassLoader类结构分析
##### 6.2 ClassLoader的等级加载机制
##### 6.3 如何加载class文件
###### 6.3.1 加载字节码到内存
###### 6.3.2 验证与解析
###### 6.3.3 初始化Class对象
##### 6.4 常见加载类错误分析
###### 6.4.1 ClassNotFoundException
###### 6.4.2 NoClassDefFoundError
###### 6.4.3 UnsatisfiedLinkError
###### 6.4.4 ClassCastException
###### 6.4.5 ExceptionInInitializerError
##### 6.5 常用的ClassLoader分析
##### 6.6 如何实现自己的ClassLoader
###### 6.6.1 加载自定义路径下的class文件
###### 6.6.2 加载自定义格式的class文件
##### 6.7 实现类的热部署
##### 6.8 Java应不应该动态加载类
##### 6.9 总结

#### 第7章 JVM体系结构与工作方式
##### 7.1 JVM体系结构
###### 7.1.1 何谓JVM
###### 7.1.2 JVM体系结构详解
##### 7.2 JVM工作机制
###### 7.2.1 机器如何执行代码
###### 7.2.2 JVM为何选择基于栈的架构
###### 7.2.3 执行引擎的架构设计
###### 7.2.4 执行引擎的执行过程
###### 7.2.5 JVM方法调用栈
##### 7.3 总结

#### 第8章 JVM内存管理
##### 8.1 物理内存与虚拟内存
##### 8.2 内核空间与用户空间
##### 8.3 在Java中哪些组件需要使用内存
###### 8.3.1 Java堆
###### 8.3.2 线程
###### 8.3.3 类和类加载器
###### 8.3.4 NIO
###### 8.3.5 JNI
##### 8.4 JVM内存结构
###### 8.4.1 PC寄存器
###### 8.4.2 Java栈
###### 8.4.3 堆
###### 8.4.4 方法区
###### 8.4.5 运行时常量池
###### 8.4.6 本地方法栈
##### 8.5 JVM内存分配策略
###### 8.5.1 通常的内存分配策略
###### 8.5.2 Java中的内存分配详解
##### 8.6 JVM内存回收策略
###### 8.6.1 静态内存分配和回收
###### 8.6.2 动态内存分配和回收
###### 8.6.3 如何检测垃圾
###### 8.6.4 基于分代的垃圾收集算法
##### 8.7 内存问题分析
###### 8.7.1 GC日志分析
###### 8.7.2 堆快照文件分析
###### 8.7.3 JVM Crash日志分析
##### 8.8 实例1
##### 8.9 实例2
##### 8.10 实例3
##### 8.11 总结

#### 第9章 Servlet工作原理解析
##### 9.1 从Servlet容器说起
###### 9.1.1 Servlet容器的启动过程
###### 9.1.2 Web应用的初始化工作
##### 9.2 创建Servlet实例
###### 9.2.1 创建Servlet对象
###### 9.2.2 初始化Servlet
##### 9.3 Servlet体系结构
##### 9.4 Servlet如何工作
##### 9.5 Servlet中的Listener
##### 9.6 Filter如何工作
##### 9.7 Servlet中的url-pattern
##### 9.8 总结

#### 第10章 深入理解Session与Cookie
##### 10.1 理解Cookie
###### 10.1.1 Cookie属性项
###### 10.1.2 Cookie如何工作
###### 10.1.3 使用Cookie的限制
##### 10.2 理解Session
###### 10.2.1 Session与Cookie
###### 10.2.2 Session如何工作
##### 10.3 Cookie安全问题
##### 10.4 分布式Session框架
###### 10.4.1 存在哪些问题
###### 10.4.2 可以解决哪些问题
###### 10.4.3 总体实现思路
##### 10.5 Cookie压缩
###### 10.6 表单重复提交问题
###### 10.7 多终端Session统一
##### 10.8 总结

#### 第11章 Tomcat的系统架构与设计模式
##### 11.1 Tomcat总体设计
###### 11.1.1 Tomcat总体结构
###### 11.1.2 Connector组件
###### 11.1.3 Servlet容器Container
###### 11.1.4 Tomcat中的其他组件
##### 11.2 Tomcat中的设计模式
###### 11.2.1 门面设计模式
###### 11.2.2 观察者设计模式
###### 11.2.3 命令设计模式
###### 11.2.4 责任链设计模式
##### 11.3 总结

#### 第12章 Jetty的工作原理解析
##### 12.1 Jetty的基本架构
###### 12.1.1 Jetty基本架构简介
###### 12.1.2 Handler的体系结构
##### 12.2 Jetty的启动过程
##### 12.3 接受请求
###### 12.3.1 基于HTTP工作
###### 12.3.2 基于AJP工作
###### 12.3.3 基于NIO方式工作
##### 12.4 处理请求
##### 12.5 与JBoss集成
##### 12.6 与Tomcat的比较
###### 12.6.1 架构比较
###### 12.6.2 性能比较
###### 12.6.3 特性比较
##### 12.7 总结

#### 第13章 Spring框架的设计理念与设计模式分析
##### 13.1 Spring的骨骼架构
###### 13.1.1 Spring的设计理念
###### 13.1.2 核心组件如何协同工作
##### 13.2 核心组件详解
###### 13.2.1 Bean组件
###### 13.2.2 Context组件
###### 13.2.3 Core组件
###### 13.2.4 Ioc容器如何工作
##### 13.3 Spring中AOP的特性详解
###### 13.3.1 动态代理的实现原理
###### 13.3.2 Spring AOP如何实现
##### 13.4 设计模式解析之代理模式
###### 13.4.1 代理模式原理
###### 13.4.2 Spring中代理模式的实现
##### 13.5 设计模式解析之策略模式
###### 13.5.1 策略模式原理
###### 13.5.2 Spring中策略模式的实现
##### 13.6 总结

#### 第14章 Spring MVC的工作机制与设计模式
##### 14.1 Spring MVC的总体设计
##### 14.2 Control设计
###### 14.2.1 HandlerMapping初始化
###### 14.2.2 HandlerAdapter初始化
###### 14.2.3 Control的调用逻辑
##### 14.3 Model设计
##### 14.4 View设计
##### 14.5 框架设计的思考
###### 14.5.1 为什么需要框架
###### 14.5.2 需要什么样的框架
###### 14.5.3 框架设计原则
###### 14.5.4 “指航灯”
###### 14.5.5 最基本的原则
##### 14.6 设计模式解析之模板模式
###### 14.6.1 模板模式的结构
###### 14.6.2 Spring MVC中的模板模式示例
##### 14.7 总结

#### 第15章 深入分析iBatis框架之系统架构与映射原理
##### 15.1 iBatis框架主要的类层次结构
##### 15.2 iBatis框架的设计策略
##### 15.3 iBatis框架的运行原理
##### 15.4 示例
##### 15.5 iBatis对SQL语句的解析
##### 15.6 数据库字段映射到Java对象
##### 15.7 示例运行的结果
##### 15.8 设计模式解析之简单工厂模式
###### 15.8.1 简单工厂模式的实现原理
###### 15.8.2 iBatis中的简单工厂模式示例
##### 15.9 设计模式解析之工厂模式
###### 15.9.1 工厂模式的实现原理
###### 15.9.2 iBatis中的工厂模式示例
##### 15.10 总结

#### 第16章 Velocity工作原理解析
##### 16.1 Velocity总体架构
##### 16.2 JJTree渲染过程解析
###### 16.2.1 #set语法
###### 16.2.2 Velocity的方法调用
###### 16.2.3 #if、#elseif和#else语法
###### 16.2.4 #foreach语法
###### 16.2.5 #parse语法
##### 16.3 事件处理机制
##### 16.4 常用优化技巧
###### 16.4.1 减少树的总节点数量
###### 16.4.2 减少渲染耗时的节点数量
##### 16.5 与JSP比较
###### 16.5.1 JSP渲染机制
###### 16.5.2 Velocity与JSP
##### 16.6 设计模式解析之合成模式
###### 16.6.1 合成模式的结构
###### 16.6.2 Velocity中合成模式的实现
##### 16.7 设计模式解析之解释器模式
###### 16.7.1 解释器模式的结构
###### 16.7.2 Velocity中解释器模式的实现
##### 16.8 总结

#### 第17章 Velocity优化实践
##### 17.1 现实存在的问题
##### 17.2 优化的理论基础
###### 17.2.1 程序语言的三角形结构
###### 17.2.2 数据结构减少抽象化
###### 17.2.3 简单的程序复杂化
###### 17.2.4 减少翻译的代价
###### 17.2.5 变的转化为不变的
##### 17.3 一个高效的模板引擎实现思路
###### 17.3.1 vm模板如何被编译
###### 17.3.2 方法调用的无反射优化
###### 17.3.3 将字符输出改成字节输出
##### 17.4 优化的成果
###### 17.4.1 将char转成byte
###### 17.4.2 无反射执行
##### 17.5 其他优化手段
##### 17.6 总结

#### 第18章 大浏览量系统的静态化架构设计
##### 18.1 淘宝大浏览量商品详情系统简介
##### 18.2 系统面临哪些挑战
##### 18.3 淘宝前台系统的优化历程
##### 18.4 大浏览量系统的静态改造
###### 18.4.1 什么是静态化系统
###### 18.4.2 为什么要进行静态化架构设计
###### 18.4.3 如何改造动态系统
###### 18.4.4 几种静态化方案的设计及选择
###### 18.4.5 如何解决失效问题
###### 18.4.6 服务端静态化方案的演进：CDN化
##### 18.5 总结
###### 参考资料
