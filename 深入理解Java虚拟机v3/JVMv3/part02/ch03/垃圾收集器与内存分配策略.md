垃圾收集器与内存分配策略
========
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里
面的人却想出来

##### 3.1 概述
说起垃圾收集（Garbage Collection，下文简称GC），有不少人把这项技术当作Java语言的伴生产
物。事实上，垃圾收集的历史远远比Java久远，在1960年诞生于麻省理工学院的Lisp是第一门开始使
用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾
收集需要完成的三件事情：

- 哪些内存需要回收？

- 什么时候回收？

- 如何回收？

经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入
了“自动化”时代，那为什么我们还要去了解垃圾收集和内存分配？答案很简单：当需要排查各种内存
溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动
化”的技术实施必要的监控和调节

把时间从大半个世纪以前拨回到现在，舞台也回到我们熟悉的Java语言。第2章介绍了Java内存运
行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈
中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基
本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模
型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，
在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着
回收了

而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能
会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才
能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器
所关注的正是这部分内存该如何管理，本文后续讨论中的“内存”分配与回收也仅仅特指这一部分内存

##### 3.2 对象已死？
在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就
是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对
象）了

###### 3.2.1 引用计数算法
很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方
引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可
能再被使用的。笔者面试过很多应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的
都是这个答案

客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但
它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用
案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语
言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。但是，在Java
领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单
的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数
就很难解决对象之间相互循环引用的问题

举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段instance，赋值令
objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已
经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也
就无法回收它们
```java
//代码清单3-1 引用计数算法的缺陷
/**
 * testGC()方法执行后，objA和objB会不会被GC呢？
 * @author zzm
 */
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}

//运行结果：
[Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
Heap
    def new generation total 9216K, used 82K [0x00000000055e0000, 0x0000000005fe0000, 0x0000000005fe0000)
    Eden space 8192K, 1% used [0x00000000055e0000, 0x00000000055f4850, 0x0000000005de0000)
    from space 1024K, 0% used [0x0000000005de0000, 0x0000000005de0000, 0x0000000005ee0000)
    to space 1024K, 0% used [0x0000000005ee0000, 0x0000000005ee0000, 0x0000000005fe0000)
    tenured generation total 10240K, used 210K [0x0000000005fe0000, 0x00000000069e0000, 0x00000000069e0000)
    the space 10240K, 2% used [0x0000000005fe0000, 0x0000000006014a18, 0x0000000006014c00, 0x00000000069e0000)
    compacting perm gen total 21248K, used 3016K [0x00000000069e0000, 0x0000000007ea0000, 0x000000000bde0000)
    the space 21248K, 14% used [0x00000000069e0000, 0x0000000006cd2398, 0x0000000006cd2400, 0x0000000007ea0000)
    No shared spaces configured.
```
从运行结果中可以清楚看到内存回收日志中包含“4603K->210K”，意味着虚拟机并没有因为这两
个对象互相引用就放弃回收它们，这也从侧面说明了Java虚拟机并不是通过引用计数算法来判断对象
是否存活的

###### 3.2.2 可达性分析算法
当前主流的商用程序语言（Java、C#，上溯至前面提到的古老的Lisp）的内存管理子系统，都是
通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过
一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过
程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，
或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的

如图3-1所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，
因此它们将会被判定为可回收的对象

在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

- 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
参数、局部变量、临时变量等

- 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量

- 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用

- 在本地方法栈中JNI（即通常所说的Native方法）引用的对象

- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如
NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器

- 所有被同步锁（synchronized关键字）持有的对象

- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不
同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集
和局部回收（Partial GC），如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生
代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不
可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引
用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性

目前最新的几款垃圾收集器<sup>[1]</sup>无一例外都具备了局部回收的特征，为了避免GC Roots包含过多对
象而过度膨胀，它们在实现上也做出了各种优化处理。关于这些概念、优化技巧以及各种不同收集器
实现等内容，都将在本章后续内容中一一介绍

[1] 如OpenJDK中的G1、Shenandoah、ZGC以及Azul的PGC、C4这些收集器

###### 3.2.3 再谈引用
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可
达，判定对象是否存活都和“引用”离不开关系。在JDK 1.2版之前，Java里面的引用是很传统的定义：
如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表
某块内存、某个对象的引用。这种定义并没有什么不对，只是现在看来有些过于狭隘了，一个对象在
这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显
得无能为力。譬如我们希望能描述一类对象：当内存空间还足够时，能保留在内存之中，如果内存空
间在进行垃圾收集后仍然非常紧张，那就可以抛弃这些对象——很多系统的缓存功能都符合这样的应
用场景

在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软
引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强
度依次逐渐减弱

- 强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object
obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回
收掉被引用的对象

- 软引用是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内
存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，
才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用

- 弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只
能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只
被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用

- 虚引用也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的
存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供
了PhantomReference类来实现虚引用

###### 3.2.4 生存还是死亡？







###### 3.2.5 回收方法区








##### 3.3 垃圾收集算法







###### 3.3.1 分代收集理论






###### 3.3.2 标记-清除算法






###### 3.3.3 标记-复制算法






###### 3.3.4 标记-整理算法






##### 3.4 HotSpot的算法细节实现







###### 3.4.1 根节点枚举






###### 3.4.2 安全点






###### 3.4.3 安全区域





###### 3.4.4 记忆集与卡表






###### 3.4.5 写屏障






###### 3.4.6 并发的可达性分析







##### 3.5 经典垃圾收集器






###### 3.5.1 Serial收集器







###### 3.5.2 ParNew收集器







###### 3.5.3 Parallel Scavenge收集器





###### 3.5.4 Serial Old收集器





###### 3.5.5 Parallel Old收集器





###### 3.5.6 CMS收集器





###### 3.5.7 Garbage First收集器




##### 3.6 低延迟垃圾收集器




###### 3.6.1 Shenandoah收集器




###### 3.6.2 ZGC收集器




##### 3.7 选择合适的垃圾收集器




###### 3.7.1 Epsilon收集器




###### 3.7.2 收集器的权衡




###### 3.7.3 虚拟机及垃圾收集器日志




###### 3.7.4 垃圾收集器参数总结





##### 3.8 实战：内存分配与回收策略





###### 3.8.1 对象优先在Eden分配





###### 3.8.2 大对象直接进入老年代





###### 3.8.3 长期存活的对象将进入老年代






###### 3.8.4 动态对象年龄判定







###### 3.8.5 空间分配担保







##### 3.9 本章小结












