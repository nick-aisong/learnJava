垃圾收集器与内存分配策略
========
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里
面的人却想出来

##### 3.1 概述
说起垃圾收集（Garbage Collection，下文简称GC），有不少人把这项技术当作Java语言的伴生产
物。事实上，垃圾收集的历史远远比Java久远，在1960年诞生于麻省理工学院的Lisp是第一门开始使
用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾
收集需要完成的三件事情：

- 哪些内存需要回收？

- 什么时候回收？

- 如何回收？

经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入
了“自动化”时代，那为什么我们还要去了解垃圾收集和内存分配？答案很简单：当需要排查各种内存
溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动
化”的技术实施必要的监控和调节

把时间从大半个世纪以前拨回到现在，舞台也回到我们熟悉的Java语言。第2章介绍了Java内存运
行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈
中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基
本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模
型的讨论里，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，
在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着
回收了

而Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能
会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才
能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器
所关注的正是这部分内存该如何管理，本文后续讨论中的“内存”分配与回收也仅仅特指这一部分内存

##### 3.2 对象已死？
在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就
是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（“死去”即不可能再被任何途径使用的对
象）了

###### 3.2.1 引用计数算法
很多教科书判断对象是否存活的算法是这样的：在对象中添加一个引用计数器，每当有一个地方
引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可
能再被使用的。笔者面试过很多应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的
都是这个答案

客观地说，引用计数算法（Reference Counting）虽然占用了一些额外的内存空间来进行计数，但
它的原理简单，判定效率也很高，在大多数情况下它都是一个不错的算法。也有一些比较著名的应用
案例，例如微软COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语
言以及在游戏脚本领域得到许多应用的Squirrel中都使用了引用计数算法进行内存管理。但是，在Java
领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单
的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数
就很难解决对象之间相互循环引用的问题

举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段instance，赋值令
objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已
经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为零，引用计数算法也
就无法回收它们
```java
//代码清单3-1 引用计数算法的缺陷
/**
 * testGC()方法执行后，objA和objB会不会被GC呢？
 * @author zzm
 */
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    /**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */
    private byte[] bigSize = new byte[2 * _1MB];
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        // 假设在这行发生GC，objA和objB是否能被回收？
        System.gc();
    }
}

//运行结果：
[Full GC (System) [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
Heap
    def new generation total 9216K, used 82K [0x00000000055e0000, 0x0000000005fe0000, 0x0000000005fe0000)
    Eden space 8192K, 1% used [0x00000000055e0000, 0x00000000055f4850, 0x0000000005de0000)
    from space 1024K, 0% used [0x0000000005de0000, 0x0000000005de0000, 0x0000000005ee0000)
    to space 1024K, 0% used [0x0000000005ee0000, 0x0000000005ee0000, 0x0000000005fe0000)
    tenured generation total 10240K, used 210K [0x0000000005fe0000, 0x00000000069e0000, 0x00000000069e0000)
    the space 10240K, 2% used [0x0000000005fe0000, 0x0000000006014a18, 0x0000000006014c00, 0x00000000069e0000)
    compacting perm gen total 21248K, used 3016K [0x00000000069e0000, 0x0000000007ea0000, 0x000000000bde0000)
    the space 21248K, 14% used [0x00000000069e0000, 0x0000000006cd2398, 0x0000000006cd2400, 0x0000000007ea0000)
    No shared spaces configured.
```








###### 3.2.2 可达性分析算法




###### 3.2.3 再谈引用




###### 3.2.4 生存还是死亡？




###### 3.2.5 回收方法区




##### 3.3 垃圾收集算法




###### 3.3.1 分代收集理论




###### 3.3.2 标记-清除算法




###### 3.3.3 标记-复制算法




###### 3.3.4 标记-整理算法




##### 3.4 HotSpot的算法细节实现





###### 3.4.1 根节点枚举




###### 3.4.2 安全点





###### 3.4.3 安全区域





###### 3.4.4 记忆集与卡表




###### 3.4.5 写屏障




###### 3.4.6 并发的可达性分析





##### 3.5 经典垃圾收集器




###### 3.5.1 Serial收集器





###### 3.5.2 ParNew收集器





###### 3.5.3 Parallel Scavenge收集器





###### 3.5.4 Serial Old收集器





###### 3.5.5 Parallel Old收集器





###### 3.5.6 CMS收集器





###### 3.5.7 Garbage First收集器




##### 3.6 低延迟垃圾收集器




###### 3.6.1 Shenandoah收集器




###### 3.6.2 ZGC收集器




##### 3.7 选择合适的垃圾收集器




###### 3.7.1 Epsilon收集器




###### 3.7.2 收集器的权衡




###### 3.7.3 虚拟机及垃圾收集器日志




###### 3.7.4 垃圾收集器参数总结





##### 3.8 实战：内存分配与回收策略





###### 3.8.1 对象优先在Eden分配





###### 3.8.2 大对象直接进入老年代





###### 3.8.3 长期存活的对象将进入老年代






###### 3.8.4 动态对象年龄判定







###### 3.8.5 空间分配担保







##### 3.9 本章小结












