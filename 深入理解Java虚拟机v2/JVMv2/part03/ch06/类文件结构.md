类文件结构
========
代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言
发展的一大步

##### 6.1 概述
记得在第一节计算机程序课上我的老师就讲过：“计算机只认识0和1，所以我们写的程
序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行”。10多年时间过去了，
今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程
序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native
Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、
平台中立的格式作为程序编译后的存储格式

##### 6.2 无关性的基石
如果计算机的CPU指令集只有x86一种，操作系统也只有Windows一种，那也许Java语言
就不会出现。Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处
运行（Write Once,Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴
求。在无时无刻不充满竞争的IT领域，不可能只有Wintel存在，我们也不希望只有Wintel存
在，各种不同的硬件体系结构和不同的操作系统肯定会长期并存发展。“与平台无关”的理想
最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各
种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现
了程序的“一次编写，到处运行”

各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）
是构成平台无关性的基石，但本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟
机的另外一种中立特性——语言无关性正越来越被开发者所重视。到目前为止，或许大部分
程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。但在Java发展
之初，设计者就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发
布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《The Java Language
Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。并且在1997年发
布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions
to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java
虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），当Java虚拟机发展到
JDK 1.7～1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺

时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运
行的语言，如Clojure、Groovy、JRuby、Jython、Scala等。使用过这些语言的开发者可能还不
是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语
言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？

实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内
的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含
了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规
范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示
为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，
任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译
器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以
把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图6-1所示

Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成
的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一
些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言
实现一些有别于Java的语言特性提供了基础

##### 6.3 Class类文件的结构
解析Class文件的数据结构是本章的最主要内容。笔者曾经在前言中阐述过本书的写作风
格：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最
为密切的内容。但是，对数据结构方面的讲解不可避免地会比较枯燥，而这部分内容又是了
解虚拟机的重要基础之一。如果想比较深入地了解虚拟机，那么这部分是不能不接触的

在本章关于Class文件结构的讲解中，我们将以《Java虚拟机规范（第2版）》（1999年
发布，对应于JDK 1.4时代的Java虚拟机）中的定义为主线，这部分内容虽然古老，但它所包
含的指令、属性是Class文件中最重要和最基础的。同时，我们也会以后续JDK 1.5～JDK 1.7
中添加的内容为支线进行较为简略的、介绍性的讲解，如果读者对这部分内容特别感兴趣，
建议参考笔者所翻译的《Java虚拟机规范（Java SE 7）》中文版，可以在笔者的网站
（http://icyfenix.iteye.com/）上下载到这本书的全文PDF

注意 任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接
口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，笔
者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它
并不一定以磁盘文件的形式存在

Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地
排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎
全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项
时，则会按照高位在前的方式分割成若干个8位字节进行存储
（这种顺序称为“Big-Endian”，具体是指最高位字节在地址最低位、最低位字节在地址最高
 位的顺序来存储数据，它是SPARC、PowerPC等处理器的默认多字节存储顺序，而x86等处
 理器则是使用了相反的“Little-Endian”顺序来存储数据）

根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存
储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类
型为基础，所以这里要先介绍这两个概念

无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个
字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8
编码构成字符串值

表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地
以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张
表，它由表6-1所示的数据项构成

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一
个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据
为某一类型的集合

本节结束之前，笔者需要再重复讲一下，Class的结构不像XML等描述语言，由于它没
有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节
序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个
字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这
个表中各个数据项的具体含义

###### 6.3.1 魔数与Class文件的版本

每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件
是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，
譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别
主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由
地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的
魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还称
做“Oak”语言的时候（大约是1991年前后）就已经确定下来了。它还有一段很有趣的历史，
据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、容易记
忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet’s Coffee中深受欢迎的
Baristas咖啡”，这个魔数似乎也预示着日后“Java”这个商标名称的出现

紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor
Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始
的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的
版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文
件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件
```java
//代码清单6-1 简单的Java代码
package org.fenixsoft.clazz;
    public class TestClass{
        private int m;
        public int inc(){
            return m+1;
        }
    }
```
图6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见
开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为
0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被
JDK 1.6或以上版本虚拟机执行的Class文件

表6-2列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号

###### 6.3.2 常量池
紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，
它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据
项目之一，同时它还是在Class文件中第一个出现的表类型数据项目

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数
据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容
量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六
进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。在
Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在
于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池
项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计
数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量
计数都与一般习惯相同，是从0开始的

常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。
字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符
号引用则属于编译原理方面的概念，包括了下面三类常量：

- 类和接口的全限定名（Fully Qualified Name）
- 字段的名称和描述符（Descriptor）
- 方法的名称和描述符

Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟
机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段
的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正
的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的
符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态
连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解

常量池中每一项常量都是一个表，在JDK 1.7之前共有11种结构各不相同的表结构数
据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种
（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和
CONSTANT_InvokeDynamic_info，本章不会涉及这3种新增的类型，在第8章介绍字节码执行
和方法调用时，将会详细讲解）

这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值
见表6-3中标志列），代表当前这个常量属于哪种常量类型。这14种常量类型所代表的具体
含义见表6-3

之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。回头看
看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的
标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的
符号引用。CONSTANT_Class_info的结构比较简单，见表6-4

tag是标志位，上面已经讲过了，它用于区分常量类型；name_index是一个索引值，它指
向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限
定名，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第
二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查
表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构
见表6-5

length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length
字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码
的区别是：从'\u0001'到'\u007f'之间的字符（相当于1～127的ASCII码）的缩略编码使用一个
字节表示，从'\u0080'到'\u07ff'之间的所有字符的缩略编码用两个字节表示，
从'\u0800'到'\uffff'之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示

顺便提一下，由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来
描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大
长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程
序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译

本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29字节，
往后29字节正好都在1～127的ASCII码范围以内，内容为“org/fenixsoft/clazz/TestClass”，有兴
趣的读者可以自己逐个字节换算一下，换算结果如图6-4选中的部分所示

到此为止，我们分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可
以通过类似的方法计算出来。为了避免计算过程占用过多的版面，后续的19个常量的计算过
程可以借助计算机来帮我们完成。在JDK的bin目录中，Oracle公司已经为我们准备好一个专
门用于分析Class文件字节码的工具：javap，代码清单6-2中列出了使用javap工具的-verbose
参数输出的TestClass.class文件字节码内容（此清单中省略了常量池以外的信息）。前面我们
曾经提到过，Class文件中还有很多数据项都要引用常量池中的常量，所以代码清单6-2中的
内容在后续的讲解过程中还要经常使用到
```java
//代码清单6-2 使用Javap命令输出常量表
 C:\>javap-verbose TestClass
Compiled from"TestClass.java"
public class org.fenixsoft.clazz.TestClass extends java.lang.Object
SourceFile:"TestClass.java"
minor version:0
major version:50
Constant pool:
const#1=class#2;//org/fenixsoft/clazz/TestClass
const#2=Asciz org/fenixsoft/clazz/TestClass;
const#3=class#4;//java/lang/Object
const#4=Asciz java/lang/Object;
const#5=Asciz m;
const#6=Asciz I;
const#7=Asciz<init>;
const#8=Asciz()V;
const#9=Asciz Code;
const#10=Method#3.#11;//java/lang/Object."<init>":()V
const#11=NameAndType#7:#8;//"<init>":()V
const#12=Asciz LineNumberTable;
const#13=Asciz LocalVariableTable;
const#14=Asciz this;
const#15=Asciz Lorg/fenixsoft/clazz/TestClass;
const#16=Asciz inc;
const#17=Asciz()I;
const#18=Field#1.#19;//org/fenixsoft/clazz/TestClass.m:I
const#19=NameAndType#5:#6;//m:I
const#20=Asciz SourceFile;
const#21=Asciz TestClass.java;
```
从代码清单6-2中可以看出，计算机已经帮我们把整个常量池的21项常量都计算了出
来，并且第1、2项常量的计算结果与我们手工计算的结果一致。仔细看一下会发现，其中有
一些常量似乎从来没有在代码中出现过，如“I”、“V”、“<init>”、“LineNumberTable”、
“LocalVariableTable”等，这些看起来在代码任何一处都没有出现过的常量是哪里来的呢？

这部分自动生成的常量的确没有在Java代码里面直接出现过，但它们会被后面即将讲到
的字段表（field_info）、方法表（method_info）、属性表（attribute_info）引用到，它们会用
来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个
参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字
节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号
引用进行表达。这部分内容将在后面进一步阐述。最后，笔者将这14种常量项的结构定义总
结为表6-6以供读者参考

###### 6.3.3 访问标志
在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识
别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类
型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志
的含义见表6-7

access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志
位要求一律为0。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚
举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后
的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、
ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、
ACC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。
从图6-5中可以看出，access_flags标志（偏移地址：0x000000EF）的确为0x0021

###### 6.3.4 类索引、父类索引与接口索引集合
类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集
合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承
关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由
于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java
类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就
用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身
是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中

类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用
两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常
量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在
CONSTANT_Utf8_info类型的常量中的全限定名字符串。图6-6演示了代码清单6-1的代码的类
索引查找过程

对于接口索引集合，入口的第一项——u2类型的数据为接口计数器
（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，
后面接口的索引表不再占用任何字节。代码清单6-1中的代码的类索引、父类索引与接口表
索引的内容如图6-7所示

从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是
类索引为1，父类索引为3，接口索引集合大小为0，查询前面代码清单6-2中javap命令计算出
来的常量池，找出对应的类和父类的常量，结果如代码清单6-3所示
```java
//代码清单6-3 部分常量池内容
const#1=class#2;//org/fenixsoft/clazz/TestClass
const#2=Asciz org/fenixsoft/clazz/TestClass;
const#3=class#4;//java/lang/Object
const#4=Asciz java/lang/Object;
```
###### 6.3.5 字段表集合
字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以
及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字
段可以包含什么信息？可以包括的信息有：字段的作用域（public、private、protected修饰
符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰
符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类
型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰
符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类
型，这些都是无法固定的，只能引用常量池中的常量来描述。表6-8中列出了字段表的最终格式

字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一
个u2的数据类型，其中可以设置的标志位和含义见表6-9

很明显，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志
最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有
ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的

跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量
池的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单
名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念

全限定名和简单名称很好理解，以代码清单6-1中的代码为
例，“org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成
了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一
个“；”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类
中的inc()方法和m字段的简单名称分别是“inc”和“m”

相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。描述符的作用是
用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描
述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表
无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来
表示，详见表6-10

对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义
为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String；”，一个整型数
组“int[]”将被记录为“[I”

用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的
严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为“()V”，方法
java.lang.String toString()的描述符为“()Ljava/lang/String；”，方法int
indexOf（char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int
targetCount,int fromIndex）的描述符为“([CII[CIII)I”

对于代码清单6-1中的TestClass.class文件来说，字段表集合从地址0x000000F8开始，第
一个u2类型的数据为容量计数器fields_count，如图6-8所示，其值为0x0001，说明这个类只有
一个字段表数据。接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private
修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为
假。代表字段名称的name_index的值为0x0005，从代码清单6-2列出的常量表中可查得第5项
常量是一个CONSTANT_Utf8_info类型的字符串，其值为“m”，代表字段描述符的
descriptor_index的值为0x0006，指向常量池的字符串“I”，根据这些信息，我们可以推断出原
代码定义的字段为：“private int m；”

字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index
之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项
的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信
息，但是，如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为
ConstantValue的属性，其值指向常量123。关于attribute_info的其他内容，将在6.3.7节介绍属
性表的数据项目时再进一步讲解

字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代
码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类
实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是
否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，
那字段重名就是合法的

###### 6.3.6 方法表集合
如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class
文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如
同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索
引（descriptor_index）、属性表集合（attributes）几项，见表6-11。这些数据项目的含义也非
常类似，仅在访问标志和属性表集合的可选项中有所区别





###### 6.3.7 属性表集合






##### 6.4 字节码指令简介





###### 6.4.1 字节码与数据类型






###### 6.4.2 加载和存储指令






###### 6.4.3 运算指令






###### 6.4.4 类型转换指令






###### 6.4.5 对象创建与访问指令





###### 6.4.6 操作数栈管理指令






###### 6.4.7 控制转移指令







###### 6.4.8 方法调用和返回指令








###### 6.4.9 异常处理指令






###### 6.4.10 同步指令







##### 6.5 公有设计和私有实现







##### 6.6 Class文件结构的发展








##### 6.7 本章小结



















