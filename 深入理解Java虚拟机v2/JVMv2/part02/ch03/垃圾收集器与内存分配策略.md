垃圾收集器与内存分配策略
========
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想
进去，墙里面的人却想出来

##### 3.1 概述
说起垃圾收集（Garbage Collection,GC），大部分人都把这项技术当做Java语言的伴生产
物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分
配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：

- 哪些内存需要回收？

- 什么时候回收？

- 如何回收？

经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需
要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我
们就需要对这些“自动化”的技术实施必要的监控和调节

把时间从半个多世纪以前拨回到现在，回到我们熟悉的Java语言。第2章介绍了Java内存
运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随
线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个
栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器
进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此
这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问
题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回
收也仅指这一部分内存

##### 3.2 对象已死吗
在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一
件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径
使用的对象）

###### 3.2.1 引用计数算法
很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0
的对象就是不可能再被使用的。作者面试过很多的应届生和一些有多年工作经验的开发人
员，他们对于这个问题给予的都是这个答案

客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部
分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的
COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游
戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流
的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象
之间相互循环引用的问题

举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段
instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引
用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引
用计数都不为0，于是引用计数算法无法通知GC收集器回收它们
```java
//代码清单3-1 引用计数算法的缺陷
/**
 * testGC()方法执行后，objA和objB会不会被GC呢？ 
 * @author zzm
 */
public class ReferenceCountingGC {

	public Object instance = null;

	private static final int _1MB = 1024 * 1024;

	/**
	 * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
	 */
	private byte[] bigSize = new byte[2 * _1MB];

	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;

		objA = null;
		objB = null;

		// 假设在这行发生GC，objA和objB是否能被回收？
		System.gc();
	}
}
//运行结果：
[FullGC(System)[Tenured:0K->210K(10240K),0.0149142secs]4603K->210K(19456K),[Perm:2999K->
2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]
Heap
def new generation total 9216K,used 82K[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)
Eden space 8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)
from space 1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)
to space 1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)
tenured generation total 10240K,used 210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)
the space 10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)
compacting perm gen total 21248K,used 3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)
the space 21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)
No shared spaces configured.
```
从运行结果中可以清楚看到，GC日志中包含“4603K->210K”，意味着虚拟机并没有因
为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判
断对象是否存活的

###### 3.2.2 可达性分析算法
在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，
都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思
路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所
走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连
（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如
图3-1所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达
的，所以它们将会被判定为是可回收的对象

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象

- 方法区中类静态属性引用的对象

- 方法区中常量引用的对象

- 本地方法栈中JNI（即一般说的Native方法）引用的对象

###### 3.2.3 再谈引用
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引
用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很
传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块
内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用
或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为
力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存
空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这
样的应用场景

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong
Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom
Reference）4种，这4种引用强度依次逐渐减弱

强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引
用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将
要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回
收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实
现软引用

弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的
对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，
都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用

虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引
用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一
个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在
JDK 1.2之后，提供了PhantomReference类来实现虚引用

###### 3.2.4 生存还是死亡










###### 3.2.5 回收方法区













##### 3.3 垃圾收集算法












###### 3.3.1 标记-清除算法












###### 3.3.2 复制算法













###### 3.3.3 标记-整理算法













###### 3.3.4 分代收集算法














##### 3.4 HotSpot的算法实现













###### 3.4.1 枚举根节点













###### 3.4.2 安全点















###### 3.4.3 安全区域














##### 3.5 垃圾收集器















###### 3.5.1 Serial收集器













###### 3.5.2 ParNew收集器
















###### 3.5.3 Parallel Scavenge收集器
















###### 3.5.4 Serial Old收集器
















###### 3.5.5 Parallel Old收集器














###### 3.5.6 CMS收集器

















###### 3.5.7 G1收集器















###### 3.5.8 理解GC日志













###### 3.5.9 垃圾收集器参数总结

















##### 3.6 内存分配与回收策略















###### 3.6.1 对象优先在Eden分配














###### 3.6.2 大对象直接进入老年代
















###### 3.6.3 长期存活的对象将进入老年代















###### 3.6.4 动态对象年龄判定

















###### 3.6.5 空间分配担保














##### 3.7 本章小结












