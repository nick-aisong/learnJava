垃圾收集器与内存分配策略
========
Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想
进去，墙里面的人却想出来

##### 3.1 概述
说起垃圾收集（Garbage Collection,GC），大部分人都把这项技术当做Java语言的伴生产
物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分
配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：

- 哪些内存需要回收？

- 什么时候回收？

- 如何回收？

经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起
来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需
要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我
们就需要对这些“自动化”的技术实施必要的监控和调节

把时间从半个多世纪以前拨回到现在，回到我们熟悉的Java语言。第2章介绍了Java内存
运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随
线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个
栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器
进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此
这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问
题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一
样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也
可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配
和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回
收也仅指这一部分内存

##### 3.2 对象已死吗
在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一
件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径
使用的对象）

###### 3.2.1 引用计数算法
很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有
一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0
的对象就是不可能再被使用的。作者面试过很多的应届生和一些有多年工作经验的开发人
员，他们对于这个问题给予的都是这个答案

客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部
分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的
COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游
戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流
的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象
之间相互循环引用的问题

举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段
instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引
用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引
用计数都不为0，于是引用计数算法无法通知GC收集器回收它们
```java
//代码清单3-1 引用计数算法的缺陷
/**
 * testGC()方法执行后，objA和objB会不会被GC呢？ 
 * @author zzm
 */
public class ReferenceCountingGC {

	public Object instance = null;

	private static final int _1MB = 1024 * 1024;

	/**
	 * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过
	 */
	private byte[] bigSize = new byte[2 * _1MB];

	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;

		objA = null;
		objB = null;

		// 假设在这行发生GC，objA和objB是否能被回收？
		System.gc();
	}
}
//运行结果：
[FullGC(System)[Tenured:0K->210K(10240K),0.0149142secs]4603K->210K(19456K),[Perm:2999K->
2999K(21248K)],0.0150007secs][Times:user=0.01sys=0.00,real=0.02secs]
Heap
def new generation total 9216K,used 82K[0x00000000055e0000,0x0000000005fe0000,0x0000000005fe0000)
Eden space 8192K,1%used[0x00000000055e0000,0x00000000055f4850,0x0000000005de0000)
from space 1024K,0%used[0x0000000005de0000,0x0000000005de0000,0x0000000005ee0000)
to space 1024K,0%used[0x0000000005ee0000,0x0000000005ee0000,0x0000000005fe0000)
tenured generation total 10240K,used 210K[0x0000000005fe0000,0x00000000069e0000,0x00000000069e0000)
the space 10240K,2%used[0x0000000005fe0000,0x0000000006014a18,0x0000000006014c00,0x00000000069e0000)
compacting perm gen total 21248K,used 3016K[0x00000000069e0000,0x0000000007ea0000,0x000000000bde0000)
the space 21248K,14%used[0x00000000069e0000,0x0000000006cd2398,0x0000000006cd2400,0x0000000007ea0000)
No shared spaces configured.
```
从运行结果中可以清楚看到，GC日志中包含“4603K->210K”，意味着虚拟机并没有因
为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判
断对象是否存活的

###### 3.2.2 可达性分析算法
在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，
都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思
路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所
走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连
（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如
图3-1所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达
的，所以它们将会被判定为是可回收的对象

在Java语言中，可作为GC Roots的对象包括下面几种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象

- 方法区中类静态属性引用的对象

- 方法区中常量引用的对象

- 本地方法栈中JNI（即一般说的Native方法）引用的对象

###### 3.2.3 再谈引用
无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引
用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很
传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块
内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用
或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为
力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存
空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这
样的应用场景

在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong
Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom
Reference）4种，这4种引用强度依次逐渐减弱

强引用就是指在程序代码之中普遍存在的，类似“Object obj=new Object()”这类的引
用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象

软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将
要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回
收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实
现软引用

弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的
对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，
都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用

虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引
用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一
个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在
JDK 1.2之后，提供了PhantomReference类来实现虚引用

###### 3.2.4 生存还是死亡
即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处
于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达
性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，
筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或
者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”

如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做
F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行
它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做
的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情
况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统
崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象
进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链
上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的
成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃
脱，那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize()被
执行，但是它仍然可以存活
```java
//代码清单3-2 一次对象自我拯救的演示
/**
 * 此代码演示了两点： 
 * 1.对象可以在被GC时自我拯救。 
 * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
 * @author zzm
 */
public class FinalizeEscapeGC {

	public static FinalizeEscapeGC SAVE_HOOK = null;

	public void isAlive() {
		System.out.println("yes, i am still alive :)");
	}

	@Override
	protected void finalize() throws Throwable {
		super.finalize();
		System.out.println("finalize mehtod executed!");
		FinalizeEscapeGC.SAVE_HOOK = this;
	}

	public static void main(String[] args) throws Throwable {
		SAVE_HOOK = new FinalizeEscapeGC();

		//对象第一次成功拯救自己
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}

		// 下面这段代码与上面的完全相同，但是这次自救却失败了
		SAVE_HOOK = null;
		System.gc();
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
	}
}
//运行结果：
finalize mehtod executed!
yes,i am still alive :)
no,i am dead :(
```
从代码清单3-2的运行结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收
集器触发过，并且在被收集前成功逃脱了

另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃
脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，
如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行
动失败了

需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色
彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因
为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的
一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描
述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。
finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔
者建议大家完全可以忘掉Java语言中有这个方法的存在

###### 3.2.5 回收方法区
很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规
范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集
的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以
回收70%～95%的空间，而永久代的垃圾收集效率远低于此

永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收
Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了
常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何
String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内
存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接
口）、方法、字段的符号引用也与此类似

判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则
相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例

- 加载该类的ClassLoader已经被回收

- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该
类的方法

虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是
和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc
参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：
+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：
+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要
FastDebug版的虚拟机支持

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁
自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出

##### 3.3 垃圾收集算法
由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法
又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程

###### 3.3.1 标记-清除算法
最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分
为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有
被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它
是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到
的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是
空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程
序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾
收集动作。标记—清除算法的执行过程如图3-2所示

###### 3.3.2 复制算法
为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容
量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着
的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是
对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指
针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原
来的一半，未免太高了一点。复制算法的执行过程如图3-3所示

现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生
代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存
分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。
当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最
后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是
8:1，%也就是每次新生代中可用内存空间为整个新生代容量的90（80%+10%），只有10%
的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每
次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里
指老年代）进行分配担保（Handle Promotion）

(这里需要说明一下，在HotSpot中的这种分代方式从最初就是这种布局，与IBM的研究并
没有什么实际联系。本书列举IBM的研究只是为了说明这种分代布局的意义所在)

###### 3.3.3 标记-整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的
是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中
所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法

根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程
仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存
活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如
图3-4所示

###### 3.3.4 分代收集算法
当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算
法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆
分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代
中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付
出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间
对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收

##### 3.4 HotSpot的算法实现
3.2 节和3.3节从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机
上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行

###### 3.4.1 枚举根节点
从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在
全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现
在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间

另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一
个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看
起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情
况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有
Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称
（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的

由于目前的主流Java虚拟机使用的都是准确式GC（这个概念在第1章介绍Exact VM对
Classic VM的改进时讲过），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有
执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在
HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的
时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也
会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知
这些信息了。下面的代码清单3-3是HotSpot Client VM生成的一段String.hashCode()方法的
本地代码，可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中
偏移量为16的内存区域中各有一个普通对象指针（Ordinary Object Pointer）的引用，有效范
围为从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移
量）=0x026eb7be，即hlt指令为止
```java
//代码清单3-3 String.hashCode()方法编译后的本地代码
[Verified Entry Point]
0x026eb730:mov%eax,-0x8000(%esp)
……;ImplicitNullCheckStub slow case
0x026eb7a9:call 0x026e83e0 ;OopMap{ebx=Oop[16]=Oop off=142} ;*caload ;-java.lang.String:hashCode@48(line 1489)
;{runtime_call}
0x026eb7ae:push$0x83c5c18 ;{external_word}
0x026eb7b3:call 0x026eb7b8
0x026eb7b8:pusha
0x026eb7b9:call 0x0822bec0;{runtime_call}
0x026eb7be:hlt
```
###### 3.4.2 安全点
在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问
题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一
条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高














###### 3.4.3 安全区域














##### 3.5 垃圾收集器















###### 3.5.1 Serial收集器













###### 3.5.2 ParNew收集器
















###### 3.5.3 Parallel Scavenge收集器
















###### 3.5.4 Serial Old收集器
















###### 3.5.5 Parallel Old收集器














###### 3.5.6 CMS收集器

















###### 3.5.7 G1收集器















###### 3.5.8 理解GC日志













###### 3.5.9 垃圾收集器参数总结

















##### 3.6 内存分配与回收策略















###### 3.6.1 对象优先在Eden分配














###### 3.6.2 大对象直接进入老年代
















###### 3.6.3 长期存活的对象将进入老年代















###### 3.6.4 动态对象年龄判定

















###### 3.6.5 空间分配担保














##### 3.7 本章小结












