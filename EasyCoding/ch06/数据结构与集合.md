#### 第6章 数据结构与集合
在代码世界中，集合是对"Collection"一词的翻译，事实上这么翻译仍不够准确。
在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set，它
具有确定性、无序性、互异性等特点。而Java中的集合表达的是数据结构的载体，
并未对应于数学概念上的集合，Java中的集合元素可以是有序的，也可以是重复的，
与数学中的要求不一样。本书中其他地方出现的集合概念，都指的是Collection，用
来保存各种各样的对象。我们经常说，“程序 = 数据结构 + 算法”。集合作为数据结
构的载体，可对元素进行加工和输出，以一定的算法实现最基本的增删改查功能，因
此集合是所有编程语言的基础

在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程
共享集合时出现的脏数据问题；某些集合在数据扩容时出现节点之间的死链问题；写
多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框
架，再到重点集合源码分析，最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手

##### 6.1 数据结构
1. 数据结构定义

数据结构是什么?网络上的一些定义十分抽象且各不相同，学习完之后，反而对
数据结构的概念更加模糊、更有敬畏之心。数据结构是指逻辑意义上的数据组织方式
及其相应的处理方式

(1) 什么是逻辑意义?数据结构的抽象表达非常丰富，而实际物理存储的方式
相对单一。比如，二叉树在磁盘中的存储真的是树形排列吗?并非如此。树的存储可
能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有7
个节点的二叉树，第一个格子放根节点，第二个格子放左子树根节点；并且根据引用
知道左叶子在后续的哪个格子里；第三个格子放右子树根节点，依此类推。此外，树
的存储也可能是基于物理上的链式存储方式，这里不再详细展开

(2) 什么是数据组织方式?逻辑意义上的组织方式有很多，比如树、图、队列、
哈希等。树可以是二叉树、三叉树、B+树等；图可以是有向图或无向图；队列是先
进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式

(3) 什么是数据处理方式?在既定的数据组织方式上，以某种特定的算法实现
数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性
能差异

2. 数据结构分类

数据结构是算法实现的基石，它是一种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。 如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类

(1 )线性结构：0至1个直接前继和直接后继。当线性结构非空时，有唯一的
首元素和尾元素，除两者外，所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。栈是后进先
出，即Last-In，First-Out， 简称LIFO；队列是先进先出，即First-In，First-Out，简称
FIFO

(2) 树结构：0至1个直接前继和0至n个直接后继(n大于或等于2)。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用

(3 )图结构：0至n个直接前继和直接后继(n大于或等于2)。图结构包括简
单图、多重图、有向图和无向图等

(4) 哈希结构：没有直接前继和直接后继。哈希结构通过某种特定的哈希函数
将索引与存储的值关联起来，它是一种查找效率非常高的数据结构

不同的数据组织方式和处理方式带来了一个新的问题：如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指
标，反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的O和一个函数描述，如O(n^3)表示程序
执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级O(1)、对数级O(logn)、线性级O(n)、线性对数级
O(nlogn)、平方级O(n^2)、立方级O(n^3)、指数级O(2^n)等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降

最后以“猜数字”为例进一步理解时间复杂度，主持人从1 ~ 100的范围内任选
一个数字，玩家随机猜一个数，如果没有猜中，主持人会提示猜大了还是猜小了，继
续这样的循环，直到猜对为止。显而易见，如果要猜测，最多要猜100次，最少只用
猜1次。经验表明，玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行1亿次，完全随机的情况下，平均猜测的次数是7.47次，近似二分法猜
测的是5.8次，时间复杂度为O(logn)

##### 6.2 集合框架图
Java中的集合是用于存储对象的工具类容器，它实现了常用的数据结构，提供了
一系列公开的方法用于增加、删除、修改、查找和遍历数据，降低了日常开发成本。
集合的种类非常多，形成了一个比较经典的继承关系树，称为Java集合框架图，如图6-1
所示。框架图中主要分为两类：第一类是按照单个元素存储的Collection，在继承树
中Set和List都实现了Collection接口；第二类是按照Key-Value存储的Map。以上
两类集合体系，无论数据存取还是遍历，都存在非常大的差异

在集合框架图中，红色代表接口，蓝色代表抽象类，绿色代表并发包中的类，灰
色代表早期线程安全的类(基本已经弃用)。可以看到，与Collection相关的4条线
分别是List、Queue、Set、Map，它们的子类会映射到数据结构中的表、树、哈希等。
对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。此图
相当于纲举目张的“纲”，虽然部分集合没有纳入此框架图中，但是容易沿着这个图
的思路理解其他集合。下面一起学习这4个常用集合类型

###### 6.2.1 List集合
List集合是线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个
元素，也存在明确的第一个元素和最后一个元素。List 集合的遍历结果是稳定的。该
体系最常用的是ArrayList和LinkedList两个集合类

ArrayList是容量可以改变的非线程安全集合。内部实现使用数组进行存储，集
合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList支持对元素
的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动
其他元素

LinkedList的本质是双向链表。与ArrayList相比，LinkedList的插入和删除速度
更快，但是随机访问速度则很慢。测试表明，对于10万条的数据，与ArrayList相比，
随机提取元素时存在数百倍的差距。除继承AbstractList抽象类外，LinkedList还实现
了另一个接口Deque，即double-endedqueue。这个接口同时具有队列和栈的性质。
LinkedList包含3个重要的成员：size、first、last。size是双向链表中节点的个数。
first和last分别指向第一个和最后一个节点的引用。LinkedList的优点在于可以将零
散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存
利用率较高

###### 6.2.2 Queue集合
Queue(队列)是一种先进先出的数据结构，队列是一种特殊的线性表， 它只允
许在表的一端进行获取操作，在表的另一端进行插入操作。当队列中没有元素时，称
为空队列。自从BlockingQueue(阻塞队列)问世以来，队列的地位得到极大的提升，
在各种高并发编程场景中，由于其本身FIFO的特性和阻塞操作的特点，经常被作为
Buffer(数据缓冲区)使用

###### 6.2.3 Map集合
Map集合是以Key-Value键值对作为存储元素实现的哈希结构，Key 按某种哈希
函数计算后是唯一的，Value则是可以重复的。Map类提供三种Collection视图，在
集合框架图中，Map指向Collection的箭头仅表示两个类之间的依赖关系。可以使用
keySet()查看所有的Key，使用values()查看所有的Value，使用entrySet() 查看所有
的键值对。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，而如今广泛
使用的HashMap，线程是不安全的。ConcurrentHashMap是线程安全的，在JDK8中
进行了锁的大幅度优化，体现出不错的性能。在多线程并发场景中，优先推荐使用
ConcurrentHashMap，而不是HashMap。TreeMap是Key有序的Map类集合

###### 6.2.4 Set集合
Set是不允许出现重复元素的集合类型。Set体系最常用的是HashSet、TreeSet
和LinkedHashSet三个集合类。HashSet从源码分析是使用HashMap来实现的，只是
Value固定为一个静态对象，使用Key保证集合元素的唯一性， 但它不保证集合元素
的顺序。TreeSet 也是如此，从源码分析是使用TreeMap来实现的，底层为树结构，
在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集
合仍然是有序的。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链
表维护了元素插入顺序

##### 6.3 集合初始化
集合初始化通常进行分配容量、设置特定参数等相关工作。我们以使用频率较高
的ArrayList和HashMap为例，简要说明初始化的相关工作，并解释为什么在任何情
况下，都需要显式地设定集合容量的初始大小。ArrayList是存储单个元素的顺序表结
构，HashMap是存储KV键值对的哈希式结构。分析两者的初始化相关源码，洞悉它
们的容量分配、参数设定等相关逻辑，有助于更好地了解集合特性，提升代码质量。
下面先从ArrayList源码说起：
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final int DEFAULT_CAPACITY = 10;
    // 空表的表示方法
    private static final Object[] EMPTY_ELEMENTDATA = {};
    transient object[] elementData;
    private int size;
    
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            // 值大于0时，根据构造方法的参数值，忠实地创建一个多大的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA; 
        }
    }
    
    // 公开的add万法调用此内部私有万法
    private void add(E e, Object[] elementData, int s) {
        // 当前数组能否容纳size+1的元素，如果不够，则调用grow来扩容
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1 ;
    }
    
    private Object[] grow() {
        return grow(size + 1);
    }
   
    // 扩容的最小要求，必须容纳刚才的元素个数+1,注意，newCapacity()
    // 方法才是扩容的重点!
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));
    }
    
    private int newCapacity(int minCapacity) {
        // 防止扩容1.5倍之后，超过int的表示范围    (第1处)
        int oldCapacity = elementData.length;
        // JDK6之前扩容50%或50%-1，但是取ceil, 而之后的版本取floor    (第2处)
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 无参数构造方法，会在此时分配默认为10的容量
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0)
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    }
}
```
第1处说明：正数带符号右移的值肯定是正值，所以oldCapacity+(oldCapacity>>1)
的结果可能超过int可以表示的最大值，反而有可能比参数的minCapacity更小，则返
回值为(size+1) 的minCapacity

第2处说明：如果原始容量是13，当新添加一个元素时，依据程序中的计算方法，
得出13的二进制数为1101，随后右移1位操作后得到二进制数110，即十进制数6。
最终扩容的大小计算结果为oldCapacitiy + (oldCapacity>>1) = 13 + 6 = 19。使用位运
算主要是基于计算效率的考虑。在JDK7之前的公式，扩容计算方式和结果为
oldCapacitiy × 3 ÷ 2 + 1 = 13 × 3 ÷ 2 + 1 = 20

当ArrayList使用无参构造时，默认大小为10，也就是说在第一次add的时候，
分配为10的容量，后续的每次扩容都会调用Array.copyOf方法，创建新数组再复
制。可以想象，假如需要将1000个元素放置在ArrayList 中，采用默认构造方法，
则需要被动扩容13次才可以完成存储。反之，如果在初始化时便指定了容量new
ArrayList(1000)，那么在初始化ArrayList 对象的时候就直接分配1000个存储空间，
从而避免被动扩容和数组复制的额外开销。最后，进一步设想，如果这个值达到更大
量级，却没有注意初始的容量分配问题，那么无形中造成的性能损耗是非常大的，甚
至导致OOM的风险

再来看一下HashMap，如果它需要放置1000个元素，同样没有设置初始容量大小，
随着元素的不断增加，则需要被动扩容7次才可以完成存储。扩容时需要重建hash表，
非常影响性能。在HashMap中有两个比较重要的参数：Capacity和Load Factor，其
中Capacity决定了存储容量的大小，默认为16；而Load Factor决定了填充比例，
一般使用默认的0.75。基于这两个参数的乘积，HashMap内部用threshold变量表示
HashMap中能放入的元素个数。HashMap 容量并不会在new的时候分配，而是在第
一次put的时候完成创建的，源码如下：
```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
     // ...省略代码
}

// 第一次put时，调用如下方法，初始化table
private void inflateTable(int toSize) {
    // 找到大于参数值且最接近2的冪值，假如输入参数是27，则返回32
    int capacity = roundUpToPowerOf2(toSize);
    
    // threshold 在不超过限制最大值的前提下等于capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}
```
为了提高运算速度，设定HashMap容量大小为2^n，这样的方式使计算落槽位置
更快。如果初始化HashMap的时候通过构造器指定了initialCapacity， 则会先计算出
比initialCapacity大的2的幂存入threshold，在第一次put时会按照这个2的幂初始化
数组大小，此后每次扩容都是增加2倍。如果没有指定初始值，log<sub>2</sub>1000 = 9.96，结
合源码分析可知，如果想要容纳1000个元素，必须经过7次扩容。HashMap的扩容
还是有不小的成本的，如果提前能够预估出HashMap内要放置的元素数量，就可以
在初始化时合理设置容量大小，避免不断扩容带来的性能损耗

综上所述，集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，
那么指定相应的默认值，这也要求我们记得各种集合的默认值大小，ArrayList 大小为
10，而HashMap默认值为16。 牢记每种数据结构的默认值和初始化逻辑，也是开发
工程师基本素质的体现

##### 6.4 数组与集合
数组是一种顺序表，在各种高级语言中，它是组织和处理数据的一种常见方式，
我们可以使用索引下标进行快速定位并获取指定位置的元素。数组的下标从0开始，
但这并不符合生活常识，这源于BCPL语言，它将指针设置在0的位置，用数组下标
作为直接偏移量进行计算。为什么下标不从1开始呢?如果是这样，计算偏移量就要
使用当前下标减1的操作。加减法运算对CPU来说是一种双数运算， 在数组下标使
用频率极高的场景下，这种运算是十分耗时的。在Java体系中，数组用以存储同一
类型的对象，一旦分配内存后则无法扩容。提倡类型与中括号紧挨相连来定义数组，
因为在Java的世界里，万物皆为对象。String[]用来指代String数组对象，示例代码
如下：
```java
String[] args = {"a", "b"};
// 数组引用赋值给Object
Object obj = args;
// 使用类名String[]进行强制转化，并成功赋值，args[0]的值由a变为object
((String[]) obj)[0] = "object";
```
声明数组和赋值的方式示例代码如下：
```java
// 初始化完成，容量的大小即等于大括号内元素的个数，使用频率并不高
String[] args3 = {"a", "b"};
String[] args4 = new String[2];
args4[0] = "a";
args4[1] = "b";
```
上述源码中的args3是静态初始化，而args4是动态初始化。无论静态初始化还
是动态初始化，数组是固定容量大小的。注意在数组动态初始化时，出现了new，这
意味着需要在new String[]的方括号内填写一个整数。如果写的是负数，并不会编译
出错，但运行时会抛出异常：NegativeArraySizeException。 对于动态大小的数组，集
合提供了Vector和ArrayList两个类，前者是线程安全，性能较差，基本弃用，而后
者是线程不安全，它是使用频率最高的集合之一

数组的遍历优先推荐JDK5引进的foreach方式，即for(元素 : 数组名)的方式，
可以在不使用下标的情况下遍历数组。如果需要使用数组下标，则使用for (int i = 0;
i < array.length; i++)的方式，注意length是数组对象的一个属性，而不是方法(注：
String类是使用length()方法来获取字符串长度的)。也可以使用JDK8的函数式接
口进行遍历：
```java
Arrays.asList(args3).stream().forEach(x -> System.out.println(x));
Arrays.asList(args3).stream().forEach(System.out::println);
```
Arrays是针对数组对象进行操作的工具类，包括数组的排序、查找、对比、拷贝
等操作。尤其是排序，在多个JDK版本中在不断地进化，比如原来的归并排序改成
Timsort，明显地改善了集合的排序性能。另外，通过这个工具类也可以把数组转成集合

数组与集合都是用来存储对象的容器，前者性质单一，方便易用；后者类型
安全，功能强大，且两者之间必然有互相转换的方式。毕竟它们的性格迥异，在
转换过程中，如果不注意转换背后的实现方式，很容易产生意料之外的问题。转
换分成两种情况：数组转集合和集合转数组。在数组转集合的过程中，注意是否
使用了视图方式直接返回数组中的数据。我们以Arrays.asList()为例，它把数组转
换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
UnsupprtedOperationException异常。示例源码如下：
```java
public class ArraysAsList {
    public static void main(String[] args) {
        String[] stringArray = new String[3] ;
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        
        List<String> stringList = Arrays.asList(stringArray);
        // 修改转换后的集合，成功地把第一个元素"one"改成"oneList"
        stringList.set(0, "oneList");
        // 运行结果是1. 数组的值随之改变
        System.out.printl(stringArray[0]);
        
        // 这是重点：以下三行编译正确，但都会抛出运行时异常
        stringList.add("four");
        stringList.remove(2);
        stringList.clear();
    }
}
```
事实证明，可以通过set()方法修改元素的值，原有数组相应位置的值
同时也会被修改，但是不能进行修改元素个数的任何操作，否则均会抛出
UnsupportedOperationException异常。ArrysasList体现的是适配器模式，后台的数据
仍是原有数组，set()方法即间接对数组进行值的修改操作。asList的返回对象是一个
Arrays的内部类，它并没有实现集合个数的相关修改方法，这也正是拋出异常的原因。
Arrays.asList的源码如下：
```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```
返回的明明是ArrayList对象，怎么就不可以随心所欲地对此集合进行修改呢?
注意此ArrayList非彼ArrayList，虽然Arrays与ArrayList同属于一个包，但是在
Arrays类中还定义了一个ArrayList的内部类(或许命名为InnerArrayList更容易识别)，
根据作用域就近原则，此处的ArrayList是李鬼，即这是个内部类。此李鬼十分简单，
只提供了个别方法的实现，如下所示：
```java
private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java. io.Serializable {
    // final修饰不准修改其引用    (第1处)
    private final E[] a;
        
    // 直接把数组引用赋值给a，而Objects是JDK7引入的工具包
    // requireNonNull仅仅判断是否为null
    ArrayList(E[] array) {
        a = Objects.requireNonNull(array);
    }
    // 实现了修改特定位置元素的方法
    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        // 注意set成功返回的是此位置上的旧值
        return oldValue;
    }
}
```
第1处的final引用，用于存储集合的数组引用始终被强制指向原有
数组。这个内部类并没有实现任何修改集合元素个数的相关方法，那这个
UnsupportedOperationException异常是从哪里抛出来的呢?是李鬼的父类
AbstractList：

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }
    
    // clear()方法调用remove方法，依然抛出异常
    public void clear() {
        removeRange(0, size());
    }
}
```
如果李鬼Arrays.ArrayList内部类覆写这些方法不抛出异常，避免使用者踩进这
个坑会不会更好?数组具有不为五斗米折腰的气节，传递的信息是“ 要么直接用我，
要么小心异常!” 数组转集合引发的故障还是十分常见的。比如，某业务调用某接口时，
对方以这样的方式返回一个List类型的集合对象，本方获取集合数据时，99.9%是只
读操作，但在小概率情况下需要增加一个元素，从而引发故障。在使用数组转集合时，
需要使用李逵java.util.ArrayList直接创建一个新集合， 参数就是Arrays.asList返回的
不可变集合，源码如下：
```java
public class ListToArray {
    public static void main(String[] args) {
        List<String> list = new ArrayList<string>(3);
        list.add("one");
        list.add("two");
        list.add("three");
        
        // 泛型丢失，无法使用String[]接收无参方法返回的结果    (第1处)
        Object[] array1 = list.toArray();
        
        // array2数组长度小于元素个数    (第2处)
        String[] array2 = new String[2];
        list.toArray(array2);
        System.out.println(Arrays.asList(array2));
        
        // array2 数组长度等于元素个数    (第3处)
        String[] array3 = new String[3];
        list.toArray(array3);
        System.out.println (Arrays.asList(array3));
    }
}
```
执行结果如下：
```text
[null, null]
[one, two, three]
```
第1处比较容易理解，不要用toArray()无参方法把集合转换成数组，这样会导
致泛型丢失；在第2处执行成功后，输出却为null；第3处正常执行，成功地把集合
数据复制到array3数组中。第2处与第3处的区别在于即将复制进去的数组容量是否
足够。如果容量不够，则弃用此数组，另起炉灶，关于此方法的源码如下：
```java
// 注意入参数组的length大小是重中之重，如果大于或等于集合的大小
// 则集合中的数据复制进入数组即可，如果空间不够，入参数组a就会被无视
// 重新分配一个空间，复制完成后返回一个新的数组引用
public <t> T[] toArray(T[] a) {
    if (a.length < size) {
        // 如果数组长度小于集合size，那么执行此语句，直接return    (第1处)
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    }
    
    // 如果容量足够，则直接复制    (第2处)
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size) {
        a[size] = null;
    }
    
    // 只有在数组容量足够的情况下，才返回传入参数
    return a;
}
```
在第1处和第2处均复制java.util.ArrayList的elementData到数组中，这
个elementData是ArrayList集合对象中真正用于存储数据的数组，它的定义为：
transient Object[] elementData;

这个存储ArrayList真正数据的数组由transient修饰，表示此字段在类的序列化
时将被忽略。因为集合序列化时系统会调用writeObject写入流中，在网络客户端反
序列化的readObject时，会重新赋值到新对象的elementData中。为什么多此一举?
因为elementData容量经常会大于实际存储元素的数量，所以只需发送真正有实际值
的数组元素即可。回到刚才的场景，当入参数组容量小于集合大小时，使用Arrays.
copyOf()方法，它的源码如下：
```java
public static <t> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    // 新创建一个数组copy
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength); 
    System.arraycopy(original, 0, copy, 0,
        Math.min(original.length, newLength));
    return copy;
}
```
我们用示例代码模拟可能出现的三种情况，分别为入参数组容量不够时、入参数
组容量刚好时，以及入参数组容量超过集合大小时，并记录其执行时间：
```java
public class ToArraySpeedTest {
    private static final int COUNT = 100 * 100 * 100;
    
    public static void main(String[] args) {
        List<Double> list = new ArrayList<>(COUNT);
        // 构造一个100万个元素的测试集合
        for (int i = 0; i < COUNT; i++) {
            list.add(i * 1.0);
        }
        
        long start = System.nanoTime();
        
        Double[] notEnoughArray = new Double[COUNT- 1];
        list.toArray(notEnoughArray);
        
        long middle1 = System.nanoTime();
        
        Double[] equalArray = new Double[COUNT];
        list.toArray(equalArray);
        
        long middle2 = System.nanoTime();
        
        Double[] doubleArray = new Double[COUNT * 2];
        list.toArray(doubleArray);
        long end = System.nanoTime();
        
        long notEnoughArrayTime = middle1 - start;
        long equalArrayTime = middle2 - middle1;
        long doubleArrayTime = end - middle2;
        
        System.out.println("数组容量小于集合大小：notEnoughArrayTime:
            + notEnoughArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量等于集合大小：equalArrayTime:
            + equalArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量是集合的两倍：doubleArrayTime:
            + doubleArrayTime / (1000.0 * 1000.0) + " ms");
    }
}
```
执行结果如下：
```text
数组长度小于集合大小: notEnoughArrayTime: 12.317152 ms
数组长度等于集合大小: equalArrayTime: 9.327377 ms
数组长度是集合的两倍: doubleArrayTime: 13. 547622 ms
```
具体的执行时间，由于CPU资源占用的随机性，会有一定差异。多次运行结果
显示，当数组容量等于集合大小时，运行总是最快的，空间消耗也是最少的。由此
证明，如果数组初始大小设置不当，不仅会降低性能，还会浪费空间。使用集合的
toArray(T[] array)方法，转换为数组时，注意需要传入类型完全一样的数组，并且它
的容量大小为list.size()

##### 6.5 集合与泛型
泛型与集合的联合使用，可以把泛型的功能发挥到极致，很多程序员不清楚
List、List\<Object\>、List<?> 三者的区别，更加不能区分<? extends T>与<? super T>
的使用场景。List完全没有类型限制和赋值限定，如果天马行空地乱用，迟早会遭遇
类型转换失败的异常。很多程序员觉得List\<Object\>的用法完全等同于List，但在接
受其他泛型赋值时会编译出错。List<?>是一个泛型，在没有赋值之前，表示它可以
接受任何类型的集合赋值，赋值之后就不能随便往里添加元素了。下方的例子很好地
说明了三者的区别，以List为原型展开说明：
```java


```





##### 6.6 元素的比较
###### 6.6.1 Comparable和Comparator






###### 6.6.2 hashCode和equals





##### 6.7 fail-fast机制





##### 6.8 Map类集合
###### 6.8.1 红黑树





###### 6.8.2 TreeMap






###### 6.8.3 HashMap





###### 6.8.4 ConcurrentHashMap





