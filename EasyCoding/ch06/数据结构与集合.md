#### 第6章 数据结构与集合
在代码世界中，集合是对"Collection"一词的翻译，事实上这么翻译仍不够准确。
在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set，它
具有确定性、无序性、互异性等特点。而Java中的集合表达的是数据结构的载体，
并未对应于数学概念上的集合，Java中的集合元素可以是有序的，也可以是重复的，
与数学中的要求不一样。本书中其他地方出现的集合概念，都指的是Collection，用
来保存各种各样的对象。我们经常说，“程序 = 数据结构 + 算法”。集合作为数据结
构的载体，可对元素进行加工和输出，以一定的算法实现最基本的增删改查功能，因
此集合是所有编程语言的基础

在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程
共享集合时出现的脏数据问题；某些集合在数据扩容时出现节点之间的死链问题；写
多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框
架，再到重点集合源码分析，最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手

##### 6.1 数据结构
1. 数据结构定义

数据结构是什么?网络上的一些定义十分抽象且各不相同，学习完之后，反而对
数据结构的概念更加模糊、更有敬畏之心。数据结构是指逻辑意义上的数据组织方式
及其相应的处理方式

(1) 什么是逻辑意义?数据结构的抽象表达非常丰富，而实际物理存储的方式
相对单一。比如，二叉树在磁盘中的存储真的是树形排列吗?并非如此。树的存储可
能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有7
个节点的二叉树，第一个格子放根节点，第二个格子放左子树根节点；并且根据引用
知道左叶子在后续的哪个格子里；第三个格子放右子树根节点，依此类推。此外，树
的存储也可能是基于物理上的链式存储方式，这里不再详细展开

(2) 什么是数据组织方式?逻辑意义上的组织方式有很多，比如树、图、队列、
哈希等。树可以是二叉树、三叉树、B+树等；图可以是有向图或无向图；队列是先
进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式

(3) 什么是数据处理方式?在既定的数据组织方式上，以某种特定的算法实现
数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性
能差异

2. 数据结构分类

数据结构是算法实现的基石，它是一种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。 如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类

(1 )线性结构：0至1个直接前继和直接后继。当线性结构非空时，有唯一的
首元素和尾元素，除两者外，所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。栈是后进先
出，即Last-In，First-Out， 简称LIFO；队列是先进先出，即First-In，First-Out，简称
FIFO

(2) 树结构：0至1个直接前继和0至n个直接后继(n大于或等于2)。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用

(3 )图结构：0至n个直接前继和直接后继(n大于或等于2)。图结构包括简
单图、多重图、有向图和无向图等

(4) 哈希结构：没有直接前继和直接后继。哈希结构通过某种特定的哈希函数
将索引与存储的值关联起来，它是一种查找效率非常高的数据结构

不同的数据组织方式和处理方式带来了一个新的问题：如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指
标，反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的O和一个函数描述，如O(n^3)表示程序
执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级O(1)、对数级O(logn)、线性级O(n)、线性对数级
O(nlogn)、平方级O(n^2)、立方级O(n^3)、指数级O(2^n)等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降

最后以“猜数字”为例进一步理解时间复杂度，主持人从1 ~ 100的范围内任选
一个数字，玩家随机猜一个数，如果没有猜中，主持人会提示猜大了还是猜小了，继
续这样的循环，直到猜对为止。显而易见，如果要猜测，最多要猜100次，最少只用
猜1次。经验表明，玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行1亿次，完全随机的情况下，平均猜测的次数是7.47次，近似二分法猜
测的是5.8次，时间复杂度为O(logn)

##### 6.2 集合框架图
Java中的集合是用于存储对象的工具类容器，它实现了常用的数据结构，提供了
一系列公开的方法用于增加、删除、修改、查找和遍历数据，降低了日常开发成本。
集合的种类非常多，形成了一个比较经典的继承关系树，称为Java集合框架图，如图6-1
所示。框架图中主要分为两类：第一类是按照单个元素存储的Collection，在继承树
中Set和List都实现了Collection接口；第二类是按照Key-Value存储的Map。以上
两类集合体系，无论数据存取还是遍历，都存在非常大的差异

在集合框架图中，红色代表接口，蓝色代表抽象类，绿色代表并发包中的类，灰
色代表早期线程安全的类(基本已经弃用)。可以看到，与Collection相关的4条线
分别是List、Queue、Set、Map，它们的子类会映射到数据结构中的表、树、哈希等。
对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。此图
相当于纲举目张的“纲”，虽然部分集合没有纳入此框架图中，但是容易沿着这个图
的思路理解其他集合。下面一起学习这4个常用集合类型

###### 6.2.1 List集合
List集合是线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个
元素，也存在明确的第一个元素和最后一个元素。List 集合的遍历结果是稳定的。该
体系最常用的是ArrayList和LinkedList两个集合类

ArrayList是容量可以改变的非线程安全集合。内部实现使用数组进行存储，集
合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList支持对元素
的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动
其他元素

LinkedList的本质是双向链表。与ArrayList相比，LinkedList的插入和删除速度
更快，但是随机访问速度则很慢。测试表明，对于10万条的数据，与ArrayList相比，
随机提取元素时存在数百倍的差距。除继承AbstractList抽象类外，LinkedList还实现
了另一个接口Deque，即double-endedqueue。这个接口同时具有队列和栈的性质。
LinkedList包含3个重要的成员：size、first、last。size是双向链表中节点的个数。
first和last分别指向第一个和最后一个节点的引用。LinkedList的优点在于可以将零
散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存
利用率较高

###### 6.2.2 Queue集合
Queue(队列)是一种先进先出的数据结构，队列是一种特殊的线性表， 它只允
许在表的一端进行获取操作，在表的另一端进行插入操作。当队列中没有元素时，称
为空队列。自从BlockingQueue(阻塞队列)问世以来，队列的地位得到极大的提升，
在各种高并发编程场景中，由于其本身FIFO的特性和阻塞操作的特点，经常被作为
Buffer(数据缓冲区)使用

###### 6.2.3 Map集合
Map集合是以Key-Value键值对作为存储元素实现的哈希结构，Key 按某种哈希
函数计算后是唯一的，Value则是可以重复的。Map类提供三种Collection视图，在
集合框架图中，Map指向Collection的箭头仅表示两个类之间的依赖关系。可以使用
keySet()查看所有的Key，使用values()查看所有的Value，使用entrySet() 查看所有
的键值对。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，而如今广泛
使用的HashMap，线程是不安全的。ConcurrentHashMap是线程安全的，在JDK8中
进行了锁的大幅度优化，体现出不错的性能。在多线程并发场景中，优先推荐使用
ConcurrentHashMap，而不是HashMap。TreeMap是Key有序的Map类集合

###### 6.2.4 Set集合
Set是不允许出现重复元素的集合类型。Set体系最常用的是HashSet、TreeSet
和LinkedHashSet三个集合类。HashSet从源码分析是使用HashMap来实现的，只是
Value固定为一个静态对象，使用Key保证集合元素的唯一性， 但它不保证集合元素
的顺序。TreeSet 也是如此，从源码分析是使用TreeMap来实现的，底层为树结构，
在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集
合仍然是有序的。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链
表维护了元素插入顺序

##### 6.3 集合初始化
集合初始化通常进行分配容量、设置特定参数等相关工作。我们以使用频率较高
的ArrayList和HashMap为例，简要说明初始化的相关工作，并解释为什么在任何情
况下，都需要显式地设定集合容量的初始大小。ArrayList是存储单个元素的顺序表结
构，HashMap是存储KV键值对的哈希式结构。分析两者的初始化相关源码，洞悉它
们的容量分配、参数设定等相关逻辑，有助于更好地了解集合特性，提升代码质量。
下面先从ArrayList源码说起：
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final int DEFAULT_CAPACITY = 10;
    // 空表的表示方法
    private static final Object[] EMPTY_ELEMENTDATA = {};
    transient object[] elementData;
    private int size;
    
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            // 值大于0时，根据构造方法的参数值，忠实地创建一个多大的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA; 
        }
    }
    
    // 公开的add万法调用此内部私有万法
    private void add(E e, Object[] elementData, int s) {
        // 当前数组能否容纳size+1的元素，如果不够，则调用grow来扩容
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1 ;
    }
    
    private Object[] grow() {
        return grow(size + 1);
    }
   
    // 扩容的最小要求，必须容纳刚才的元素个数+1,注意，newCapacity()
    // 方法才是扩容的重点!
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));
    }
    
    private int newCapacity(int minCapacity) {
        // 防止扩容1.5倍之后，超过int的表示范围    (第1处)
        int oldCapacity = elementData.length;
        // JDK6之前扩容50%或50%-1，但是取ceil, 而之后的版本取floor    (第2处)
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 无参数构造方法，会在此时分配默认为10的容量
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0)
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    }
}
```
第1处说明：正数带符号右移的值肯定是正值，所以oldCapacity+(oldCapacity>>1)
的结果可能超过int可以表示的最大值，反而有可能比参数的minCapacity更小，则返
回值为(size+1) 的minCapacity

第2处说明：如果原始容量是13，当新添加一个元素时，依据程序中的计算方法，
得出13的二进制数为1101，随后右移1位操作后得到二进制数110，即十进制数6。
最终扩容的大小计算结果为oldCapacitiy + (oldCapacity>>1) = 13 + 6 = 19。使用位运
算主要是基于计算效率的考虑。在JDK7之前的公式，扩容计算方式和结果为
oldCapacitiy × 3 ÷ 2 + 1 = 13 × 3 ÷ 2 + 1 = 20

当ArrayList使用无参构造时，默认大小为10，也就是说在第一次add的时候，
分配为10的容量，后续的每次扩容都会调用Array.copyOf方法，创建新数组再复
制。可以想象，假如需要将1000个元素放置在ArrayList 中，采用默认构造方法，
则需要被动扩容13次才可以完成存储。反之，如果在初始化时便指定了容量new
ArrayList(1000)，那么在初始化ArrayList 对象的时候就直接分配1000个存储空间，
从而避免被动扩容和数组复制的额外开销。最后，进一步设想，如果这个值达到更大
量级，却没有注意初始的容量分配问题，那么无形中造成的性能损耗是非常大的，甚
至导致OOM的风险

再来看一下HashMap，如果它需要放置1000个元素，同样没有设置初始容量大小，
随着元素的不断增加，则需要被动扩容7次才可以完成存储。扩容时需要重建hash表，
非常影响性能。在HashMap中有两个比较重要的参数：Capacity和Load Factor，其
中Capacity决定了存储容量的大小，默认为16；而Load Factor决定了填充比例，
一般使用默认的0.75。基于这两个参数的乘积，HashMap内部用threshold变量表示
HashMap中能放入的元素个数。HashMap 容量并不会在new的时候分配，而是在第
一次put的时候完成创建的，源码如下：
```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
     // ...省略代码
}

// 第一次put时，调用如下方法，初始化table
private void inflateTable(int toSize) {
    // 找到大于参数值且最接近2的冪值，假如输入参数是27，则返回32
    int capacity = roundUpToPowerOf2(toSize);
    
    // threshold 在不超过限制最大值的前提下等于capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}
```
为了提高运算速度，设定HashMap容量大小为2^n，这样的方式使计算落槽位置
更快。如果初始化HashMap的时候通过构造器指定了initialCapacity， 则会先计算出
比initialCapacity大的2的幂存入threshold，在第一次put时会按照这个2的幂初始化
数组大小，此后每次扩容都是增加2倍。如果没有指定初始值，log<sub>2</sub>1000 = 9.96，结
合源码分析可知，如果想要容纳1000个元素，必须经过7次扩容。HashMap的扩容
还是有不小的成本的，如果提前能够预估出HashMap内要放置的元素数量，就可以
在初始化时合理设置容量大小，避免不断扩容带来的性能损耗

综上所述，集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，
那么指定相应的默认值，这也要求我们记得各种集合的默认值大小，ArrayList 大小为
10，而HashMap默认值为16。 牢记每种数据结构的默认值和初始化逻辑，也是开发
工程师基本素质的体现

##### 6.4 数组与集合






##### 6.5 集合与泛型






##### 6.6 元素的比较





###### 6.6.1 Comparable和Comparator






###### 6.6.2 hashCode和equals





##### 6.7 fail-fast机制





##### 6.8 Map类集合




###### 6.8.1 红黑树





###### 6.8.2 TreeMap






###### 6.8.3 HashMap





###### 6.8.4 ConcurrentHashMap





