#### 第6章 数据结构与集合
在代码世界中，集合是对"Collection"一词的翻译，事实上这么翻译仍不够准确。
在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set，它
具有确定性、无序性、互异性等特点。而Java中的集合表达的是数据结构的载体，
并未对应于数学概念上的集合，Java中的集合元素可以是有序的，也可以是重复的，
与数学中的要求不一样。本书中其他地方出现的集合概念，都指的是Collection，用
来保存各种各样的对象。我们经常说，“程序 = 数据结构 + 算法”。集合作为数据结
构的载体，可对元素进行加工和输出，以一定的算法实现最基本的增删改查功能，因
此集合是所有编程语言的基础

在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程
共享集合时出现的脏数据问题；某些集合在数据扩容时出现节点之间的死链问题；写
多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框
架，再到重点集合源码分析，最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手

##### 6.1 数据结构
1. 数据结构定义

数据结构是什么?网络上的一些定义十分抽象且各不相同，学习完之后，反而对
数据结构的概念更加模糊、更有敬畏之心。数据结构是指逻辑意义上的数据组织方式
及其相应的处理方式

(1) 什么是逻辑意义?数据结构的抽象表达非常丰富，而实际物理存储的方式
相对单一。比如，二叉树在磁盘中的存储真的是树形排列吗?并非如此。树的存储可
能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有7
个节点的二叉树，第一个格子放根节点，第二个格子放左子树根节点；并且根据引用
知道左叶子在后续的哪个格子里；第三个格子放右子树根节点，依此类推。此外，树
的存储也可能是基于物理上的链式存储方式，这里不再详细展开

(2) 什么是数据组织方式?逻辑意义上的组织方式有很多，比如树、图、队列、
哈希等。树可以是二叉树、三叉树、B+树等；图可以是有向图或无向图；队列是先
进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式

(3) 什么是数据处理方式?在既定的数据组织方式上，以某种特定的算法实现
数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性
能差异

2. 数据结构分类

数据结构是算法实现的基石，它是一种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。 如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类

(1 )线性结构：0至1个直接前继和直接后继。当线性结构非空时，有唯一的
首元素和尾元素，除两者外，所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。栈是后进先
出，即Last-In，First-Out， 简称LIFO；队列是先进先出，即First-In，First-Out，简称
FIFO

(2) 树结构：0至1个直接前继和0至n个直接后继(n大于或等于2)。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用

(3 )图结构：0至n个直接前继和直接后继(n大于或等于2)。图结构包括简
单图、多重图、有向图和无向图等

(4) 哈希结构：没有直接前继和直接后继。哈希结构通过某种特定的哈希函数
将索引与存储的值关联起来，它是一种查找效率非常高的数据结构

不同的数据组织方式和处理方式带来了一个新的问题：如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指
标，反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的O和一个函数描述，如O(n^3)表示程序
执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级O(1)、对数级O(logn)、线性级O(n)、线性对数级
O(nlogn)、平方级O(n^2)、立方级O(n^3)、指数级O(2^n)等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降

最后以“猜数字”为例进一步理解时间复杂度，主持人从1 ~ 100的范围内任选
一个数字，玩家随机猜一个数，如果没有猜中，主持人会提示猜大了还是猜小了，继
续这样的循环，直到猜对为止。显而易见，如果要猜测，最多要猜100次，最少只用
猜1次。经验表明，玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行1亿次，完全随机的情况下，平均猜测的次数是7.47次，近似二分法猜
测的是5.8次，时间复杂度为O(logn)

##### 6.2 集合框架图
Java中的集合是用于存储对象的工具类容器，它实现了常用的数据结构，提供了
一系列公开的方法用于增加、删除、修改、查找和遍历数据，降低了日常开发成本。
集合的种类非常多，形成了一个比较经典的继承关系树，称为Java集合框架图，如图6-1
所示。框架图中主要分为两类：第一类是按照单个元素存储的Collection，在继承树
中Set和List都实现了Collection接口；第二类是按照Key-Value存储的Map。以上
两类集合体系，无论数据存取还是遍历，都存在非常大的差异

在集合框架图中，红色代表接口，蓝色代表抽象类，绿色代表并发包中的类，灰
色代表早期线程安全的类(基本已经弃用)。可以看到，与Collection相关的4条线
分别是List、Queue、Set、Map，它们的子类会映射到数据结构中的表、树、哈希等。
对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。此图
相当于纲举目张的“纲”，虽然部分集合没有纳入此框架图中，但是容易沿着这个图
的思路理解其他集合。下面一起学习这4个常用集合类型

###### 6.2.1 List集合
List集合是线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个
元素，也存在明确的第一个元素和最后一个元素。List 集合的遍历结果是稳定的。该
体系最常用的是ArrayList和LinkedList两个集合类

ArrayList是容量可以改变的非线程安全集合。内部实现使用数组进行存储，集
合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList支持对元素
的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动
其他元素

LinkedList的本质是双向链表。与ArrayList相比，LinkedList的插入和删除速度
更快，但是随机访问速度则很慢。测试表明，对于10万条的数据，与ArrayList相比，
随机提取元素时存在数百倍的差距。除继承AbstractList抽象类外，LinkedList还实现
了另一个接口Deque，即double-endedqueue。这个接口同时具有队列和栈的性质。
LinkedList包含3个重要的成员：size、first、last。size是双向链表中节点的个数。
first和last分别指向第一个和最后一个节点的引用。LinkedList的优点在于可以将零
散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存
利用率较高

###### 6.2.2 Queue集合
Queue(队列)是一种先进先出的数据结构，队列是一种特殊的线性表， 它只允
许在表的一端进行获取操作，在表的另一端进行插入操作。当队列中没有元素时，称
为空队列。自从BlockingQueue(阻塞队列)问世以来，队列的地位得到极大的提升，
在各种高并发编程场景中，由于其本身FIFO的特性和阻塞操作的特点，经常被作为
Buffer(数据缓冲区)使用

###### 6.2.3 Map集合
Map集合是以Key-Value键值对作为存储元素实现的哈希结构，Key 按某种哈希
函数计算后是唯一的，Value则是可以重复的。Map类提供三种Collection视图，在
集合框架图中，Map指向Collection的箭头仅表示两个类之间的依赖关系。可以使用
keySet()查看所有的Key，使用values()查看所有的Value，使用entrySet() 查看所有
的键值对。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，而如今广泛
使用的HashMap，线程是不安全的。ConcurrentHashMap是线程安全的，在JDK8中
进行了锁的大幅度优化，体现出不错的性能。在多线程并发场景中，优先推荐使用
ConcurrentHashMap，而不是HashMap。TreeMap是Key有序的Map类集合

###### 6.2.4 Set集合
Set是不允许出现重复元素的集合类型。Set体系最常用的是HashSet、TreeSet
和LinkedHashSet三个集合类。HashSet从源码分析是使用HashMap来实现的，只是
Value固定为一个静态对象，使用Key保证集合元素的唯一性， 但它不保证集合元素
的顺序。TreeSet 也是如此，从源码分析是使用TreeMap来实现的，底层为树结构，
在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集
合仍然是有序的。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链
表维护了元素插入顺序

##### 6.3 集合初始化
集合初始化通常进行分配容量、设置特定参数等相关工作。我们以使用频率较高
的ArrayList和HashMap为例，简要说明初始化的相关工作，并解释为什么在任何情
况下，都需要显式地设定集合容量的初始大小。ArrayList是存储单个元素的顺序表结
构，HashMap是存储KV键值对的哈希式结构。分析两者的初始化相关源码，洞悉它
们的容量分配、参数设定等相关逻辑，有助于更好地了解集合特性，提升代码质量。
下面先从ArrayList源码说起：
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final int DEFAULT_CAPACITY = 10;
    // 空表的表示方法
    private static final Object[] EMPTY_ELEMENTDATA = {};
    transient object[] elementData;
    private int size;
    
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            // 值大于0时，根据构造方法的参数值，忠实地创建一个多大的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA; 
        }
    }
    
    // 公开的add万法调用此内部私有万法
    private void add(E e, Object[] elementData, int s) {
        // 当前数组能否容纳size+1的元素，如果不够，则调用grow来扩容
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1 ;
    }
    
    private Object[] grow() {
        return grow(size + 1);
    }
   
    // 扩容的最小要求，必须容纳刚才的元素个数+1,注意，newCapacity()
    // 方法才是扩容的重点!
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));
    }
    
    private int newCapacity(int minCapacity) {
        // 防止扩容1.5倍之后，超过int的表示范围    (第1处)
        int oldCapacity = elementData.length;
        // JDK6之前扩容50%或50%-1，但是取ceil, 而之后的版本取floor    (第2处)
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 无参数构造方法，会在此时分配默认为10的容量
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0)
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    }
}
```
第1处说明：正数带符号右移的值肯定是正值，所以oldCapacity+(oldCapacity>>1)
的结果可能超过int可以表示的最大值，反而有可能比参数的minCapacity更小，则返
回值为(size+1) 的minCapacity

第2处说明：如果原始容量是13，当新添加一个元素时，依据程序中的计算方法，
得出13的二进制数为1101，随后右移1位操作后得到二进制数110，即十进制数6。
最终扩容的大小计算结果为oldCapacitiy + (oldCapacity>>1) = 13 + 6 = 19。使用位运
算主要是基于计算效率的考虑。在JDK7之前的公式，扩容计算方式和结果为
oldCapacitiy × 3 ÷ 2 + 1 = 13 × 3 ÷ 2 + 1 = 20

当ArrayList使用无参构造时，默认大小为10，也就是说在第一次add的时候，
分配为10的容量，后续的每次扩容都会调用Array.copyOf方法，创建新数组再复
制。可以想象，假如需要将1000个元素放置在ArrayList 中，采用默认构造方法，
则需要被动扩容13次才可以完成存储。反之，如果在初始化时便指定了容量new
ArrayList(1000)，那么在初始化ArrayList 对象的时候就直接分配1000个存储空间，
从而避免被动扩容和数组复制的额外开销。最后，进一步设想，如果这个值达到更大
量级，却没有注意初始的容量分配问题，那么无形中造成的性能损耗是非常大的，甚
至导致OOM的风险

再来看一下HashMap，如果它需要放置1000个元素，同样没有设置初始容量大小，
随着元素的不断增加，则需要被动扩容7次才可以完成存储。扩容时需要重建hash表，
非常影响性能。在HashMap中有两个比较重要的参数：Capacity和Load Factor，其
中Capacity决定了存储容量的大小，默认为16；而Load Factor决定了填充比例，
一般使用默认的0.75。基于这两个参数的乘积，HashMap内部用threshold变量表示
HashMap中能放入的元素个数。HashMap 容量并不会在new的时候分配，而是在第
一次put的时候完成创建的，源码如下：
```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
     // ...省略代码
}

// 第一次put时，调用如下方法，初始化table
private void inflateTable(int toSize) {
    // 找到大于参数值且最接近2的冪值，假如输入参数是27，则返回32
    int capacity = roundUpToPowerOf2(toSize);
    
    // threshold 在不超过限制最大值的前提下等于capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}
```
为了提高运算速度，设定HashMap容量大小为2^n，这样的方式使计算落槽位置
更快。如果初始化HashMap的时候通过构造器指定了initialCapacity， 则会先计算出
比initialCapacity大的2的幂存入threshold，在第一次put时会按照这个2的幂初始化
数组大小，此后每次扩容都是增加2倍。如果没有指定初始值，log<sub>2</sub>1000 = 9.96，结
合源码分析可知，如果想要容纳1000个元素，必须经过7次扩容。HashMap的扩容
还是有不小的成本的，如果提前能够预估出HashMap内要放置的元素数量，就可以
在初始化时合理设置容量大小，避免不断扩容带来的性能损耗

综上所述，集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，
那么指定相应的默认值，这也要求我们记得各种集合的默认值大小，ArrayList 大小为
10，而HashMap默认值为16。 牢记每种数据结构的默认值和初始化逻辑，也是开发
工程师基本素质的体现

##### 6.4 数组与集合
数组是一种顺序表，在各种高级语言中，它是组织和处理数据的一种常见方式，
我们可以使用索引下标进行快速定位并获取指定位置的元素。数组的下标从0开始，
但这并不符合生活常识，这源于BCPL语言，它将指针设置在0的位置，用数组下标
作为直接偏移量进行计算。为什么下标不从1开始呢?如果是这样，计算偏移量就要
使用当前下标减1的操作。加减法运算对CPU来说是一种双数运算， 在数组下标使
用频率极高的场景下，这种运算是十分耗时的。在Java体系中，数组用以存储同一
类型的对象，一旦分配内存后则无法扩容。提倡类型与中括号紧挨相连来定义数组，
因为在Java的世界里，万物皆为对象。String[]用来指代String数组对象，示例代码
如下：
```java
String[] args = {"a", "b"};
// 数组引用赋值给Object
Object obj = args;
// 使用类名String[]进行强制转化，并成功赋值，args[0]的值由a变为object
((String[]) obj)[0] = "object";
```
声明数组和赋值的方式示例代码如下：
```java
// 初始化完成，容量的大小即等于大括号内元素的个数，使用频率并不高
String[] args3 = {"a", "b"};
String[] args4 = new String[2];
args4[0] = "a";
args4[1] = "b";
```
上述源码中的args3是静态初始化，而args4是动态初始化。无论静态初始化还
是动态初始化，数组是固定容量大小的。注意在数组动态初始化时，出现了new，这
意味着需要在new String[]的方括号内填写一个整数。如果写的是负数，并不会编译
出错，但运行时会抛出异常：NegativeArraySizeException。 对于动态大小的数组，集
合提供了Vector和ArrayList两个类，前者是线程安全，性能较差，基本弃用，而后
者是线程不安全，它是使用频率最高的集合之一

数组的遍历优先推荐JDK5引进的foreach方式，即for(元素 : 数组名)的方式，
可以在不使用下标的情况下遍历数组。如果需要使用数组下标，则使用for (int i = 0;
i < array.length; i++)的方式，注意length是数组对象的一个属性，而不是方法(注：
String类是使用length()方法来获取字符串长度的)。也可以使用JDK8的函数式接
口进行遍历：
```java
Arrays.asList(args3).stream().forEach(x -> System.out.println(x));
Arrays.asList(args3).stream().forEach(System.out::println);
```
Arrays是针对数组对象进行操作的工具类，包括数组的排序、查找、对比、拷贝
等操作。尤其是排序，在多个JDK版本中在不断地进化，比如原来的归并排序改成
Timsort，明显地改善了集合的排序性能。另外，通过这个工具类也可以把数组转成集合

数组与集合都是用来存储对象的容器，前者性质单一，方便易用；后者类型
安全，功能强大，且两者之间必然有互相转换的方式。毕竟它们的性格迥异，在
转换过程中，如果不注意转换背后的实现方式，很容易产生意料之外的问题。转
换分成两种情况：数组转集合和集合转数组。在数组转集合的过程中，注意是否
使用了视图方式直接返回数组中的数据。我们以Arrays.asList()为例，它把数组转
换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
UnsupprtedOperationException异常。示例源码如下：
```java
public class ArraysAsList {
    public static void main(String[] args) {
        String[] stringArray = new String[3] ;
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        
        List<String> stringList = Arrays.asList(stringArray);
        // 修改转换后的集合，成功地把第一个元素"one"改成"oneList"
        stringList.set(0, "oneList");
        // 运行结果是1. 数组的值随之改变
        System.out.printl(stringArray[0]);
        
        // 这是重点：以下三行编译正确，但都会抛出运行时异常
        stringList.add("four");
        stringList.remove(2);
        stringList.clear();
    }
}
```
事实证明，可以通过set()方法修改元素的值，原有数组相应位置的值
同时也会被修改，但是不能进行修改元素个数的任何操作，否则均会抛出
UnsupportedOperationException异常。ArrysasList体现的是适配器模式，后台的数据
仍是原有数组，set()方法即间接对数组进行值的修改操作。asList的返回对象是一个
Arrays的内部类，它并没有实现集合个数的相关修改方法，这也正是拋出异常的原因。
Arrays.asList的源码如下：
```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```
返回的明明是ArrayList对象，怎么就不可以随心所欲地对此集合进行修改呢?
注意此ArrayList非彼ArrayList，虽然Arrays与ArrayList同属于一个包，但是在
Arrays类中还定义了一个ArrayList的内部类(或许命名为InnerArrayList更容易识别)，
根据作用域就近原则，此处的ArrayList是李鬼，即这是个内部类。此李鬼十分简单，
只提供了个别方法的实现，如下所示：
```java
private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java. io.Serializable {
    // final修饰不准修改其引用    (第1处)
    private final E[] a;
        
    // 直接把数组引用赋值给a，而Objects是JDK7引入的工具包
    // requireNonNull仅仅判断是否为null
    ArrayList(E[] array) {
        a = Objects.requireNonNull(array);
    }
    // 实现了修改特定位置元素的方法
    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        // 注意set成功返回的是此位置上的旧值
        return oldValue;
    }
}
```
第1处的final引用，用于存储集合的数组引用始终被强制指向原有
数组。这个内部类并没有实现任何修改集合元素个数的相关方法，那这个
UnsupportedOperationException异常是从哪里抛出来的呢?是李鬼的父类
AbstractList：

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }
    
    // clear()方法调用remove方法，依然抛出异常
    public void clear() {
        removeRange(0, size());
    }
}
```
如果李鬼Arrays.ArrayList内部类覆写这些方法不抛出异常，避免使用者踩进这
个坑会不会更好?数组具有不为五斗米折腰的气节，传递的信息是“ 要么直接用我，
要么小心异常!” 数组转集合引发的故障还是十分常见的。比如，某业务调用某接口时，
对方以这样的方式返回一个List类型的集合对象，本方获取集合数据时，99.9%是只
读操作，但在小概率情况下需要增加一个元素，从而引发故障。在使用数组转集合时，
需要使用李逵java.util.ArrayList直接创建一个新集合， 参数就是Arrays.asList返回的
不可变集合，源码如下：
```java
public class ListToArray {
    public static void main(String[] args) {
        List<String> list = new ArrayList<string>(3);
        list.add("one");
        list.add("two");
        list.add("three");
        
        // 泛型丢失，无法使用String[]接收无参方法返回的结果    (第1处)
        Object[] array1 = list.toArray();
        
        // array2数组长度小于元素个数    (第2处)
        String[] array2 = new String[2];
        list.toArray(array2);
        System.out.println(Arrays.asList(array2));
        
        // array2 数组长度等于元素个数    (第3处)
        String[] array3 = new String[3];
        list.toArray(array3);
        System.out.println (Arrays.asList(array3));
    }
}
```
执行结果如下：
```text
[null, null]
[one, two, three]
```
第1处比较容易理解，不要用toArray()无参方法把集合转换成数组，这样会导
致泛型丢失；在第2处执行成功后，输出却为null；第3处正常执行，成功地把集合
数据复制到array3数组中。第2处与第3处的区别在于即将复制进去的数组容量是否
足够。如果容量不够，则弃用此数组，另起炉灶，关于此方法的源码如下：
```java
// 注意入参数组的length大小是重中之重，如果大于或等于集合的大小
// 则集合中的数据复制进入数组即可，如果空间不够，入参数组a就会被无视
// 重新分配一个空间，复制完成后返回一个新的数组引用
public <t> T[] toArray(T[] a) {
    if (a.length < size) {
        // 如果数组长度小于集合size，那么执行此语句，直接return    (第1处)
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    }
    
    // 如果容量足够，则直接复制    (第2处)
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size) {
        a[size] = null;
    }
    
    // 只有在数组容量足够的情况下，才返回传入参数
    return a;
}
```
在第1处和第2处均复制java.util.ArrayList的elementData到数组中，这
个elementData是ArrayList集合对象中真正用于存储数据的数组，它的定义为：
transient Object[] elementData;

这个存储ArrayList真正数据的数组由transient修饰，表示此字段在类的序列化
时将被忽略。因为集合序列化时系统会调用writeObject写入流中，在网络客户端反
序列化的readObject时，会重新赋值到新对象的elementData中。为什么多此一举?
因为elementData容量经常会大于实际存储元素的数量，所以只需发送真正有实际值
的数组元素即可。回到刚才的场景，当入参数组容量小于集合大小时，使用Arrays.
copyOf()方法，它的源码如下：
```java
public static <t> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    // 新创建一个数组copy
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength); 
    System.arraycopy(original, 0, copy, 0,
        Math.min(original.length, newLength));
    return copy;
}
```
我们用示例代码模拟可能出现的三种情况，分别为入参数组容量不够时、入参数
组容量刚好时，以及入参数组容量超过集合大小时，并记录其执行时间：
```java
public class ToArraySpeedTest {
    private static final int COUNT = 100 * 100 * 100;
    
    public static void main(String[] args) {
        List<Double> list = new ArrayList<>(COUNT);
        // 构造一个100万个元素的测试集合
        for (int i = 0; i < COUNT; i++) {
            list.add(i * 1.0);
        }
        
        long start = System.nanoTime();
        
        Double[] notEnoughArray = new Double[COUNT- 1];
        list.toArray(notEnoughArray);
        
        long middle1 = System.nanoTime();
        
        Double[] equalArray = new Double[COUNT];
        list.toArray(equalArray);
        
        long middle2 = System.nanoTime();
        
        Double[] doubleArray = new Double[COUNT * 2];
        list.toArray(doubleArray);
        long end = System.nanoTime();
        
        long notEnoughArrayTime = middle1 - start;
        long equalArrayTime = middle2 - middle1;
        long doubleArrayTime = end - middle2;
        
        System.out.println("数组容量小于集合大小：notEnoughArrayTime:
            + notEnoughArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量等于集合大小：equalArrayTime:
            + equalArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量是集合的两倍：doubleArrayTime:
            + doubleArrayTime / (1000.0 * 1000.0) + " ms");
    }
}
```
执行结果如下：
```text
数组长度小于集合大小: notEnoughArrayTime: 12.317152 ms
数组长度等于集合大小: equalArrayTime: 9.327377 ms
数组长度是集合的两倍: doubleArrayTime: 13. 547622 ms
```
具体的执行时间，由于CPU资源占用的随机性，会有一定差异。多次运行结果
显示，当数组容量等于集合大小时，运行总是最快的，空间消耗也是最少的。由此
证明，如果数组初始大小设置不当，不仅会降低性能，还会浪费空间。使用集合的
toArray(T[] array)方法，转换为数组时，注意需要传入类型完全一样的数组，并且它
的容量大小为list.size()

##### 6.5 集合与泛型
泛型与集合的联合使用，可以把泛型的功能发挥到极致，很多程序员不清楚
List、List\<Object\>、List<?> 三者的区别，更加不能区分<? extends T>与<? super T>
的使用场景。List完全没有类型限制和赋值限定，如果天马行空地乱用，迟早会遭遇
类型转换失败的异常。很多程序员觉得List\<Object\>的用法完全等同于List，但在接
受其他泛型赋值时会编译出错。List<?>是一个泛型，在没有赋值之前，表示它可以
接受任何类型的集合赋值，赋值之后就不能随便往里添加元素了。下方的例子很好地
说明了三者的区别，以List为原型展开说明：

```java
public class ListNoGeneric {
    public static void main(String[] args) {
        
        // 第一段：泛型出现之前的集合定义方式
        List a1 = new ArrayList();
        a1.add(new Object());
        a1.add(new Integer(111));
        a1.add(new String("hello a1a1"));
        
        // 第二段：把a1引用赋值给a2，注意a2与a1的区别是增加了泛型限制<Object>
        List<Object> a2 = a1;
        a2.add(new Object());
        a2.add(new Integer(222));
        a2.add(new String("hello a2a2"));
        
        // 第三段：把a1引用赋值给a3，注意a3与a1的区别是增加了泛型<Integer>
        List<Integer> a3 = a1;
        a3.add(new Integer(333));
        // 下方两行编译出错，不允许增加非Integer类型进入集合
        a3.add(new Object());
        a3.add(new String("hel1o a3a3"));
        
        // 第四段：把a1引用赋值给a4，a1与a4的区别是增加了通配符
        List<?> a4 = a1;
        // 允许删除和清除元素
        a1.remove(0);
        a4.clear();
        // 编译出错。不允许增加任何元素
        a4.add (new Object());
    }
}
```
第一段说明：在定义List之后，毫不犹豫地往集合里装入三种不同的对象：
Object、Integer和String，遍历没有问题，但是贸然以为里边的元素都是Integer，使
用强制转化，则抛出ClassCastException异常

第二段说明：把a1赋值给a2，a2是List\<Object\>类型的，也可以再往里装入三
种不同的对象。很多程序员认为List和List\<Object\>是完全相同的，至少从目前这两
段来看是这样的

第三段说明：由于泛型在JDK5之后才出现，考虑到向前兼容，因此历史代码有
时需要赋值给新泛型代码，从编译器角度是允许的。这种代码似乎有点反人类，在实
际故障案例中经常出现，来看一段问题代码
```java
JSONObject jsonObject = JSONObject.fromObject("{\"level\":[\"3\"]}");
List<Integer> intList = new ArrayList<Integer>(10);

if (jsonObject != null) {
    intList.addAll(jsonObject.getJSONArray("level"));
    int amount = 0;
    for (Integer t : intList) {
        // 抛出ClassCastException异常：String cannot be cast to Integer
        if (condition) {
            amount = amount + t;
        }
    }
}
```
addAll的定义如下：
```java
public boolean addAll(Collection<? extends E> c) {...}
```
进行了泛型限制，示例中addAll的实际参数是getJSONArray返回的JSONArray
对象，它并非是List，更加不是Integer集合的子类，为何编译不报错?查看
JSONArray的定义：
```java
public final class JSONArray extends AbstractJSON implements JSON, List {}
```
JSONArray实现了List，是非泛型集合，可以赋值给任何泛型限制的集合。编译
可以通过，但在运行时报错，这是一个隐藏得比较深的Bug，最终导致发生线上故障。
在JDK5之后，应尽量使用泛型定义，以及使用类、集合、参数等

如果把a1的定义从List a1修改为List\<Object\> a1，那么第三段就会编译出错。
List\<Object\>赋值给List\<Integer\>是不允许的，若是反过来赋值：
```java
List<Integer> intList = new ArrayList<Integer>(3) ;
intList.add(111) ;
List<Object> objectList = intList;
```
事实上，依然会编译出错，提示如下：
```text
Error:(10,26)java:incompatible types: java.util.List<java.lang.Integer> cannot be converted to java.util.List<java.lang.Object)
```
注意，数组可以这样赋值，因为它是协变的，而集合不是

第四段说明：问号在正则表达式中可以匹配任何字符，List\<?\> 称为通配符集合。
它可以接受任何类型的集合引用赋值，不能添加任何元素，但可以remove和clear，
并非immutable集合。List\<?\>一般作为参数来接收外部的集合，或者返回一个不知道
具体元素类型的集合

List\<T\>最大的问题是只能放置一种类型，如果随意转换类型的话，就是“破窗
理论”，泛型就失去了类型安全的意义。如果需要放置多种受泛型约束的类型呢?
JDK的开发者顺应了民意，实现了<? extends T>与<? super T>两种语法，但是两者
的区别非常微妙。简单来说，<? extends T>是Get First，适用于，消费集合元素为主
的场景； <? super T>是Put First，适用于生产集合元素为主的场景

<? extends T>可以赋值给任何T及T子类的集合，上界为T，取出来的类型带有
泛型限制，向上强制转型为T。null可以表示任何类型，所以除null外，任何元素都
不得添加进<? extends T>集合内

<? super T>可以赋值给任何T及T的父类集合，下界为T。在生活中，投票选
举类似于<? super T>的操作。选举代表时，你只能往里投选票，取数据时，根本不
知道是谁的票，相当于泛型丢失。有人说，这只是一种生活场景，在系统设计中，很
难有这样的情形。再举例说明一下，我们在填写对主管的年度评价时，提交后若想再
次访问之前的链接修改评价，就会被告之：“ 您已经完成对主管的年度反馈，谢谢参
与。”extends的场景是put功能受限，而super的场景是get功能受限

下例中，以加菲猫、猫、动物为例，说明extends和super的详细语法差异：
```java
// 用动物的猫科与加菲猫的继承关系说明extends与super在集合中的意义
public class AnimalCatCarfield {
    public static void main(String[] args) {
        // 第1段：声明三个依次继承的类的集合：Object > 动物 > 猫 > 加菲猫
        List<Animal> animal = new ArrayList<Animal>();
        List<Cat> cat = new ArrayList<Cat>();
        List<Garfield> garfield = new ArrayList<Garfield>();
        
        animal.add(new Animal());
        cat.add(new Cat());
        garfield.add(new Garfield());
        
        // 第2段：测试赋值操作
        // 下行编译出错。只能赋值Cat或Cat子类的集合
        List<? extends Cat> extendsCatFromAnimal = animal;
        List<? super Cat> superCatFromAnimal = animal;
        
        List<? extends Cat> extendsCatFromCat = cat;
        List<? super Cat> superCatFromCat = cat;
        
        List<? extends Cat> extendsCatFromGarfield = garfield;
        // 下行编译出错。只能赋值Cat或Cat父类的集合
        List<? super Cat> superCatFromGarfield = garfield;
        
        // 第3段：测试add方法
        // 下面三行中所有的<? extends T>都无法进行add操作，编译均出错
        extendsCatFromCat.add(new Animal());
        extendsCatFromCat.add(new Cat());
        extendsCatFromCat.add(new Garfield());
        
        // 下行编译出错。只能添加Cat或Cat子类的集合
        superCatFromCat.add(new Animal());
        superCatFromCat.add(new Cat());
        superCatFromCat.add(new Garfield());
        
        // 第4段：测试get方法
        // 所有的super操作能够返回元素，但是泛型丢失，只能返回Object对象
        
        // 以下extends操作能够返回元素
        Object catExtends2 = extendsCatFromCat.get(0);
        Cat catExtends1 = extendsCatFromCat.get(0);
        // 下行编译出错。虽然Cat集合从Garfield賦值而来，但类型擦除后，是不知道的
        Garfield garfield1 = extendsCatFromGarfield.get(0);
    }
}
```
第1段，声明三个泛型集合，可以理解为三个不同的笼子，List\<Animal\> 住的是
动物(反正就是动物世界里的动物)，List\<Cat\> 住的是猫(反正就是猫科动物)，
List\<Garfield\>住的是加菲猫(又懒又可爱的一种猫)。Garfield继承于Cat，而Cat
继承自Animal

第2段，以Cat类为核心，因为它有父类也有子类。定义类型限定集合，分别
为List<? extends Cat>和List<? super Cat>。在理解这两个概念时，暂时不要引入上
界和下界，专注于代码本身就好。把List\<Cat\>对象赋值给两者都是可以的。但是把
List\<Animal\>赋值给List\<Cat\>时会编译出错。因为能赋值给<? extends Cat>的类型，
只有Cat自己和它的子类。尽管它是类型安全的，但依然有泛型信息，因而从笼子里
取出来的必然是只猫，而List\<Animal\>里边有可能住着毒蛇、鳄鱼、蝙蝠等 其他动物

把List\<Garfield\>赋值给List<? super Cat>时，也会编译报错。因为能赋值给
<? superCat>的类型，只有Cat自己和它的父类

第3段，所有的List<? extends T>都会编译出错，无法进行add操作，这是因为
除null外，任何元素都不能被添加进<? extends T>集合内。List<? super Cat>可以往
里增加元素，但只能添加Cat自身及子类对象，假如放入一块石头，则明显违背了
Animal大类的性质

第4段，所有List<? super T>集合可以执行get操作，虽然能够返回元素，但是
类型丢失，即只能返回Object对象。List<? extends Cat>可以返回带类型的元素，但
只能返回Cat自身及其父类对象，因为子类类型被擦除了

对于一个笼子，如果只是不断地向外取动物而不向里放的话，则属于Get First,
应采用<? extends T>；相反，如果经常向里放动物的话，则应采用<? super T>，属于
Put First

##### 6.6 元素的比较
###### 6.6.1 Comparable和Comparator
Java中两个对象相比较的方法通常用在元素排序中，常用的两个接口分别是
Comparable和Comparator，前者是自己和自己比，可以看作是自营性质的比较器；后
者是第三方比较器，可以看作是平台性质的比较器。从词根上分析, Comparable以-able
结尾，表示它有自身具备某种能力的性质，表明Comparable对象本身是可以与同类
型进行比较的，它的比较方法是compareTo；而Comparator以-or结尾，表示自身是
比较器的实践者，它的比较方法是compare

我们经常说的自然排序其实是以人类对常识认知的升序排序，比如数字的1、2、
3，字母的a、b、c等。我们熟知的Integer和String实现的就是Comparable的自然排序。
而我们在使用某个自定义对象时，可能需要按照自己定义的方式排序，比如在搜索列
表对象SearchResult中进行大小比较时，先根据相关度排序，然后再根据浏览数排序，
实现这样的自定义Comparable的示例代码如下：
```java
public class SearchResult implements Comparable<SearchResult> {
    int relativeRatio;
    long count;
    int recentOrders;
    
    public SearchResult(int relativeRatio, long count) {
        this.relativeRatio = relativeRatio;
        this.count = count;
    }
    
    @Override
    public int compareTo(SearchResult o) {
        // 先比较相关度
        if (this.relativeRatio != o.relativeRatio) {
            return this.relativeRatio > o.relativeRatio ? 1 : -1;
        }
        // 相关度相等时再比较浏览数
        if (this.count != o.count) {
            return this.count > o.count ? 1 : -1;
        }
        return 0;
    }
    
    public void setRecentOrders(int recentOrders) {
        this.recentOrders = recentOrders;
    }
}
```
实现Comparable时，可以加上泛型限定，在编译阶段即可发现传入的参数非
SearchResult对象，不需要在运行期进行类型检查和强制转换。如果这个排序的规则
不符合业务方的要求，那么就需要修改这个类的比较方法compareTo，然而我们都知
道开闭原则，即最好不要对自己已经交付的类进行修改。另外，如果另一个业务方也
在使用这个比较方法呢?甚至再极端一点，这个SearchResult是他人提供的类，我们
可能连源码都没有。所以，我们其实需要在外部定义比较器，即Comparator

正因为Comparator的出现，业务方可以根据需要修改排序规则。如在上面的示
例代码中，如果业务方需要在搜索时将最近订单数(recentOrders)的权重调整到相关
度与浏览数之间，则使用Comparator实现的比较器如下所示：
```java
public class SearchResultComparator implements Comparator<SearchResult> {
    @Override
    public int compare(SearchResult o1, SearchResult o2) {
        // 相关度是第一排序准则，更高者排前(避免if-else嵌套过多使用卫语句来实现)
        if (o1.relativeRatio != o2.relativeRatio) {
            return o1.relativeRatio > o2.relativeRatio ? 1 : -1;
        }
        
        // 如果相关度一样，则最近订单数多者排前
        if (o1.recentOrders != o2.recentOrders) {
            return o1.recentorders > o2.recentOrders ? 1 : -1;
        }
        
        // 如果相关度和最近订单数都一样，则浏览数多者排前
        if (o1. count != o2 . count) {
            return ol.count > o2.count ? 1 : -1;
        }
        
        return 0;
    }
}
```
在JDK中，Comparator最典型的应用是在Arrays.sort中作为比较器参数进行排序：
```java
public static <t> void sort(T[] a, Comparator<? super T> c) {
    if(c == null) {
        sort(a);
    } else {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, c);
        else
            TimSort.sort(a, 0, a.length, c, null, 0, 0);    // (第1处)
    }
}
```
红色的<? super T>语法为下限通配，也就是将泛型类型参数限制为T或T的某
个父类，直到Object。该语法只能用在形参中来限定实参调用。如果本例中不加限定，
假定sort对象是Integer，那么传入String时就会编译报错，就是充分利用了多态的向
下转型的功能

约定俗成，不管是Comparable还是Comparator，小于的情况返回-1，,等于的情
况返回0，大于的情况返回1。当然，很多代码里只是判断是否大于或小于0，如在
集合中使用比较器进行排序时，直接使用正负来判断比较的结果：
```java
result = comparator.compare(key, t.key);
if (result < 0)
    t = t.left;
else if (result > 0)
    t = t.right;
else
    return t;
```
我们再回到之前sort()方法中的TimSort算法，是归并排序Merge Sort)与插入
排序(Insertion Sort )优化后的排序算法

首先回顾一下归并排序的原理。长度为1的数组是排序好的，有n个元素的集合
可以看成是n个长度为1的有序子集合；对有序子集合进行两两归并，并保证结果子
集合有序，最后得到n/2个长度为2的有序子集合；重复上一步骤直到所有元素归并
成一个长度为n的有序集合。在此排序过程中，主要工作都在归并处理中，如何使归
并过程更快，或者如何减少归并次数，成为优化归并排序的重点

再回顾插入排序工作的工作原理：长度为1的数组是有序的，当有了k个已排
序的元素，将第k+1个元素插入已有的k个元素中合适的位置，就会得到一个长度
为k+1已排序的数组。假设有n个元素且已经升序排列的数组，并且在数组尾端有第
n+1个元素的位置，此时如果想要添加一个新的元素并保持数组有序，根据插入排序，
可以将新元素放到第n+1个位置上，然后从后向前两两比较，如果新值较小则交换位
置，直到新元素到达正确的位置

2002年Tim Peters结合归并排序和插入排序的优点，实现了TimSort排序算
法。该算法避免了归并排序和插入排序的缺点，相对传统归并排序，减少了归并次
数，相对插入排序，引入了二分排序概念，提升了排序效率。TimSort算法对于已经
部分排序的数组，时间复杂度最优可达O(n)；对于随机排序的数组，时间复杂度为
0(nlogn)，平均时间复杂度为O(nlogn)。 因此Java在JDK7中使用TimSort算法取代
了原来的归并排序。它有两个主要优化：

(1) 归并排序的分段不再从单个元素开始，而是每次先查找当前最大的排序好
的数组片段run，然后对run进行扩展并利用二分排序，之后将该run与其他已经排
序好的run进行归并，产生排序好的大run

(2) 引入二分排序，即binarySort。二分排序是对插入排序的优化，在插入排序
中不再是从后向前逐个元素对比，而是引入了二分查找的思想，将一次查找新元素合
适位置的时间复杂度由O(m)降低到O(logn)

###### 6.6.2 hashCode和equals
hashCode和equals用来标识对象，两个方法协同工作可用来判断两个对象是否
相等。众所周知，根据生成的哈希将数据离散开来，可以使存取元素更快。对象通过
调用Object.hashCode()生成哈希值；由于不可避免地会存在哈希值冲突的情况，因此
当hashCode相同时，还需要再调用equals进行一次值的比较；但是，若hashCode不
同，将直接判定Objects不同，跳过equals，这加快了冲突处理效率。Object类定义
中对hashCode和equals要求如下：

(1 )如果两个对象的equals的结果是相等的，则两个对象的hashCode的返回结
果也必须是相同的

(2) 任何时候覆写equals,都必须同时覆写hashCode

在Map和Set类集合中，用到这两个方法时，首先判断hashCode的值，如果
hash相等，则再判断equals的结果，HashMap的get判断代码如下：

```java
if (e.hash == hash && ((k = e.key) == key || (key != null
    && key.equals(k))))
    return (e = getNode(hash(key), key)) == null ? null : e.value;
```
if条件表达式中的e.hash == hash是先决条件，只有相等才会执行阴影部分。如
果不相等，则阴影部分后边的equals根本不会被执行。equals不相等时并不强制要求
hashCode也不相等，但是一个优秀的哈希算法应尽可能地让元素均匀分布，降低冲
突概率，即在equals不相等时尽量使hashCode也不相等，这样&&或||短路操作一
旦生效，会极大地提高程序的执行效率。如果自定义对象作为Map的键，那么必须
覆写hashCode和equals。此外，因为Set存储的是不重复的对象，依据hashCode和
equals进行判断，所以Set存储的自定义对象也必须覆写这两个方法。此时如果覆写
了equals，而没有覆写hashCode，具体会有什么影响，让我们通过如下示例代码深入
体会：
```java
public class EqualsObject {
    private int id;
    private String name;
    
    public EqualsObject(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    @Override
    public boolean equals(Object obj) {
        // 如果为null，或者并非同类，则直接返回false    (第1处)
        if (obj == null || this.getClass() != obj.getClass()) {
            return false;
        }
        
        // 如果引用指向同一个对象，则返回true
        if (this == obj) {
            return true;
        }
        // 需要强制转换来获取EqualsObject的方法
        EqualsObject temp = (EqualsObject)obj;
        // 本示例判断标准是两个属性值相等，逻辑随业务场景不同而不同
        if (temp.getId() == this.id && name.equals(temp.getName())) {
            return true ;
        }
            return false;
    }
    
    // getter and setter...
}
```
第1处说明：首先判断两个对象的类型是否相同，如果不匹配，则直接返回
false。此处使用getClass的方式，就是严格限制了只有EqualsObject对象本身才可以
执行equals操作

这里并没有覆写hashCode,那么把这个对象放置到Set集合中去：
```java
Set<EqualsObject> hashSet = new HashSet<>();
EqualsObject a = new EqualsObject(1, "one");
EqualsObject b = new EqualsObject(1, "one");
EqualsObject C = new EqualsObject(1, "one");
hashSet.add(a);
hashSet.add(b);
hashSet.add(c);
System.out.println(hashSet.size());
```
输出的结果是3。虽然这些对象显而易见是相同的，但在HashSet操作中，应该
只剩下一个，为什么结果是3呢?因为如果不覆写hashCode()，即使equals()相等也
毫无意义，Object.hashCode()的实现是默认为每一个对象生成不同的int数值，它本
身是native方法，一般与对象内存地址有关。下面查看C++的源码实现：
```C++
VM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 JVMWrapper("JVM THashCode");
 return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode
      (THREAD, JNIHandles::resolve_non_null(handle));
VM_END
```
ObjectSynchronizer的核心代码如下，从代码分析角度也印证了hashCode就是根
据对象的地址进行相关计算得到int类型数值的：
```C++
mark = monitor->header();
assert(mark->is_neutral(), "invariant");
hash = mark->hash();

intptr_t hash() const {
    return mask_bits(value() >> hash_shift, hash_mask);
}
```
因为EqualsObject没有覆写hashCode，所以得到的是一个与对象地址相关
的唯一值，回到刚才的HashSet集合上，如果想存储不重复的元素，那么需要在
EqualsObject类中覆写hashCode()：

```java
@Override
public int hashCode() {
    return id + name.hashCode();
}
```
EqualsObject的name属性是String类型，String覆写了hashCode()，所以可以直
接调用。equals()的实现方式与类的具体处理逻辑有关，但又各不相同，因而应尽量
分析源码来确定其判断结果，比如下列代码：

```java
public class ListEquals {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(1);
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        arrayList.add(1);
        
        if (arrayList.equals(linkedList)) {
            System.out.println("equals is true");
        } else {
            System.out.println("equals is false");
        }
    }
}
```
两个不同的集合类，输出的结果是equals is true。因为ArrayList的equals()只进
行了是否为List子类的判断，接着调用了equalsRange()方法：
```java
boolean equalsRange(List<?> other, int from, int to)  {
    final Object[] es = elementData;
    
    // 用var变量接收linkedList的遍历器    (第1处)
    var oit = other.iterator();
    for (; from < to; from++) {
        
        // 如果linkedList没有元素，则equals结果直接为false；
        // 如果linkedList有元素，则在对应下标进行值的比较    (第2处)
        if (!oit.hasNext() || !Objects.equals(es[from]，oit.next())) {
            return false;
        }
    }
    
    // 如果arrayList已经境历完，而linkedList还有元素，则equals结果为false 
    return !oit.hasNext();
}
```
第1处说明：局部变量类型推断(Local Variable Type Inference)是JDK10引入
的变量命名机制，一改Java是强类型语言的传统形象，这是Java致力于未来体积更小、
面向生产效率的新语言特性，减少累赘的语法规则，当然这仅仅是一个语法糖，Java
仍然是一种静态语言。在初始化阶段，在处理var变量的时候，编译器会检测右侧代
码的返回类型，并将其类型用于左侧，如下所示：
```java
var a = "string";
// 输出：class java.lang.String
System.out.println(a.getClass());
var b = Integer.valueOf(7);
// 输出：class java.lang.Integer
System.out.println(b.getClass());
// 编译出错。虽然是var，但是依然存在类型限定
b = 3.0;
```
b在第一次赋值时，类型推断为Integer，所以在第二次赋值为double时编译出错。
如果一个方法内频繁地使用var，则会大大降低可读性，这是一个权衡，建议当用var
定义变量时，尽量不要超过两个

第2处说明：尽量避免通过实例对象引用来调用equals方法，否则容易抛出空
指针异常。推荐使用JDK7引入的Objects的equals方法，源码如下，可以有效地防
止在equals调用时产生NPE问题：

```java
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}
```
##### 6.7 fail-fast机制
fail-fast机制是集合世界中比较常见的错误检测机制，通常出现在遍历集合元素
的过程中。下面通过校园生活中的一个例子来体会fail-fast机制





##### 6.8 Map类集合
###### 6.8.1 红黑树





###### 6.8.2 TreeMap






###### 6.8.3 HashMap





###### 6.8.4 ConcurrentHashMap





