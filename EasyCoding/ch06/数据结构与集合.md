#### 第6章 数据结构与集合
在代码世界中，集合是对"Collection"一词的翻译，事实上这么翻译仍不够准确。
在数学世界中，集合是指具有某种特定性质的事物汇成的集体，对应英文是Set，它
具有确定性、无序性、互异性等特点。而Java中的集合表达的是数据结构的载体，
并未对应于数学概念上的集合，Java中的集合元素可以是有序的，也可以是重复的，
与数学中的要求不一样。本书中其他地方出现的集合概念，都指的是Collection，用
来保存各种各样的对象。我们经常说，“程序 = 数据结构 + 算法”。集合作为数据结
构的载体，可对元素进行加工和输出，以一定的算法实现最基本的增删改查功能，因
此集合是所有编程语言的基础

在进入高并发编程时代后，由集合引发的相关故障占比越来越高。比如，多线程
共享集合时出现的脏数据问题；某些集合在数据扩容时出现节点之间的死链问题；写
多读少的场景误用某些集合导致性能下降问题等。本章将从数组讲起，引申到集合框
架，再到重点集合源码分析，最后介绍高并发集合框架，目的是对集合的了解成竹在
胸、运用得心应手

##### 6.1 数据结构
1. 数据结构定义

数据结构是什么?网络上的一些定义十分抽象且各不相同，学习完之后，反而对
数据结构的概念更加模糊、更有敬畏之心。数据结构是指逻辑意义上的数据组织方式
及其相应的处理方式

(1) 什么是逻辑意义?数据结构的抽象表达非常丰富，而实际物理存储的方式
相对单一。比如，二叉树在磁盘中的存储真的是树形排列吗?并非如此。树的存储可
能是基于物理上的顺序存储方式，可以理解为一个格子一个格子连续地放，设想有7
个节点的二叉树，第一个格子放根节点，第二个格子放左子树根节点；并且根据引用
知道左叶子在后续的哪个格子里；第三个格子放右子树根节点，依此类推。此外，树
的存储也可能是基于物理上的链式存储方式，这里不再详细展开

(2) 什么是数据组织方式?逻辑意义上的组织方式有很多，比如树、图、队列、
哈希等。树可以是二叉树、三叉树、B+树等；图可以是有向图或无向图；队列是先
进先出的线性结构；哈希是根据某种算法直接定位的数据组织方式

(3) 什么是数据处理方式?在既定的数据组织方式上，以某种特定的算法实现
数据的增加、删除、修改、查找和遍历。不同的数据处理方式往往存在着非常大的性
能差异

2. 数据结构分类

数据结构是算法实现的基石，它是一种体现基础逻辑思维的内功心法，也是计算
机从业人员能力图谱中的重要一项。 如果完全不懂数据结构，很难写出优秀的代码。
有缺陷的底层数据结构容易导致系统风险高、可扩展性差，所以需要认真地对数据结
构进行设计和评审。从直接前继和直接后继个数的维度来看，大体可以将数据结构分
为以下四类

(1 )线性结构：0至1个直接前继和直接后继。当线性结构非空时，有唯一的
首元素和尾元素，除两者外，所有的元素都有唯一的直接前继和直接后继。线性结
构包括顺序表、链表、栈、队列等，其中栈和队列是访问受限的结构。栈是后进先
出，即Last-In，First-Out， 简称LIFO；队列是先进先出，即First-In，First-Out，简称
FIFO

(2) 树结构：0至1个直接前继和0至n个直接后继(n大于或等于2)。树是
一种非常重要的有层次的非线性数据结构，像自然界的树一样。由于树结构比较稳定
和均衡，在计算机领域中得到广泛应用

(3 )图结构：0至n个直接前继和直接后继(n大于或等于2)。图结构包括简
单图、多重图、有向图和无向图等

(4) 哈希结构：没有直接前继和直接后继。哈希结构通过某种特定的哈希函数
将索引与存储的值关联起来，它是一种查找效率非常高的数据结构

不同的数据组织方式和处理方式带来了一个新的问题：如何衡量数据处理的性
能。数据结构的复杂度分为空间复杂度和时间复杂度两种，在存储设备越来越便宜的
情况下，时间复杂度成为重点考量的因素。算法时间复杂度是一种衡量计算性能的指
标，反映了程序执行时间随输入规模增长而增长的量级，在很大程度上能够反映出算
法性能的优劣与否。而这个量级通常用大写的O和一个函数描述，如O(n^3)表示程序
执行时间随输入规模呈现三次方倍的增长，这是比较差的算法实现。从最好到最坏的
常用算法复杂度排序如下：常数级O(1)、对数级O(logn)、线性级O(n)、线性对数级
O(nlogn)、平方级O(n^2)、立方级O(n^3)、指数级O(2^n)等。有人觉得在实际编程中没
有必要去纠结算法复杂度，因为现实中的数据量有限，执行时间相差无几。但是，数
据规模并非静止不变，优秀的程序实现不会因为数据规模的急剧上升导致程序性能的
急剧下降

最后以“猜数字”为例进一步理解时间复杂度，主持人从1 ~ 100的范围内任选
一个数字，玩家随机猜一个数，如果没有猜中，主持人会提示猜大了还是猜小了，继
续这样的循环，直到猜对为止。显而易见，如果要猜测，最多要猜100次，最少只用
猜1次。经验表明，玩家总会往中间砍一段，平均猜测次数总在七八次左右。通过模
拟程序运行1亿次，完全随机的情况下，平均猜测的次数是7.47次，近似二分法猜
测的是5.8次，时间复杂度为O(logn)

##### 6.2 集合框架图
Java中的集合是用于存储对象的工具类容器，它实现了常用的数据结构，提供了
一系列公开的方法用于增加、删除、修改、查找和遍历数据，降低了日常开发成本。
集合的种类非常多，形成了一个比较经典的继承关系树，称为Java集合框架图，如图6-1
所示。框架图中主要分为两类：第一类是按照单个元素存储的Collection，在继承树
中Set和List都实现了Collection接口；第二类是按照Key-Value存储的Map。以上
两类集合体系，无论数据存取还是遍历，都存在非常大的差异

在集合框架图中，红色代表接口，蓝色代表抽象类，绿色代表并发包中的类，灰
色代表早期线程安全的类(基本已经弃用)。可以看到，与Collection相关的4条线
分别是List、Queue、Set、Map，它们的子类会映射到数据结构中的表、树、哈希等。
对集合框架图的深刻理解，有利于对集合的宏观把控，并写出更高质量的程序。此图
相当于纲举目张的“纲”，虽然部分集合没有纳入此框架图中，但是容易沿着这个图
的思路理解其他集合。下面一起学习这4个常用集合类型

###### 6.2.1 List集合
List集合是线性数据结构的主要实现，集合元素通常存在明确的上一个和下一个
元素，也存在明确的第一个元素和最后一个元素。List 集合的遍历结果是稳定的。该
体系最常用的是ArrayList和LinkedList两个集合类

ArrayList是容量可以改变的非线程安全集合。内部实现使用数组进行存储，集
合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList支持对元素
的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动
其他元素

LinkedList的本质是双向链表。与ArrayList相比，LinkedList的插入和删除速度
更快，但是随机访问速度则很慢。测试表明，对于10万条的数据，与ArrayList相比，
随机提取元素时存在数百倍的差距。除继承AbstractList抽象类外，LinkedList还实现
了另一个接口Deque，即double-endedqueue。这个接口同时具有队列和栈的性质。
LinkedList包含3个重要的成员：size、first、last。size是双向链表中节点的个数。
first和last分别指向第一个和最后一个节点的引用。LinkedList的优点在于可以将零
散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存
利用率较高

###### 6.2.2 Queue集合
Queue(队列)是一种先进先出的数据结构，队列是一种特殊的线性表， 它只允
许在表的一端进行获取操作，在表的另一端进行插入操作。当队列中没有元素时，称
为空队列。自从BlockingQueue(阻塞队列)问世以来，队列的地位得到极大的提升，
在各种高并发编程场景中，由于其本身FIFO的特性和阻塞操作的特点，经常被作为
Buffer(数据缓冲区)使用

###### 6.2.3 Map集合
Map集合是以Key-Value键值对作为存储元素实现的哈希结构，Key 按某种哈希
函数计算后是唯一的，Value则是可以重复的。Map类提供三种Collection视图，在
集合框架图中，Map指向Collection的箭头仅表示两个类之间的依赖关系。可以使用
keySet()查看所有的Key，使用values()查看所有的Value，使用entrySet() 查看所有
的键值对。最早用于存储键值对的Hashtable因为性能瓶颈已经被淘汰，而如今广泛
使用的HashMap，线程是不安全的。ConcurrentHashMap是线程安全的，在JDK8中
进行了锁的大幅度优化，体现出不错的性能。在多线程并发场景中，优先推荐使用
ConcurrentHashMap，而不是HashMap。TreeMap是Key有序的Map类集合

###### 6.2.4 Set集合
Set是不允许出现重复元素的集合类型。Set体系最常用的是HashSet、TreeSet
和LinkedHashSet三个集合类。HashSet从源码分析是使用HashMap来实现的，只是
Value固定为一个静态对象，使用Key保证集合元素的唯一性， 但它不保证集合元素
的顺序。TreeSet 也是如此，从源码分析是使用TreeMap来实现的，底层为树结构，
在添加新元素到集合中时，按照某种比较规则将其插入合适的位置，保证插入后的集
合仍然是有序的。LinkedHashSet继承自HashSet，具有HashSet的优点，内部使用链
表维护了元素插入顺序

##### 6.3 集合初始化
集合初始化通常进行分配容量、设置特定参数等相关工作。我们以使用频率较高
的ArrayList和HashMap为例，简要说明初始化的相关工作，并解释为什么在任何情
况下，都需要显式地设定集合容量的初始大小。ArrayList是存储单个元素的顺序表结
构，HashMap是存储KV键值对的哈希式结构。分析两者的初始化相关源码，洞悉它
们的容量分配、参数设定等相关逻辑，有助于更好地了解集合特性，提升代码质量。
下面先从ArrayList源码说起：
```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    private static final int DEFAULT_CAPACITY = 10;
    // 空表的表示方法
    private static final Object[] EMPTY_ELEMENTDATA = {};
    transient object[] elementData;
    private int size;
    
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            // 值大于0时，根据构造方法的参数值，忠实地创建一个多大的数组
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA; 
        }
    }
    
    // 公开的add万法调用此内部私有万法
    private void add(E e, Object[] elementData, int s) {
        // 当前数组能否容纳size+1的元素，如果不够，则调用grow来扩容
        if (s == elementData.length)
            elementData = grow();
        elementData[s] = e;
        size = s + 1 ;
    }
    
    private Object[] grow() {
        return grow(size + 1);
    }
   
    // 扩容的最小要求，必须容纳刚才的元素个数+1,注意，newCapacity()
    // 方法才是扩容的重点!
    private Object[] grow(int minCapacity) {
        return elementData = Arrays.copyOf(elementData, newCapacity(minCapacity));
    }
    
    private int newCapacity(int minCapacity) {
        // 防止扩容1.5倍之后，超过int的表示范围    (第1处)
        int oldCapacity = elementData.length;
        // JDK6之前扩容50%或50%-1，但是取ceil, 而之后的版本取floor    (第2处)
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity <= 0) {
            if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
                // 无参数构造方法，会在此时分配默认为10的容量
                return Math.max(DEFAULT_CAPACITY, minCapacity);
            if (minCapacity < 0)
                throw new OutOfMemoryError();
            return minCapacity;
        }
        return (newCapacity - MAX_ARRAY_SIZE <= 0)
            ? newCapacity
            : hugeCapacity(minCapacity);
    }
}
```
第1处说明：正数带符号右移的值肯定是正值，所以oldCapacity+(oldCapacity>>1)
的结果可能超过int可以表示的最大值，反而有可能比参数的minCapacity更小，则返
回值为(size+1) 的minCapacity

第2处说明：如果原始容量是13，当新添加一个元素时，依据程序中的计算方法，
得出13的二进制数为1101，随后右移1位操作后得到二进制数110，即十进制数6。
最终扩容的大小计算结果为oldCapacitiy + (oldCapacity>>1) = 13 + 6 = 19。使用位运
算主要是基于计算效率的考虑。在JDK7之前的公式，扩容计算方式和结果为
oldCapacitiy × 3 ÷ 2 + 1 = 13 × 3 ÷ 2 + 1 = 20

当ArrayList使用无参构造时，默认大小为10，也就是说在第一次add的时候，
分配为10的容量，后续的每次扩容都会调用Array.copyOf方法，创建新数组再复
制。可以想象，假如需要将1000个元素放置在ArrayList 中，采用默认构造方法，
则需要被动扩容13次才可以完成存储。反之，如果在初始化时便指定了容量new
ArrayList(1000)，那么在初始化ArrayList 对象的时候就直接分配1000个存储空间，
从而避免被动扩容和数组复制的额外开销。最后，进一步设想，如果这个值达到更大
量级，却没有注意初始的容量分配问题，那么无形中造成的性能损耗是非常大的，甚
至导致OOM的风险

再来看一下HashMap，如果它需要放置1000个元素，同样没有设置初始容量大小，
随着元素的不断增加，则需要被动扩容7次才可以完成存储。扩容时需要重建hash表，
非常影响性能。在HashMap中有两个比较重要的参数：Capacity和Load Factor，其
中Capacity决定了存储容量的大小，默认为16；而Load Factor决定了填充比例，
一般使用默认的0.75。基于这两个参数的乘积，HashMap内部用threshold变量表示
HashMap中能放入的元素个数。HashMap 容量并不会在new的时候分配，而是在第
一次put的时候完成创建的，源码如下：
```java
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
     // ...省略代码
}

// 第一次put时，调用如下方法，初始化table
private void inflateTable(int toSize) {
    // 找到大于参数值且最接近2的冪值，假如输入参数是27，则返回32
    int capacity = roundUpToPowerOf2(toSize);
    
    // threshold 在不超过限制最大值的前提下等于capacity * loadFactor
    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);
    table = new Entry[capacity];
    initHashSeedAsNeeded(capacity);
}
```
为了提高运算速度，设定HashMap容量大小为2^n，这样的方式使计算落槽位置
更快。如果初始化HashMap的时候通过构造器指定了initialCapacity， 则会先计算出
比initialCapacity大的2的幂存入threshold，在第一次put时会按照这个2的幂初始化
数组大小，此后每次扩容都是增加2倍。如果没有指定初始值，log<sub>2</sub>1000 = 9.96，结
合源码分析可知，如果想要容纳1000个元素，必须经过7次扩容。HashMap的扩容
还是有不小的成本的，如果提前能够预估出HashMap内要放置的元素数量，就可以
在初始化时合理设置容量大小，避免不断扩容带来的性能损耗

综上所述，集合初始化时，指定集合初始值大小。如果暂时无法确定集合大小，
那么指定相应的默认值，这也要求我们记得各种集合的默认值大小，ArrayList 大小为
10，而HashMap默认值为16。 牢记每种数据结构的默认值和初始化逻辑，也是开发
工程师基本素质的体现

##### 6.4 数组与集合
数组是一种顺序表，在各种高级语言中，它是组织和处理数据的一种常见方式，
我们可以使用索引下标进行快速定位并获取指定位置的元素。数组的下标从0开始，
但这并不符合生活常识，这源于BCPL语言，它将指针设置在0的位置，用数组下标
作为直接偏移量进行计算。为什么下标不从1开始呢?如果是这样，计算偏移量就要
使用当前下标减1的操作。加减法运算对CPU来说是一种双数运算， 在数组下标使
用频率极高的场景下，这种运算是十分耗时的。在Java体系中，数组用以存储同一
类型的对象，一旦分配内存后则无法扩容。提倡类型与中括号紧挨相连来定义数组，
因为在Java的世界里，万物皆为对象。String[]用来指代String数组对象，示例代码
如下：
```java
String[] args = {"a", "b"};
// 数组引用赋值给Object
Object obj = args;
// 使用类名String[]进行强制转化，并成功赋值，args[0]的值由a变为object
((String[]) obj)[0] = "object";
```
声明数组和赋值的方式示例代码如下：
```java
// 初始化完成，容量的大小即等于大括号内元素的个数，使用频率并不高
String[] args3 = {"a", "b"};
String[] args4 = new String[2];
args4[0] = "a";
args4[1] = "b";
```
上述源码中的args3是静态初始化，而args4是动态初始化。无论静态初始化还
是动态初始化，数组是固定容量大小的。注意在数组动态初始化时，出现了new，这
意味着需要在new String[]的方括号内填写一个整数。如果写的是负数，并不会编译
出错，但运行时会抛出异常：NegativeArraySizeException。 对于动态大小的数组，集
合提供了Vector和ArrayList两个类，前者是线程安全，性能较差，基本弃用，而后
者是线程不安全，它是使用频率最高的集合之一

数组的遍历优先推荐JDK5引进的foreach方式，即for(元素 : 数组名)的方式，
可以在不使用下标的情况下遍历数组。如果需要使用数组下标，则使用for (int i = 0;
i < array.length; i++)的方式，注意length是数组对象的一个属性，而不是方法(注：
String类是使用length()方法来获取字符串长度的)。也可以使用JDK8的函数式接
口进行遍历：
```java
Arrays.asList(args3).stream().forEach(x -> System.out.println(x));
Arrays.asList(args3).stream().forEach(System.out::println);
```
Arrays是针对数组对象进行操作的工具类，包括数组的排序、查找、对比、拷贝
等操作。尤其是排序，在多个JDK版本中在不断地进化，比如原来的归并排序改成
Timsort，明显地改善了集合的排序性能。另外，通过这个工具类也可以把数组转成集合

数组与集合都是用来存储对象的容器，前者性质单一，方便易用；后者类型
安全，功能强大，且两者之间必然有互相转换的方式。毕竟它们的性格迥异，在
转换过程中，如果不注意转换背后的实现方式，很容易产生意料之外的问题。转
换分成两种情况：数组转集合和集合转数组。在数组转集合的过程中，注意是否
使用了视图方式直接返回数组中的数据。我们以Arrays.asList()为例，它把数组转
换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出
UnsupprtedOperationException异常。示例源码如下：
```java
public class ArraysAsList {
    public static void main(String[] args) {
        String[] stringArray = new String[3] ;
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        
        List<String> stringList = Arrays.asList(stringArray);
        // 修改转换后的集合，成功地把第一个元素"one"改成"oneList"
        stringList.set(0, "oneList");
        // 运行结果是1. 数组的值随之改变
        System.out.printl(stringArray[0]);
        
        // 这是重点：以下三行编译正确，但都会抛出运行时异常
        stringList.add("four");
        stringList.remove(2);
        stringList.clear();
    }
}
```
事实证明，可以通过set()方法修改元素的值，原有数组相应位置的值
同时也会被修改，但是不能进行修改元素个数的任何操作，否则均会抛出
UnsupportedOperationException异常。ArrysasList体现的是适配器模式，后台的数据
仍是原有数组，set()方法即间接对数组进行值的修改操作。asList的返回对象是一个
Arrays的内部类，它并没有实现集合个数的相关修改方法，这也正是拋出异常的原因。
Arrays.asList的源码如下：
```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```
返回的明明是ArrayList对象，怎么就不可以随心所欲地对此集合进行修改呢?
注意此ArrayList非彼ArrayList，虽然Arrays与ArrayList同属于一个包，但是在
Arrays类中还定义了一个ArrayList的内部类(或许命名为InnerArrayList更容易识别)，
根据作用域就近原则，此处的ArrayList是李鬼，即这是个内部类。此李鬼十分简单，
只提供了个别方法的实现，如下所示：
```java
private static class ArrayList<E> extends AbstractList<E> implements RandomAccess, java. io.Serializable {
    // final修饰不准修改其引用    (第1处)
    private final E[] a;
        
    // 直接把数组引用赋值给a，而Objects是JDK7引入的工具包
    // requireNonNull仅仅判断是否为null
    ArrayList(E[] array) {
        a = Objects.requireNonNull(array);
    }
    // 实现了修改特定位置元素的方法
    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        // 注意set成功返回的是此位置上的旧值
        return oldValue;
    }
}
```
第1处的final引用，用于存储集合的数组引用始终被强制指向原有
数组。这个内部类并没有实现任何修改集合元素个数的相关方法，那这个
UnsupportedOperationException异常是从哪里抛出来的呢?是李鬼的父类
AbstractList：

```java
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }
    
    // clear()方法调用remove方法，依然抛出异常
    public void clear() {
        removeRange(0, size());
    }
}
```
如果李鬼Arrays.ArrayList内部类覆写这些方法不抛出异常，避免使用者踩进这
个坑会不会更好?数组具有不为五斗米折腰的气节，传递的信息是“ 要么直接用我，
要么小心异常!” 数组转集合引发的故障还是十分常见的。比如，某业务调用某接口时，
对方以这样的方式返回一个List类型的集合对象，本方获取集合数据时，99.9%是只
读操作，但在小概率情况下需要增加一个元素，从而引发故障。在使用数组转集合时，
需要使用李逵java.util.ArrayList直接创建一个新集合， 参数就是Arrays.asList返回的
不可变集合，源码如下：
```java
public class ListToArray {
    public static void main(String[] args) {
        List<String> list = new ArrayList<string>(3);
        list.add("one");
        list.add("two");
        list.add("three");
        
        // 泛型丢失，无法使用String[]接收无参方法返回的结果    (第1处)
        Object[] array1 = list.toArray();
        
        // array2数组长度小于元素个数    (第2处)
        String[] array2 = new String[2];
        list.toArray(array2);
        System.out.println(Arrays.asList(array2));
        
        // array2 数组长度等于元素个数    (第3处)
        String[] array3 = new String[3];
        list.toArray(array3);
        System.out.println (Arrays.asList(array3));
    }
}
```
执行结果如下：
```text
[null, null]
[one, two, three]
```
第1处比较容易理解，不要用toArray()无参方法把集合转换成数组，这样会导
致泛型丢失；在第2处执行成功后，输出却为null；第3处正常执行，成功地把集合
数据复制到array3数组中。第2处与第3处的区别在于即将复制进去的数组容量是否
足够。如果容量不够，则弃用此数组，另起炉灶，关于此方法的源码如下：
```java
// 注意入参数组的length大小是重中之重，如果大于或等于集合的大小
// 则集合中的数据复制进入数组即可，如果空间不够，入参数组a就会被无视
// 重新分配一个空间，复制完成后返回一个新的数组引用
public <t> T[] toArray(T[] a) {
    if (a.length < size) {
        // 如果数组长度小于集合size，那么执行此语句，直接return    (第1处)
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    }
    
    // 如果容量足够，则直接复制    (第2处)
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size) {
        a[size] = null;
    }
    
    // 只有在数组容量足够的情况下，才返回传入参数
    return a;
}
```
在第1处和第2处均复制java.util.ArrayList的elementData到数组中，这
个elementData是ArrayList集合对象中真正用于存储数据的数组，它的定义为：
transient Object[] elementData;

这个存储ArrayList真正数据的数组由transient修饰，表示此字段在类的序列化
时将被忽略。因为集合序列化时系统会调用writeObject写入流中，在网络客户端反
序列化的readObject时，会重新赋值到新对象的elementData中。为什么多此一举?
因为elementData容量经常会大于实际存储元素的数量，所以只需发送真正有实际值
的数组元素即可。回到刚才的场景，当入参数组容量小于集合大小时，使用Arrays.
copyOf()方法，它的源码如下：
```java
public static <t> T[] copyOf(U[] original, int newLength, Class<? extends T[]> newType) {
    // 新创建一个数组copy
    T[] copy = ((Object)newType == (Object)Object[].class)
        ? (T[]) new Object[newLength]
        : (T[]) Array.newInstance(newType.getComponentType(), newLength); 
    System.arraycopy(original, 0, copy, 0,
        Math.min(original.length, newLength));
    return copy;
}
```
我们用示例代码模拟可能出现的三种情况，分别为入参数组容量不够时、入参数
组容量刚好时，以及入参数组容量超过集合大小时，并记录其执行时间：
```java
public class ToArraySpeedTest {
    private static final int COUNT = 100 * 100 * 100;
    
    public static void main(String[] args) {
        List<Double> list = new ArrayList<>(COUNT);
        // 构造一个100万个元素的测试集合
        for (int i = 0; i < COUNT; i++) {
            list.add(i * 1.0);
        }
        
        long start = System.nanoTime();
        
        Double[] notEnoughArray = new Double[COUNT- 1];
        list.toArray(notEnoughArray);
        
        long middle1 = System.nanoTime();
        
        Double[] equalArray = new Double[COUNT];
        list.toArray(equalArray);
        
        long middle2 = System.nanoTime();
        
        Double[] doubleArray = new Double[COUNT * 2];
        list.toArray(doubleArray);
        long end = System.nanoTime();
        
        long notEnoughArrayTime = middle1 - start;
        long equalArrayTime = middle2 - middle1;
        long doubleArrayTime = end - middle2;
        
        System.out.println("数组容量小于集合大小：notEnoughArrayTime:
            + notEnoughArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量等于集合大小：equalArrayTime:
            + equalArrayTime / (1000.0 * 1000.0) + " ms");
        System.out.println("数组容量是集合的两倍：doubleArrayTime:
            + doubleArrayTime / (1000.0 * 1000.0) + " ms");
    }
}
```
执行结果如下：
```text
数组长度小于集合大小: notEnoughArrayTime: 12.317152 ms
数组长度等于集合大小: equalArrayTime: 9.327377 ms
数组长度是集合的两倍: doubleArrayTime: 13. 547622 ms
```
具体的执行时间，由于CPU资源占用的随机性，会有一定差异。多次运行结果
显示，当数组容量等于集合大小时，运行总是最快的，空间消耗也是最少的。由此
证明，如果数组初始大小设置不当，不仅会降低性能，还会浪费空间。使用集合的
toArray(T[] array)方法，转换为数组时，注意需要传入类型完全一样的数组，并且它
的容量大小为list.size()

##### 6.5 集合与泛型
泛型与集合的联合使用，可以把泛型的功能发挥到极致，很多程序员不清楚
List、List\<Object\>、List<?> 三者的区别，更加不能区分\<? extends T\>与\<? super T\>
的使用场景。List完全没有类型限制和赋值限定，如果天马行空地乱用，迟早会遭遇
类型转换失败的异常。很多程序员觉得List\<Object\>的用法完全等同于List，但在接
受其他泛型赋值时会编译出错。List<?>是一个泛型，在没有赋值之前，表示它可以
接受任何类型的集合赋值，赋值之后就不能随便往里添加元素了。下方的例子很好地
说明了三者的区别，以List为原型展开说明：

```java
public class ListNoGeneric {
    public static void main(String[] args) {
        
        // 第一段：泛型出现之前的集合定义方式
        List a1 = new ArrayList();
        a1.add(new Object());
        a1.add(new Integer(111));
        a1.add(new String("hello a1a1"));
        
        // 第二段：把a1引用赋值给a2，注意a2与a1的区别是增加了泛型限制<Object>
        List<Object> a2 = a1;
        a2.add(new Object());
        a2.add(new Integer(222));
        a2.add(new String("hello a2a2"));
        
        // 第三段：把a1引用赋值给a3，注意a3与a1的区别是增加了泛型<Integer>
        List<Integer> a3 = a1;
        a3.add(new Integer(333));
        // 下方两行编译出错，不允许增加非Integer类型进入集合
        a3.add(new Object());
        a3.add(new String("hel1o a3a3"));
        
        // 第四段：把a1引用赋值给a4，a1与a4的区别是增加了通配符
        List<?> a4 = a1;
        // 允许删除和清除元素
        a1.remove(0);
        a4.clear();
        // 编译出错。不允许增加任何元素
        a4.add (new Object());
    }
}
```
第一段说明：在定义List之后，毫不犹豫地往集合里装入三种不同的对象：
Object、Integer和String，遍历没有问题，但是贸然以为里边的元素都是Integer，使
用强制转化，则抛出ClassCastException异常

第二段说明：把a1赋值给a2，a2是List\<Object\>类型的，也可以再往里装入三
种不同的对象。很多程序员认为List和List\<Object\>是完全相同的，至少从目前这两
段来看是这样的

第三段说明：由于泛型在JDK5之后才出现，考虑到向前兼容，因此历史代码有
时需要赋值给新泛型代码，从编译器角度是允许的。这种代码似乎有点反人类，在实
际故障案例中经常出现，来看一段问题代码
```java
JSONObject jsonObject = JSONObject.fromObject("{\"level\":[\"3\"]}");
List<Integer> intList = new ArrayList<Integer>(10);

if (jsonObject != null) {
    intList.addAll(jsonObject.getJSONArray("level"));
    int amount = 0;
    for (Integer t : intList) {
        // 抛出ClassCastException异常：String cannot be cast to Integer
        if (condition) {
            amount = amount + t;
        }
    }
}
```
addAll的定义如下：
```java
public boolean addAll(Collection<? extends E> c) {...}
```
进行了泛型限制，示例中addAll的实际参数是getJSONArray返回的JSONArray
对象，它并非是List，更加不是Integer集合的子类，为何编译不报错?查看
JSONArray的定义：
```java
public final class JSONArray extends AbstractJSON implements JSON, List {}
```
JSONArray实现了List，是非泛型集合，可以赋值给任何泛型限制的集合。编译
可以通过，但在运行时报错，这是一个隐藏得比较深的Bug，最终导致发生线上故障。
在JDK5之后，应尽量使用泛型定义，以及使用类、集合、参数等

如果把a1的定义从List a1修改为List\<Object\> a1，那么第三段就会编译出错。
List\<Object\>赋值给List\<Integer\>是不允许的，若是反过来赋值：
```java
List<Integer> intList = new ArrayList<Integer>(3) ;
intList.add(111) ;
List<Object> objectList = intList;
```
事实上，依然会编译出错，提示如下：
```text
Error:(10,26)java:incompatible types: java.util.List<java.lang.Integer> cannot be converted to java.util.List<java.lang.Object)
```
注意，数组可以这样赋值，因为它是协变的，而集合不是

第四段说明：问号在正则表达式中可以匹配任何字符，List\<?\> 称为通配符集合。
它可以接受任何类型的集合引用赋值，不能添加任何元素，但可以remove和clear，
并非immutable集合。List\<?\>一般作为参数来接收外部的集合，或者返回一个不知道
具体元素类型的集合

List\<T\>最大的问题是只能放置一种类型，如果随意转换类型的话，就是“破窗
理论”，泛型就失去了类型安全的意义。如果需要放置多种受泛型约束的类型呢?
JDK的开发者顺应了民意，实现了\<? extends T\>与\<? super T\>两种语法，但是两者
的区别非常微妙。简单来说，\<? extends T\>是Get First，适用于，消费集合元素为主
的场景； \<? super T\>是Put First，适用于生产集合元素为主的场景

\<? extends T\>可以赋值给任何T及T子类的集合，上界为T，取出来的类型带有
泛型限制，向上强制转型为T。null可以表示任何类型，所以除null外，任何元素都
不得添加进\<? extends T\>集合内
\<? super T\>可以赋值给任何T及T的父类集合，下界为T。在生活中，投票选
举类\<? super T\>的操作。选举代表时，你只能往里投选票，取数据时，根本不
知道是谁的票，相当于泛型丢失。有人说，这只是一种生活场景，在系统设计中，很
难有这样的情形。再举例说明一下，我们在填写对主管的年度评价时，提交后若想再
次访问之前的链接修改评价，就会被告之：“ 您已经完成对主管的年度反馈，谢谢参
与。”extends的场景是put功能受限，而super的场景是get功能受限

下例中，以加菲猫、猫、动物为例，说明extends和super的详细语法差异：
```java
// 用动物的猫科与加菲猫的继承关系说明extends与super在集合中的意义
public class AnimalCatCarfield {
    public static void main(String[] args) {
        // 第1段：声明三个依次继承的类的集合：Object > 动物 > 猫 > 加菲猫
        List<Animal> animal = new ArrayList<Animal>();
        List<Cat> cat = new ArrayList<Cat>();
        List<Garfield> garfield = new ArrayList<Garfield>();
        
        animal.add(new Animal());
        cat.add(new Cat());
        garfield.add(new Garfield());
        
        // 第2段：测试赋值操作
        // 下行编译出错。只能赋值Cat或Cat子类的集合
        List<? extends Cat> extendsCatFromAnimal = animal;
        List<? super Cat> superCatFromAnimal = animal;
        
        List<? extends Cat> extendsCatFromCat = cat;
        List<? super Cat> superCatFromCat = cat;
        
        List<? extends Cat> extendsCatFromGarfield = garfield;
        // 下行编译出错。只能赋值Cat或Cat父类的集合
        List<? super Cat> superCatFromGarfield = garfield;
        
        // 第3段：测试add方法
        // 下面三行中所有的<? extends T>都无法进行add操作，编译均出错
        extendsCatFromCat.add(new Animal());
        extendsCatFromCat.add(new Cat());
        extendsCatFromCat.add(new Garfield());
        
        // 下行编译出错。只能添加Cat或Cat子类的集合
        superCatFromCat.add(new Animal());
        superCatFromCat.add(new Cat());
        superCatFromCat.add(new Garfield());
        
        // 第4段：测试get方法
        // 所有的super操作能够返回元素，但是泛型丢失，只能返回Object对象
        
        // 以下extends操作能够返回元素
        Object catExtends2 = extendsCatFromCat.get(0);
        Cat catExtends1 = extendsCatFromCat.get(0);
        // 下行编译出错。虽然Cat集合从Garfield賦值而来，但类型擦除后，是不知道的
        Garfield garfield1 = extendsCatFromGarfield.get(0);
    }
}
```
第1段，声明三个泛型集合，可以理解为三个不同的笼子，List\<Animal\> 住的是
动物(反正就是动物世界里的动物)，List\<Cat\> 住的是猫(反正就是猫科动物)，
List\<Garfield\>住的是加菲猫(又懒又可爱的一种猫)。Garfield继承于Cat，而Cat
继承自Animal

第2段，以Cat类为核心，因为它有父类也有子类。定义类型限定集合，分别
为List\<? extends Cat\>和List\<? super Cat\>。在理解这两个概念时，暂时不要引入上
界和下界，专注于代码本身就好。把List\<Cat\>对象赋值给两者都是可以的。但是把
List\<Animal\>赋值给List\<Cat\>时会编译出错。因为能赋值给\<? extends Cat\>的类型，
只有Cat自己和它的子类。尽管它是类型安全的，但依然有泛型信息，因而从笼子里
取出来的必然是只猫，而List\<Animal\>里边有可能住着毒蛇、鳄鱼、蝙蝠等 其他动物

把List\<Garfield\>赋值给List\<? super Cat\>时，也会编译报错。因为能赋值给
\<? superCat\>的类型，只有Cat自己和它的父类

第3段，所有的List\<? extends T\>都会编译出错，无法进行add操作，这是因为
除null外，任何元素都不能被添加进\<? extends T\>集合内。List\<? super Cat\>可以往
里增加元素，但只能添加Cat自身及子类对象，假如放入一块石头，则明显违背了
Animal大类的性质

第4段，所有List\<? super T\>集合可以执行get操作，虽然能够返回元素，但是
类型丢失，即只能返回Object对象。List\<? extends Cat\>可以返回带类型的元素，但
只能返回Cat自身及其父类对象，因为子类类型被擦除了

对于一个笼子，如果只是不断地向外取动物而不向里放的话，则属于Get First,
应采用\<? extends T\>；相反，如果经常向里放动物的话，则应\<? super T\>，属于
Put First

##### 6.6 元素的比较
###### 6.6.1 Comparable和Comparator
Java中两个对象相比较的方法通常用在元素排序中，常用的两个接口分别是
Comparable和Comparator，前者是自己和自己比，可以看作是自营性质的比较器；后
者是第三方比较器，可以看作是平台性质的比较器。从词根上分析, Comparable以-able
结尾，表示它有自身具备某种能力的性质，表明Comparable对象本身是可以与同类
型进行比较的，它的比较方法是compareTo；而Comparator以-or结尾，表示自身是
比较器的实践者，它的比较方法是compare

我们经常说的自然排序其实是以人类对常识认知的升序排序，比如数字的1、2、
3，字母的a、b、c等。我们熟知的Integer和String实现的就是Comparable的自然排序。
而我们在使用某个自定义对象时，可能需要按照自己定义的方式排序，比如在搜索列
表对象SearchResult中进行大小比较时，先根据相关度排序，然后再根据浏览数排序，
实现这样的自定义Comparable的示例代码如下：
```java
public class SearchResult implements Comparable<SearchResult> {
    int relativeRatio;
    long count;
    int recentOrders;
    
    public SearchResult(int relativeRatio, long count) {
        this.relativeRatio = relativeRatio;
        this.count = count;
    }
    
    @Override
    public int compareTo(SearchResult o) {
        // 先比较相关度
        if (this.relativeRatio != o.relativeRatio) {
            return this.relativeRatio > o.relativeRatio ? 1 : -1;
        }
        // 相关度相等时再比较浏览数
        if (this.count != o.count) {
            return this.count > o.count ? 1 : -1;
        }
        return 0;
    }
    
    public void setRecentOrders(int recentOrders) {
        this.recentOrders = recentOrders;
    }
}
```
实现Comparable时，可以加上泛型限定，在编译阶段即可发现传入的参数非
SearchResult对象，不需要在运行期进行类型检查和强制转换。如果这个排序的规则
不符合业务方的要求，那么就需要修改这个类的比较方法compareTo，然而我们都知
道开闭原则，即最好不要对自己已经交付的类进行修改。另外，如果另一个业务方也
在使用这个比较方法呢?甚至再极端一点，这个SearchResult是他人提供的类，我们
可能连源码都没有。所以，我们其实需要在外部定义比较器，即Comparator

正因为Comparator的出现，业务方可以根据需要修改排序规则。如在上面的示
例代码中，如果业务方需要在搜索时将最近订单数(recentOrders)的权重调整到相关
度与浏览数之间，则使用Comparator实现的比较器如下所示：
```java
public class SearchResultComparator implements Comparator<SearchResult> {
    @Override
    public int compare(SearchResult o1, SearchResult o2) {
        // 相关度是第一排序准则，更高者排前(避免if-else嵌套过多使用卫语句来实现)
        if (o1.relativeRatio != o2.relativeRatio) {
            return o1.relativeRatio > o2.relativeRatio ? 1 : -1;
        }
        
        // 如果相关度一样，则最近订单数多者排前
        if (o1.recentOrders != o2.recentOrders) {
            return o1.recentorders > o2.recentOrders ? 1 : -1;
        }
        
        // 如果相关度和最近订单数都一样，则浏览数多者排前
        if (o1. count != o2 . count) {
            return ol.count > o2.count ? 1 : -1;
        }
        
        return 0;
    }
}
```
在JDK中，Comparator最典型的应用是在Arrays.sort中作为比较器参数进行排序：
```java
public static <t> void sort(T[] a, Comparat\<? super T\>T> c) {
    if(c == null) {
        sort(a);
    } else {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, c);
        else
            TimSort.sort(a, 0, a.length, c, null, 0, 0);    // (第1处)
    }
}
```
红\<? super T\>语法为下限通配，也就是将泛型类型参数限制为T或T的某
个父类，直到Object。该语法只能用在形参中来限定实参调用。如果本例中不加限定，
假定sort对象是Integer，那么传入String时就会编译报错，就是充分利用了多态的向
下转型的功能

约定俗成，不管是Comparable还是Comparator，小于的情况返回-1，,等于的情
况返回0，大于的情况返回1。当然，很多代码里只是判断是否大于或小于0，如在
集合中使用比较器进行排序时，直接使用正负来判断比较的结果：
```java
result = comparator.compare(key, t.key);
if (result < 0)
    t = t.left;
else if (result > 0)
    t = t.right;
else
    return t;
```
我们再回到之前sort()方法中的TimSort算法，是归并排序(Merge Sort)与插入
排序(Insertion Sort)优化后的排序算法

首先回顾一下归并排序的原理。长度为1的数组是排序好的，有n个元素的集合
可以看成是n个长度为1的有序子集合；对有序子集合进行两两归并，并保证结果子
集合有序，最后得到n/2个长度为2的有序子集合；重复上一步骤直到所有元素归并
成一个长度为n的有序集合。在此排序过程中，主要工作都在归并处理中，如何使归
并过程更快，或者如何减少归并次数，成为优化归并排序的重点

再回顾插入排序工作的工作原理：长度为1的数组是有序的，当有了k个已排
序的元素，将第k+1个元素插入已有的k个元素中合适的位置，就会得到一个长度
为k+1已排序的数组。假设有n个元素且已经升序排列的数组，并且在数组尾端有第
n+1个元素的位置，此时如果想要添加一个新的元素并保持数组有序，根据插入排序，
可以将新元素放到第n+1个位置上，然后从后向前两两比较，如果新值较小则交换位
置，直到新元素到达正确的位置

2002年Tim Peters结合归并排序和插入排序的优点，实现了TimSort排序算
法。该算法避免了归并排序和插入排序的缺点，相对传统归并排序，减少了归并次
数，相对插入排序，引入了二分排序概念，提升了排序效率。TimSort算法对于已经
部分排序的数组，时间复杂度最优可达O(n)；对于随机排序的数组，时间复杂度为
0(nlogn)，平均时间复杂度为O(nlogn)。 因此Java在JDK7中使用TimSort算法取代
了原来的归并排序。它有两个主要优化：

(1) 归并排序的分段不再从单个元素开始，而是每次先查找当前最大的排序好
的数组片段run，然后对run进行扩展并利用二分排序，之后将该run与其他已经排
序好的run进行归并，产生排序好的大run

(2) 引入二分排序，即binarySort。二分排序是对插入排序的优化，在插入排序
中不再是从后向前逐个元素对比，而是引入了二分查找的思想，将一次查找新元素合
适位置的时间复杂度由O(m)降低到O(logn)

###### 6.6.2 hashCode和equals
hashCode和equals用来标识对象，两个方法协同工作可用来判断两个对象是否
相等。众所周知，根据生成的哈希将数据离散开来，可以使存取元素更快。对象通过
调用Object.hashCode()生成哈希值；由于不可避免地会存在哈希值冲突的情况，因此
当hashCode相同时，还需要再调用equals进行一次值的比较；但是，若hashCode不
同，将直接判定Objects不同，跳过equals，这加快了冲突处理效率。Object类定义
中对hashCode和equals要求如下：

(1 )如果两个对象的equals的结果是相等的，则两个对象的hashCode的返回结
果也必须是相同的

(2) 任何时候覆写equals,都必须同时覆写hashCode

在Map和Set类集合中，用到这两个方法时，首先判断hashCode的值，如果
hash相等，则再判断equals的结果，HashMap的get判断代码如下：

```java
if (e.hash == hash && ((k = e.key) == key || (key != null
    && key.equals(k))))
    return (e = getNode(hash(key), key)) == null ? null : e.value;
```
if条件表达式中的e.hash == hash是先决条件，只有相等才会执行阴影部分。如
果不相等，则阴影部分后边的equals根本不会被执行。equals不相等时并不强制要求
hashCode也不相等，但是一个优秀的哈希算法应尽可能地让元素均匀分布，降低冲
突概率，即在equals不相等时尽量使hashCode也不相等，这样&&或||短路操作一
旦生效，会极大地提高程序的执行效率。如果自定义对象作为Map的键，那么必须
覆写hashCode和equals。此外，因为Set存储的是不重复的对象，依据hashCode和
equals进行判断，所以Set存储的自定义对象也必须覆写这两个方法。此时如果覆写
了equals，而没有覆写hashCode，具体会有什么影响，让我们通过如下示例代码深入
体会：
```java
public class EqualsObject {
    private int id;
    private String name;
    
    public EqualsObject(int id, String name) {
        this.id = id;
        this.name = name;
    }
    
    @Override
    public boolean equals(Object obj) {
        // 如果为null，或者并非同类，则直接返回false    (第1处)
        if (obj == null || this.getClass() != obj.getClass()) {
            return false;
        }
        
        // 如果引用指向同一个对象，则返回true
        if (this == obj) {
            return true;
        }
        // 需要强制转换来获取EqualsObject的方法
        EqualsObject temp = (EqualsObject)obj;
        // 本示例判断标准是两个属性值相等，逻辑随业务场景不同而不同
        if (temp.getId() == this.id && name.equals(temp.getName())) {
            return true ;
        }
            return false;
    }
    
    // getter and setter...
}
```
第1处说明：首先判断两个对象的类型是否相同，如果不匹配，则直接返回
false。此处使用getClass的方式，就是严格限制了只有EqualsObject对象本身才可以
执行equals操作

这里并没有覆写hashCode,那么把这个对象放置到Set集合中去：
```java
Set<EqualsObject> hashSet = new HashSet<>();
EqualsObject a = new EqualsObject(1, "one");
EqualsObject b = new EqualsObject(1, "one");
EqualsObject C = new EqualsObject(1, "one");
hashSet.add(a);
hashSet.add(b);
hashSet.add(c);
System.out.println(hashSet.size());
```
输出的结果是3。虽然这些对象显而易见是相同的，但在HashSet操作中，应该
只剩下一个，为什么结果是3呢?因为如果不覆写hashCode()，即使equals()相等也
毫无意义，Object.hashCode()的实现是默认为每一个对象生成不同的int数值，它本
身是native方法，一般与对象内存地址有关。下面查看C++的源码实现：
```C++
VM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 JVMWrapper("JVM THashCode");
 return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode
      (THREAD, JNIHandles::resolve_non_null(handle));
VM_END
```
ObjectSynchronizer的核心代码如下，从代码分析角度也印证了hashCode就是根
据对象的地址进行相关计算得到int类型数值的：
```C++
mark = monitor->header();
assert(mark->is_neutral(), "invariant");
hash = mark->hash();

intptr_t hash() const {
    return mask_bits(value() >> hash_shift, hash_mask);
}
```
因为EqualsObject没有覆写hashCode，所以得到的是一个与对象地址相关
的唯一值，回到刚才的HashSet集合上，如果想存储不重复的元素，那么需要在
EqualsObject类中覆写hashCode()：

```java
@Override
public int hashCode() {
    return id + name.hashCode();
}
```
EqualsObject的name属性是String类型，String覆写了hashCode()，所以可以直
接调用。equals()的实现方式与类的具体处理逻辑有关，但又各不相同，因而应尽量
分析源码来确定其判断结果，比如下列代码：

```java
public class ListEquals {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(1);
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        arrayList.add(1);
        
        if (arrayList.equals(linkedList)) {
            System.out.println("equals is true");
        } else {
            System.out.println("equals is false");
        }
    }
}
```
两个不同的集合类，输出的结果是equals is true。因为ArrayList的equals()只进
行了是否为List子类的判断，接着调用了equalsRange()方法：
```java
boolean equalsRange(List<?> other, int from, int to)  {
    final Object[] es = elementData;
    
    // 用var变量接收linkedList的遍历器    (第1处)
    var oit = other.iterator();
    for (; from < to; from++) {
        
        // 如果linkedList没有元素，则equals结果直接为false；
        // 如果linkedList有元素，则在对应下标进行值的比较    (第2处)
        if (!oit.hasNext() || !Objects.equals(es[from]，oit.next())) {
            return false;
        }
    }
    
    // 如果arrayList已经境历完，而linkedList还有元素，则equals结果为false 
    return !oit.hasNext();
}
```
第1处说明：局部变量类型推断(Local Variable Type Inference)是JDK10引入
的变量命名机制，一改Java是强类型语言的传统形象，这是Java致力于未来体积更小、
面向生产效率的新语言特性，减少累赘的语法规则，当然这仅仅是一个语法糖，Java
仍然是一种静态语言。在初始化阶段，在处理var变量的时候，编译器会检测右侧代
码的返回类型，并将其类型用于左侧，如下所示：
```java
var a = "string";
// 输出：class java.lang.String
System.out.println(a.getClass());

var b = Integer.valueOf(7);
// 输出：class java.lang.Integer
System.out.println(b.getClass());

// 编译出错。虽然是var，但是依然存在类型限定
b = 3.0;
```
b在第一次赋值时，类型推断为Integer，所以在第二次赋值为double时编译出错。
如果一个方法内频繁地使用var，则会大大降低可读性，这是一个权衡，建议当用var
定义变量时，尽量不要超过两个

第2处说明：尽量避免通过实例对象引用来调用equals方法，否则容易抛出空
指针异常。推荐使用JDK7引入的Objects的equals方法，源码如下，可以有效地防
止在equals调用时产生NPE问题：

```java
public static boolean equals(Object a, Object b) {
    return (a == b) || (a != null && a.equals(b));
}
```
##### 6.7 fail-fast机制
fail-fast机制是集合世界中比较常见的错误检测机制，通常出现在遍历集合元素
的过程中。下面通过校园生活中的一个例子来体会fail-fast机制

上课前，班长开始点名。刚点到一半，这时从教室外三三两两进来若干同学，同
学们起哄：点错了！班长重新开始点名，点到中途，又出去几位同学，同学们又起哄说：
点错了，班长又需要重新遍历，这就是fail-fast机制。它是一种对集合(班级)遍历
操作时的错误检测机制，在遍历中途出现意料之外的修改时，通过unchecked异常暴
力地反馈出来。这种机制经常出现在多线程环境下，当前线程会维护一个计数比较
器，即expectedModCount，记录已经修改的次数。在进入遍历前，会把实时修改次数
modCount赋值给expectedModCount，如果这两个数据不相等，则抛出异常。java.util
下的所有集合类都是fail-fast，而concurrent包中的集合类都是fail-safe。与fail-fast不同，
fail-safe对于刚才点名被频繁打断的情形，相当于班长直接拿出手机快速照相，然后
根据照片点名，不再关心同学们的进进出出

人的大脑习惯用单线程方式处理日常逻辑，思维在某个时间段或某个深度上具
有方向性。多线程的运行逻辑并非自然思维。我们通过ArrayList.subList()方法进一
步阐述fail-fast这种机制。在某种情况下，需要从一个主列表master中获取子列表
branch，master集合元素个数的增加或删除，均会导致子列表的遍历、增加、删除，
进而产生fail-fast 异常。伪代码分析如下： 
```java
public class SubListFailFast {
    public static void main(String[] args) {
        List masterList = new ArrayList();
        masterList.add("one");
        masterList.add("two");
        masterList.add("three");
        masterList.add("four");
        masterList.add("five");
        
        List branchList = masterList.subList(0, 3);
        
        // 下方三行代码，如果不注释掉，则会导致branchList操作出现异常    (第1处)
        masterList.remove(0);
        masterList.add("ten");
        masterList.clear();
        
        // 下方四行全部能够正确执行
        branchList.clear();
        branchList.add("six");
        branchList.add("seven");
        branchList.remove(0);
        
        // 正常遍历结束，只有一个元素: seven
        for (Object t : branchList) {
            System.out.println(t);
        }
        
        // 子列表修改导致主列表也被改动，输出：[seven, four, five]
        System.out.println(masterList);
    }
}
```
第1处说明，如果不注释掉，masterList的任何关于元素个数的修改操作都会导
致branchList的“增删改查”抛出ConcurrentModificationException异常。在实际调研中，
大部分程序员知道subList子列表无法序列化，也知道它的修改会导致主列表的修改，
但是并不知道主列表元素个数的改动会让子列表如此敏感，频频抛出异常。在实际代
码中，这样的故障案例属于常见的类型。subList方法返回的是内部类SubList的对象，
SubList类是ArrayList的内部类，SubList的定义如下，并没有实现序列化接口，无法
网络传输：
```java
private static class SubList<E> extends AbstractList<E> implements RandomAccess {...}
```
在foreach遍历元素时，使用删除方式测试fail-fast机制，查看如下代码：
```java
public class ArrayListFailFast {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        list.add("one");
        list.add("two");
        list.add("three");
        for (String s : list) {
            if ("two".equals(s)) {
                list.remove(s);
            }
        }
        System.out.println(list);
    }
}
```
编译正确，执行成功！输出[one, thee]。说好的ConcurrentMoificationException异
常呢?这只是一个巧合而已。在集合遍历时维护一个初始值为0的游标cursor，从
头到尾地进行扫描，在cursor==size时，退出遍历。如图6-2所示，执行remove这
个元素后，所有元素往前拷贝，size=size-1 即为2，这时cursor也等于2。在执行
hasNext()时，结果为false，退出循环体，并没有机会执行到next()的第一行代码
checkForComodification()，此方法用来判断expectedModCount和modCount是否相等，
如果不相等，则抛出ConcurrentModificationException异常

这个案例应引起对删除元素时的fail-fast的警觉。我们可以使用Iterator机制进行
遍历时的删除，如果是多线程并发，还需要在Iterator遍历时加锁，如下源码：
```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    synchronized(对象) {
        String item = iterator.next();
        if (删除元素的条件) {
        iterator.remove();
    }
}
```
或者使用并发容器CopyOnWriteArrayList代替ArrayList，该容器内部会对
Iterator进行加锁操作。顺便简单介绍一个COW(奶牛)家族，即Copy-On-Write。
它是并发的一种新思路，实行读写分离，如果是写操作，则复制一个新集合，在新集
合内添加或删除元素。待一切修改完成之后，再将原集合的引用指向新的集合。这样
做的好处是可以高并发地对COW进行读和遍历操作，而不需要加锁，因为当前集合
不会添加任何元素。使用COW时应注意两点：第一，尽量设置合理的容量初始值，
它扩容的代价比较大；第二，使用批量添加或删除方法，如addAll或removeAll操作,
在高并发请求下，可以攒一下要添加或者删除的元素，避免增加一个元素复制整个集
合。如果集合数据是100MB，再写入50MB，那么某个时间段内占用的内存就达到
(100MBx2) + 50MB = 250MB，内存的大量占用会导致GC的频繁发生，从而降低
服务器的性能，我们观察如下代码：

```java
public static void main(String[] args) {
    List<Long> copy = new CopyOnWriteArrayList<Long>();
    
    long start = System.nanoTime();
    for(int i = 0; i < 20 * 10000; i++) {
        copy.add(System.nanoTime());
    }
```
循环20万次，不断地进行数据插入，这对COW类型的集合来说简直是灾难性
的操作，本示例执行时间为97.8秒，如果换成ArrayList，则只需39毫秒，差距巨
大！要初始化这样的COW集合，建议先将数据填充到ArrayList集合中去，然后把
ArrayList集合当成COW的参数，这就是使用批量添加的另一种方式。这种一个接一
个往里增加元素的场景，简直就是COW的阿喀琉斯之踵。所以明显COW适用于读
多写极少的场景

COW是fail-safe机制的，在并发包的集合中都是由这种机制实现的，fail-safe是
在安全的副本(或者没有修改操作的正本)上进行遍历，集合修改与副本的遍历是没
有任何关系的，但是缺点也很明显，就是读取不到最新的数据。这也是CAP理论中
C(Consistency)与A(Availabilty)的矛盾，即一致性与可用性的矛盾

##### 6.8 Map类集合

在数据元素的存储、查找、修改和遍历中，Java中的Map类集合都与Collection
类集合存在很大不同。它是与Collection类平级的一个接口，在集合框架图上，它有
一条微弱的依赖线与Collection类产生关联，那是因为部分方法返回Collection视图，
比如values()方法返回的所有Value的列表。Map类集合中的存储单位是KV键值对，
Map类就是使用一定的哈希算法形成一组比较均匀的哈希值作为Key，Value值挂在
Key上。Map类的特点如下：

- Map类取代了旧的抽象类Dictionary，拥有更好的性能
- 没有重复的Key，可以有多个重复的Value
- Value可以是List、Map、Set类对象
- KV是否允许为null，以实现类约束为准

Map接口除提供传统的增删改查方式外，还有三个Map类特有的方法，即返回
所有的Key，返回所有的Value，返回所有的KV键值对。源码加注释如下：
```java
// 返回Map类对象中的Key的Set视图
Set<K> keySet();

// 返回Map类对象中的所有Value集合的Collection视图
// 返回的集合实现类为Values extends AbstractCollection<V>
Collection<V> values();
// 返回Map类对象中的Key-Value对的Set视图
Set<Map.Entry<K, V>> entrySet();
```
通常这些返回的视图是支持清除操作的，但是修改和增加元素会抛出异常，因为
AbstractCollection没有实现add操作，但是实现了remove、clear等相关操作。所以
在使用这些视图返回集合时，注意不要操作此类相关方法。是否将KV设置为null，
以实现类约束为准，这是一个十分难以记忆的知识点，如表6-1所示

从1.0→1.2→1.5，这几个重点的KV集合类见证了Java语言成为工业级语言
的成长历程。从线程安全到线程不安全，再到线程安全，经历了否定之否定的过程，
不断走向成熟。在大多数情况下，直接使用ConcurrentHashMap替代HashMap没有
任何问题，在性能上区别并不大，而且更加安全。抽样调查发现，近八成的程序员认
为ConcurrentHashMap可以置入null值，毕竟它与HashMap是近亲，而HashMap的
KV都可以为null。比如，在某次配置xml时，如果只是把Key复制过来，没有做相
关的null判断就置入ConcurrentHashMap，就会导致NPE异常，但是子线程的异常并
不会抛给主线程，所以排查颇费周折。在任何Map类集合中，都要尽量避免KV设
置为null值

###### 6.8.1 红黑树
1. 树(Tree)

树是一种常用的数据结构，它是一个由有限节点(本书统称为节点，而不是结点)
组成的一个具有层次关系的集合，数据就存在树的这些节点中。最顶层只有一个节点，
称为根节点，类似于图6-3中在悬崖边上倒着生长的树，root是根节点。在分支处有
一个节点，指向多个方向，如果某节点下方没有任何分叉的话，就是叶子节点。从某
节点出发，到叶子节点为止，最长简单路径上边的条数，称为该节点的高度；从根节
点出发，到某节点边的条数，称为该节点的深度。如图6-3所示的树，根节点root的
高度是5，深度是0；而节点2的高度是4，深度是1。树结构的特点如下：

(1) 一个节点，即只有根节点，也可以是一棵树

(2) 其中任何一个节点与下面所有节点构成的树称为子树

(3) 根节点没有父节点，而叶子节点没有子节点

(4) 除根节点外，任何节点有且仅有一个父节点

(5) 任何节点可以有0 ~ n个子节点

至多有两个子节点的树称为二叉树，图6-3所示的恰好是二叉树。二分法是经典
的问题拆解算法，二叉树是近似于二分法的一种数据结构实现，二叉树是高效算法实
现的载体，在整个数据结构领域具有举足轻重的地位。在二叉树的世界中，最为重要
的概念是平衡二叉树、二叉查找树、红黑树

2. 平衡二叉树

如果把图6-3中的左侧枝叶全部砍掉的话，那么剩余的部分还是树吗?是的，但
只是以“树” 之名，行“链表”之实，如图6-4 (a)所示。如果以树的复杂结构来实
现简单的链表功能，则完全埋没了树的特点。看来对于树的使用，需要进行某种条件
的约束，如图6-4(b)所示，让链表一样的树变得更有层次结构，平衡二叉树就呼之
欲出了。图6-4(b)的高度差为5，而右侧树由9与8组成的递归右子树的，高度差为1，
高度差是一棵树是否为平衡二叉树的决定条件

平衡二叉树的性质如下：

(1) 树的左右高度差不能超过1

(2) 任何往下递归的左子树与右子树，必须符合第一条性质

(3) 没有任何节点的空树或只有根节点的树也是平衡二叉树

图6-4(a)明显不符合第一条标准，因此它不是平衡二叉树，而图6-4 (b)为
平衡二叉树

3. 二叉查找树

二叉查找树又称二叉搜索树，即Binary Search Tree，其中Search也可以替换为
Sort，所以也称为二叉排序树。Java中集合的最终目的就是加工数据，二叉查找树也
是如此。树如其名，二叉查找树非常擅长数据查找。二叉查找树额外增加了如下要求：
对于任意节点来说，它的左子树上所有节点的值都小于它，而它的右子树上所有节点
的值都大于它。查找过程从树的根节点开始，沿着简单的判断向下走，小于节点值的
往左边走，大于节点值的往右边走，直到找到目标数据或者到达叶子节点还未找到

遍历所有节点的常用方式有三种：前序遍历、中序遍历、后序遍历。它们三者的
规律如下：

(1) 在任何递归子树中，左节点一定在右节点之前先遍历

(2) 前序、中序、后序，仅指根节点在遍历时的位置顺序

前序遍历的顺序是根节点、左节点、右节点；中序遍历的顺序是左节点、根节点、
右节点；而后序遍历的顺序则是左节点、右节点、根节点

如图6-5所示，按中序遍历图中二叉查找树，坐标轴的顺序就是中序遍历

根据二叉查找树的性质要求，下面来“美化”一下本节最开始的那两棵树，使它
们成长为二叉查找树

图6-6(a)的红色节点8与节点9进行互换，节点9成为节点8的右子树，形成图6-6
(b)；图6-6(c)的红色节点8移动到左子树上，把紫色的节点2与节点4互换一下，
形成图6-6(d)。经过调整后，再查看任何递归子树，都是符合二叉查找树的要求，
所以两棵新树都为二叉查找树。但明显右下方这棵新树要优于右上方那棵，因为更加
平衡，查找效率更高。可以看出，二叉查找树容易构造，但是如果缺少约束条件，很
可能往一个方向野蛮生长，成为查找复杂度为O(n)的树。所以二叉查找树需要引入一
种检测机制，随着新值的插入动态地调整树结构。那如何调整呢?下文中的红黑树就
是来回答这个疑问的

二叉查找树由于随着数据不断地增加或删除容易失衡，为了保持二叉树重要的平
衡性，有很多算法的实现，如AVL树、红黑树、SBT(Size Balanced Tree)、Treap(树堆)等。
考虑到在Java底层框架很多算法实现以红黑树为基础，所以先简单介绍一下AVL树，
然后重点介绍红黑树

4. AVL树

AVL树算法是以苏联数学家Adelson-Velsky和Landis名字命名的平衡二叉树算
法，可以使二叉树的使用效率最大化。AVL 树是一种平衡二叉查找树，增加和删除节
点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点
的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转；同理，左旋是
以某个节点为中心，将它沉入当前左子节点的位置，而让当前右子节点作为新树的根
节点，也称为逆时针旋转

AVL树就是通过不断旋转来达到树平衡的，下方的左旋和右旋只是旋转操作层
面的简单示意图，我们应体会如何通过旋转达到一种新的平衡状态，不再基于插入和
删除进行展开，右旋示意图如图6-7所示

图6-7所示左侧是非平衡状态，需要进行平衡化处理，根节点的左子树与右子树
高度差超过1，向右旋转。在旋转过程中，节点15成为新的根节点，而节点16移动
到节点17的左节点上。而左旋转则反之，如图6-8所示

5. 红黑树

红黑树是于1972年发明的，当时称为对称二叉B树，1978年得到优化，正式命
名为红黑树。它的主要特征是在每个节点上增加一个属性来表示节点的颜色，可以是
红色，也可以是黑色

红黑树和AVL树类似，都是在进行插入和删除元素时，通过特定的旋转来保持
自身平衡的，从而获得较高的查找性能。与AVL树相比，红黑树并不追求所有递归
子树的高度差不超过1，而是保证从根节点到叶子节点的最长路径不超过最短路径的
2倍，所以它的最坏运行时间也是O(logn)。红黑树通过重新着色和左右旋转，更加
高效地完成了插入和删除操作后的自平衡调整。当然，红黑树在本质上还是二叉查找
树，它额外引入了5个约束条件：

(1) 节点只能是红色或黑色

(2) 根节点必须是黑色

(3) 所有NIL节点都是黑色的。NIL，即叶子节点下挂的两个虚节点

(4) 一条路径上不能出现相邻的两个红色节点

(5) 在任何递归子树内，根节点到叶子节点的所有路径上包含相同数目的黑色
节点

总结一下，即“有红必有黑，红红不相连”，上述5个约束条件保证了红黑树的新增、
删除、查找的最坏时间复杂度均为O(logn)。如果一个树的左子节点或右子节点不存在，
则均认定为黑色。红黑树的任何旋转在3次之内均可完成，红黑树的演进示意图在分
析完TreeMap的核心源码后，会呈现给大家，耐心往下看

6. 红黑树与AVL树的比较

先从复杂度分析说起，任意节点的黑深度(Black Depth)是指当前节点到NIL(树
尾端)途径的黑色节点个数。根据约束条件的第(4)、(5)条，可以推出对于任意
高度的节点，它的黑深度都满足：Black Depth ≥ height / 2。也就是说，对于任意包
含n个节点的红黑树而言，它的根节点高度h ≤ 2log<sub>2</sub>(n+1)。常规BST操作比如查找、
插入、删除等，时间复杂度为O(h)，即取决于树的高度h。当树失衡时，时间复杂度
将有可能恶化到O(n)，即h=n。所以，当我们能保证树的高度始终保持在O(logn)时，
便能保证所有操作的时间复杂度都能保持在O(logn)以内

红黑树的平衡性并不如AVL树，它维持的只是一种大致上的平衡，并不严格保
证左右子树的高度差不超过1。这导致在相同节点数的情况下，红黑树的高度可能
更高，也就是说，平均查找次数会高于相同情况下的AVL树。在插入时，红黑树和
AVL树都能在至多两次旋转内恢复平衡。在删除时，由于红黑树只追求大致上的平
衡，因此红黑树能在至多三次旋转内恢复平衡，而追求绝对平衡的AVL树，则至多
需要O(logn)次旋转。AVL树在插入与删除时，将向上回溯确定是否需要旋转，这
个回溯的时间成本最差可能为O(logn)，而红黑树每次向上回溯的步长为2，回溯成
本降低。因此，面对频繁的插入和删除，红黑树更为合适；面对低频修改、大量查询
时，AVL树将更为合适。为了更形象地理解红黑树的“大致平衡”，我们对红黑树
与AVL树同时进行以下操作，按顺序依次插入36、34、37、33、35、32。此时，红
黑树与AVL树结构的区别如图6-9所示

我们可以直观地感受到左侧AVL树的绝对平衡，以及右侧红黑树的相对平衡，
至于红黑树为什么呈现成这个样子，将在下节详细分析

###### 6.8.2 TreeMap
TreeMap是按照Key的排序结果来组织内部结构的Map类集合，它改变了
Map类散乱无序的形象。虽然TreeMap没有ConcurrentHashMap和HashMap普及
(毕竟插入和删除的效率远没有后两者高)，但是在Key有排序要求的场景下，使
用TreeMap可以事半功倍。在集合框架图中，它们都继承于AbstractMap抽象类，
TreeMap与HashMap、ConcurrentHashMap的类关系如图6-10所示

在TreeMap的接口继承树中有两个与众不同的接口：SortedMap和NavigableMap。
SortedMap接口表示它的Key是有序不可重复的，支持获取头尾Key-Value元素，或
者根据Key指定范围获取子集合等。插入的Key必须实现Comparable或提供额外的
比较器Comparator，所以Key不允许为nul，但是Value可以；NavigableMap接口
继承了SortedMap接口，根据指定的搜索条件返回最匹配的Key-Value元素。不同于
HashMap，TreeMap并非一定要覆写hashCode和equals方法来达到Key去重的目的
```java
public class TreeMapRepeat {
    public static void main(String[] args) {
        // 如果仅把此处的TreeMap换成HashMap，则size = 1
        TreeMap map = new TreeMap();
        map.put(new Key(), "value one");
        map.put(new Key(), "value two");
        // TreeMap，size=2，因为Key去重规则是根据排序结果
        System.out.println(map.size());
    }
}

class Key implements Comparable<Key> {
    @Override
    // 返回负的常数，表示此对象永远小于输入的other对象，此处决定TreeMap的size=2
    public int compareTo(Key other) {
        return -1;
    }
    
    // hash是相等的
    @Override
    public int hashCode() {
        return 1;
    }
    
    // equals比较也是相等的
    @Override
    public boolean equals(Object obj) {
        return true;
    }
}
```
上述示例把红色的TreeMap换成HashMap，size的结果则从2变为1。注意
HashMap是使用hashCode和equals实现去重的。而TreeMap依靠Comparable或
Comparator来实现Key的去重。这个信息非常重要，因为如果没有覆盖正确的方
法，那么TreeMap的最大特性将无法发挥出来，甚至在运行时会出现异常。如果要用
TreeMap对Key进行排序，调用如下方法：

```java
final int compare(Object k1, Object k2) {
    return comparator == null
        ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
```
如果comparator不为null, 优先使用比较器comparator的compare方法;如果为
null,则使用Key实现的自然排序Comparable接口的compareTo方法。如果两者都无
法满足，则抛出异常：
```text
Exception in thread "main" java.lang.ClassCastException: Key cannot be cast to java.base/java.lang.Comparable at java.base/java.util.TreeMap.compare(TreeMap.java:1291)
```
基于红黑树实现的TreeMap提供了平均和最坏复杂度均为O(logn)的增删改查操
作，并且实现了NavigableMap接口，该集合最大的特点是Key的有序性。先从类名
和属性开始分析：

```java
public class TreeMap<K,V> extends AbstractMap<K,V> implements NavigableMap<K,V>, Cloneable, java.io.Serializable {
    // 排序使用的比较器，put源码解析时会提到
    private final Comparator<? super K> comparator;
    // 根节点，put源码解析时会提到
    private transient Entry<K,V> root;
    // 定义成为有字面含义的常量。下方fixAfterInsertion()解析时会提到
    private static final boolean RED = false;
    private static final boolean BLACK = true;
    // TreeMap的内部类，存储红黑树节点的载体类，在整个TreeMap中高频出现
    static final class Entry<K,V> implements Map.Entry<K,V> {
        K key;
        V value;
        Entry<K,V> left;      // 指向左子树的引用
        Entry<K,V> right;     // 指向右子树的引用
        Entry<K,V> parent;    // 指向父节点的引用
        // 节点颜色信息是红黑树的精髓所在，默认是黑色
        boolean color = BLACK;
    }
    // ...
}
```
TreeMap通过put()和deleteEntry()实现红黑树的增加和删除节点操作，下面的
源码分析以插入主流程为例，删除操作的主体流程与插入操作基本类似，不再展开。
在插入新节点之前，需要明确三个前提条件：

(1) 需要调整的新节点总是红色的

(2) 如果插入新节点的父节点是黑色的，无须调整。因为依然能符合红黑树的
5个约束条件

(3) 如果插入新节点的父节点是红色的，因为红黑树规定不能出现相邻的两个
红色节点，所以进入循环判断，或重新着色，或左右旋转，最终达到红黑树的五个约
束条件，退出条件如下：
```java
while (x != null && x != root && x.parent.color == RED) {...}
```
如果是根节点，则直接退出，设置为黑色即可；如果不是根节点，并且父节点为
红色，会一直进行调整，直到退出循环

TreeMap的插入操作就是按Key的对比往下遍历，大于比较节点值的向右走，小
于比较节点值的向左走，先按照二叉查找树的特性进行操作，无须关心节点颜色与树
的平衡，后续会重新着色和旋转，保持红黑树的特性。put 的源码分析如下：

```java
public V put(K key, V value) {
    // t表示当前节点，记住这个很重要！先把TreeMap的根节点root引用赋值给当前节点
    Entry<K,V> t = root;
    // 如果当前节点为null，即是空树，新增的KV形成的节点就是根节点
    if (t == nul1) {
        // 看似多此一举，实际上预检了Key是否可以比较
        compare(key, key);
        // 使用KV构造出新的Entry对象，其中第三个参数是parent，根节点没有父节点
        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    // cmp用来接收比较结果
    int cmp;
    Entry<K, V> parent;
    // 构造方法中置入的外部比较器
    Comparator<? super K> cpr = comparator;
    // 重点步骤：根据二叉查找树的特性，找到新节点插入的合适位置
    if (cpr != null) {
        // 循环的目标：根据参数Key与当前节点的Key不断地进行对比
        do {
            // 当前节点赋值给父节点，故从根节点开始遍历比较
            parent = t;
            // 比较输入的参数Key和当前节点Key的大小
            cmp = cpr.compare(key, t.key);
            // 参数的Key更小，向左边走，把当前节点引用移动至它的左子节点上
            if (cmp < 0)
                t = t.left;
            // 参数的Key更大，向右边走，把当前节点引用移动至它的右子节点上
            else if (cmp > 0)
                t = t.right;
            // 如果相等，则会残忍地覆盖当前节点的Value值，并返回更新前的值
            else
                return t.setValue(value);
            // 如果没有相等的Key,一直会遍历到NIL节点为止
        } while (t != null);
    }
    // 在没有指定比较器的情况下，调用自然排序的Comparable比较
    else {
        if (key == null)
            throw new NullPointerException();
        Comparable<? super K> k = (Comparable<? super K>)key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue (value);
        } while (t != null);
    }
    
    // 创建Entry对象，并把parent置入参数
    Entry<K,V> e = new Entry<>(key, value, parent);
    // 新节点找到自己的位置，原本以为可以安顿下来
    if (cmp < 0)
        // 如果比较结果小于0，则成为parent的左孩子
        parent.left = e;
    else
        // 如果比较结果大于0，则成为parent的右孩子
        parent.right = e;
    // 还需要对这个新节点进行重新着色和旋转操作，以达到平衡
    fixAfterInsertion(e);
    // 终于融入其中
    size++;
    modCount++;
    // 成功插入新节点后，返回为null
    return null;
}
```
如果一个新节点在插入时能够运行到fixAfterInsertion()进行着色和旋转，说
明：第一，新节点加入之前是非空；第二，新节点的Key与任何节点都不相同。
fixAfterInsertion()是插入节点后的动作，和删除节点操作中的fixAfterDeletion()的原
理基本相同，本节重点以新增节点为例讲解fixAfterInsertion()源码
```java
private void fixAfterInsertion(Entry<K,V> x) {
    // 虽然内部类Entry的属性color默认为黑色，但新节点一律先赋值为红色
    x.color = RED;
    
    // 新节点是根节点或者其父节点(简称为父亲)为黑色
    // 插入红色节点并不会破坏红黑树的性质，无须调整
    // x值的改变已用红色高亮显示，改变的过程是在不断地向上游遍历(或内部调整)
    // 直到父亲为黑色，或者到达根节点
    while (x != null && x != root && x.parent.color == RED) {
        // 如果父亲是其父节点(简称为爷爷)的左子节点
        if (parentOf(x) == leftof(parentOf(parentOf(x)))) {
            // 这时，得看爷爷的右子节点(简称为右叔)的脸色
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            // 如果右叔是红色，此时通过局部颜色调整，就可以使子树继续满足红黑树的性质
            if (colorOf(y) == RED) {        // (第1处)
                // 父亲置为黑色
                setColor(parentOf(x), BLACK);
                // 右叔置为黑色
                setColor(y, BLACK);
                // 爷爷置为红色
                setColor(parentOf(parentOf(x)), RED);
                // 爷爷成为新的节点，进入到下一轮循环
                x = parentOf(parentOf(x));
            // 如果右叔是黑色，则需要加入旋转
            } else {
                // 如果x是父亲的右子节点，先对父亲做一次左旋转操作
                // 转化x是父亲的左子节点的情形
                if (x == rightOf(parentOf(x))) {
                    // 对父亲做一次左旋转操作，红色的父亲会沉入其左侧位置
                    // 将父亲赋值给x
                    x = parentOf(x);
                    rotateLeft(x);
                }
                // 重新着色并对爷爷进行右旋操作
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        // 与上方阴影代码相反，如果父亲是爷爷的右子节点
        } else {
            // 则看左叔的脸色，原理相同
            ...
        }
    }
    root.color = BLACK;
}
```
在上方源码中，第1处出现的colorOf()方法返回节点颜色。调整后的根节点必
然是黑色的；叶子节点可能是黑色的，也可能是红色的；叶子节点下挂的两个虚节点
即NIL节点必然是黑色的，下方源码中的p==null时，返回为BLACK。这些都是红
黑树的重要性质
```java
private static <K,V> boolean colorOf(Entry<K,V> p) {
    return (p == null ? BLACK : p.color);
}
```
左旋和右旋的代码基本类似，这里仅讲解左旋代码。请结合之前的旋转示例图，
输入参数为失去平衡的那棵子树的根节点
```java
private void rotateLeft(Entry<K,V> p) {
    // 如果参数节点不是NIL节点
    if (p != null) {
        // 获取p的右子节点r
        Entry<K,V> r = p.right;
        // 将上的左子树设置为p的右子树
        p.right = r.left;
        
        // 若r的左子树不为空，则将p设置为工左子树的父亲
        if (r.left != null)
            r.left.parent = p;
        // 将p的父亲设置工的父亲
        r.parent = p.parent;
        
        // 无论如何，r都要在p父亲心目中替代p的位置
        if (p.parent == null)
            root = r;
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        // 将p设置为上的左子树，将工设置为p的父亲
        r.left = p;
        p.parent = r;
    }
}
```
初步学完TreeMap构造方法、插入、着色、旋转的相关源码之后，举一个简单
的例子进一步体会红黑树的平衡策略。构造一个自然排序的TreeMap对象，插入、删
除数据的示例代码如下

```java
TreeMap<Integer, String> treeMap = new TreeMap<Integer, String>();
treeMap.put(55, "fifty-five");
treeMap.put(56, "fifty-six");
treeMap.put(57, "fifty-seven");
treeMap.put (58, "fifty-eight");
treeMap.put(83, "eighty-three");
treeMap.remove(57);
treeMap.put(59, "fifty-nine");
```
为什么在58和59之间插入83和删除57呢?是因为需要构造这样的场景：旋转
两次(先右旋，再左旋)

第一步，如图6-11所示，先分析55、56、57 三个数的插入操作。图中的55在
插入时是空树，它就是根节点，根据红黑树约束条件，根节点必须是黑色的，将节点
55涂黑。继续插入节点56与节点57，新节点的颜色设置为红色。当插入56时，由
于父亲是黑色节点，不做任何调整；当插入57时，由于父节点56是红色的，出现两
个连续红色节点，需要重新着色，并且旋转。完成之后如图6-11(e)所示

第二步，如图6-12所示，再分析节点58的插入操作。父亲57是爷爷56的右节
点，左叔55为红色。这时把父亲和左叔同时涂黑，把爷爷56设置为红色。因为爷爷
56是根节点，退出循环，最后一句代码是root.color=BLACK，重新把56涂黑。完成
之后如图6-12(c)所示

第三步，如图6-13所示，再分析节点83的插入操作。根据自然排序结果，从
根节点56开始比较，比56大、比57大、比58大，所以放置在58的右子节点上。
在重新调整平衡时，父亲58是爷爷57的右子节点，左叔不存在，认为是黑色NIL。
这时把父亲颜色涂黑，把爷爷设置为红色。此时，爷爷57为失去平衡的那棵小树
(57/58/83)的根节点，将它作为输入参数，进行左旋操作。完成之后如图6-13(c)
所示

第四步，删除57。因为节点57没有任何子节点，也非根节点，本身又是红色，
不影响红黑树性质，直接删除即可

第五步，如图6-14所示，删除57之后，再分析59的插入操作。根据自然排序结果，
从根节点56开始比较，比56大、比58大、比83小，放置在83的左子节点上。对
于59，只有满足如下条件，才会进入右旋转操作：

- 父亲是爷爷的右子节点
- 当前节点是父亲的左子节点
- 左叔是黑色的(删除57的原因所在)

右旋之后，把59涂黑，把58置为红色，然后以58为输入参数，进入左旋操作，
完成之后如图6-14(d)所示

在树的演化过程中，插入节点的过程中，如果需要重新着色或旋转，存在三种情
形，如图6-12和图6-14所示：

(1) 节点的父亲是红色，叔叔是红色的，则重新着色

(2) 节点的父亲是红色，叔叔是黑色的，而新节点是父亲的左节点：进行右旋

(3) 节点的父亲是红色，叔叔是黑色的，而新节点是父亲的右节点：进行左旋

如图6-14所示，在旋转时，箭头方向的引出端均为红色。插入55、56、58，删
除57均并没有引起树的旋转调整。红黑树相比AVL树，任何不平衡都能在3次旋转
之内调整完成。每次向上回溯的步长是2，对于频繁插入和删除的场景，红黑树的优
势是非常明显的

总体来说，TreeMap的时间复杂度比HashMap要高一些，但是合理利用好
TreeMap集合的有序性和稳定性，以及支持范围查找的特性，往往在数据排序的场景
中特别高效。另外，TreeMap是线程不安全的集合，不能在多线程之间进行共享数据
的写操作。在多线程进行写操作时，需要添加互斥机制，或者把对象放在Collections.
synchroinzedMap(treeMap)中实现同步

在JDK7之后的HashMap、TreeSet、ConcurrentHashMap，也使用红黑树的方式
管理节点。如果只是对单个元素进行排序，使用TreeSet即可。TreeSet底层其实就是
TreeMap，Value共享使用一个静态Object对象，如下源码所示：

```java
private static final Object PRESENT = new Object();
public boolean add(E e) {
    return treeMap.put(e, PRESENT) == null;
}
```

###### 6.8.3 HashMap





###### 6.8.4 ConcurrentHashMap





