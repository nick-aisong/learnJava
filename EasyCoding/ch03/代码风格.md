#### 第3章 代码风格
在美剧《硅谷》中有这样一个经典镜头，主人公Richard与同为开发工程师的女
友闹分手，理由是两人对缩进方式有着截然不同的编程习惯，互相鄙视对方的代码风
格。Richard 认为"one tab saves four spaces"，缩进使用Tab键操作更快，更节省存
储空间；而女友坚持使用空格缩进，连续四次敲击空格的声音，把Richard折磨到几
近崩溃，认为这是一种精神折磨。Richard 觉得难以相处，吵完架下楼梯时，不小心
摔倒了，还淡定地说，“I just tried to go down the stairs four steps at a time”( 这只是
表达我的立场而已)。Tab键和空格键的争议在现实编程中确实存在。除此之外，在
其他代码风格上，也存在不同的处理方式，往往是谁也说服不了谁，都站在自身“完
全正确”的立场上，试图说服对方。这在团队开发效率上，往往是一个巨大的内耗，
无休止的争论与最后的收益是成反比的。所以，我们认为一致性很重要，就像交通规
则一样，我国规定靠右行驶，有些国家则规定靠左行驶，并没有绝对的优劣之分，但
是在同一个国家或地区内必须要有统一的标准。 代码风格也是如此，无论选择哪一种
处理方式，都需要部分人牺牲小我，成就大我，切实提升团队的研发效能

代码风格并不影响程序运行，没有潜在的故障风险，通常与数据结构、逻辑表达
无关，是指不可见字符的展示方式、代码元素的命名方式和代码注释风格等。比如，
大括号是否换行、缩进方式、常量与变量的命名方式、注释是否统一放置在代码上方
等。代码风格的主要诉求是清爽统一、 便于阅读和维护。统-的代码风格可以让开发
工程师们没有严重的代码心理壁垒，每个人都可以轻松地阅读并快速理解代码逻辑，
便于高效协作，逐步形成团队的代码“味道”

##### 3.1 命名规约
代码元素包括类、方法、参数、常量、变量等程序中的各种要素。合适的命名，
可以体现出元素的特征、职责，以及元素之间的差异性和协同性。为了统一代码风格，
元素的命名要遵守以下约定

1. 命名符合本语言特性

当前主流的编程语言有50种左右，分为两大阵营一面向对象与面向过程，但
是按变量定义和赋值的要求，分为强类型语言和弱类型语言。每种语言都有自己的独
特命名风格，有些语言在定义时提倡以前缀来区分局部变量、全局变量、控件类型。
比如li_count表示local int局部整型变量，dw_report表示data window用于展示报表
数据的控件。有些语言规定以下画线为前缀来进行命名。这些语言的命名风格，自成
一派，也无可厚非，但是在同一种语言中，如果使用多种语言的命名风格，就会引起.
其他开发工程师的反感。比如，在Java中，所有代码元素的命名均不能以下画线或
美元符号开始或结束

2. 命名体现代码元素特征

命名上可体现出代码元素的特征，仅从名字上即可知道代码元素的属性是什么，
有利于快速厘清代码脉络。面向对象代码元素的命名形式分为两大类，即首字母大写
的UpperCamelCase和首字母小写的lowerCamelCase，前者俗称大驼峰，后者俗称小
驼峰。类名采用大驼峰形式，一般为名词，例如Object、StringBuffer、 FileInputStream等。
方法名采用小驼峰形式，一般为动词，与参数组成动宾结构，例如Object的wait()、
StringBuffer的append(String)、FileInputStream的read()等。变量包括参数、成员变量、
局部变量等，也采用小驼峰形式。常量的命名方式比较特殊，字母全部大写，单词之
间用下画线连接。常量和变量是最基本的代码元素，就像血液中的红细胞一样无处不
在。合理的命名，有利于保障代码机体的清爽、健康

在命名时若能体现出元素的特征，则有助于快速识别命名对象的作用，有助于快
速理解程序逻辑。我们推荐在Java命名时，以下列方式体现元素特征：

- 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名
统一使用单数形式，但是类名如果有复数含义，则可以使用复数形式

- 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测
试类命名以它要测试的类名开始，以Test结尾

- 类型与中括号紧挨相连来定义数组

- 枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下画线隔开

3. 命名最好望文知义

望文知义是在不需要额外解释的情况下，仅从名称上就能够理解某个词句的确切
含义。在代码元素命名时做到望文知义，从而减少注释内容，达到自解释的目的。在
实践中，望文知义的难度是最大的，就好像给孩子起名一样需要反复斟酌。文不对题
的命名方式，肯定会加大理解成本，更大的罪过是把程序员引导到一个错误的理解方
向上。某些不规范的缩写会导致理解成本增加，比如condition缩写成condi, 类似随
意的缩写会严重降低代码的可理解性。再比如，以单个字母命名的变量，在上下文理
解时，会带来很大的困扰。本书中的所有示例代码都比较精简，没有具体业务含义，
重点在于阐述示例背后的编程思维，所以采用单字母的简洁命名方式，在实际业务代
码中请勿模仿

主流的编程语言基本上以英语为基础，此处望文知义的“文”指的是英文。随着
开源社区的发展与繁荣，各国程序员踊跃参与开源项目的共建，国际交流与合作越来
越频繁，英语能力已经成为程序员必备的基础技能之一。 虽然有人认为命名方式应该
符合本国语言习惯，拼音这种命名方式，应该是被允许的，但是在国际化项目或开源
项目中，对于非汉语国家的开发工程师而言，拼音这种命名方式的可读性几乎为零。
即使在汉语系国家，拼音也存在地区差异。中英文混合的方式，更不应该出现，比如
在某业务代码中，曾经出现过DaZePromotion，猜了很久才被命名者告知是打折促销
的类。最让人无法容忍的是拼音“首字母”简写的命名方式，即使发挥极致的想象
力，也很难猜出具体的含义，比如PfmxBuilder，名称意思是评分模型的创建工厂类!
这些命名方式，极大增加了程序的理解成本。所以，正确的英文拼写和语法可以让阅
读者易于理解，避免歧义。alibaba、 taobao、 hangzhou等国际通用的名称，可视同英
文。某些复合语义的情况下，尽量使用完整的单词组合来达到望文知义的目的，比如
KeyboardShortcutsHandler、AtomicReferenceFieldUpdater

命名要符合语言特性、体现元素特征。命名做到望文知义、自解释是每个开发工
程师的基本素质之一。我们在思量更好的代码元素命名的同时，也要敢于修改已有的
不合理的命名方式

在所有代码元素中，常量和变量最为常见，优雅地定义与使用好它们，是开发工
程师的基本功之一

###### 3.1.1 常量
什么是常量?常量是在作用域内保持不变的值，一般用final关键字进行修饰，
根据作用域区分，分为全局常量、类内常量、局部常量。全局常量是指类的公开静态
属性，使用public static final修饰；类内常量是私有静态属性，使用private static final
修饰；局部常量分为方法常量和参数常量，前者是在方法或代码块内定义的常量，后
者是在定义形式参数时，增加final标识，表示此参数值不能被修改。全局常量和类
内常量是最主要的常量表现形式，它们的命名方式比较特殊，采用字母全部大写、单
词之间加下画线的方式。而局部常量采用小驼峰形式即可。示例代码如下：
```java
public class Constant {
    public static final String GLOBAL_CONSTANT = "shared in global";
    private static final String CLASS_CONSTANT = "shared in class";
    
    public void f(String a) {
        final String methodConstant = "shared in method";
    }
    
    public void g(final int b) {
        // 编译出错，不允许对常量参数进行重新赋值
        b = 3;
    }
}
```
常量在代码中具有穿透性，使用甚广。如果没有一个恰当的命名 ，就会给代码阅
读带来沉重的负担，甚至影响对主干逻辑的理解。首当其冲的问题就是到处使用魔法
值。魔法值即“共识层面”上的常量，直接以具体的数值或者字符出现在代码中。这
些不知所云的魔法值极大地影响了代码的可读性和可维护性。下面先来看一段实际业
务代码：

```java
public void getOnlinePackageCourse(Long packageId, Long userId) {
    if (packageId == 3) {
        logger.error("线下课程，无法在线观看");
        return;
    }
    // 其他逻辑处理
    PackageCourse online = packageService.getByTeacherId(userId);
    if (online.getPackageId() == 2) {
        logger.error("未审核课程");
        return;
    }
    // 其他逻辑处理
}
```
以上示例代码中，信手拈来的2和3分别表示未审核课程和线下课程，仅仅是两
个数字，似乎很容易记忆。但事实上除2和3两种状态外，还有1、4、5分别代表新
建、审核未通过、审核通过。在团队规模较小时，口口相传，倒也勉强能够记住这五
个数字的含义，早期还有零星的注释，驾轻就熟的情况下，连注释也省了。现实是残
酷的，团队迅速扩大后，课程状态个数也在逐步增加，新来的开发工程师在上线新功
能模块时，把“审核通过”和“未审核课程”对应的数字搞反了，使得课程展示错误，
导致用户大量投诉。随着应用变得越来越复杂，这些魔法值几乎成了整个后台服务代
码中的梦魇。团队架构师终于下定决心进行系统重构，把这些魔法值以合适的命名方
式定义成全局常量。使用Enum枚举类来定义课程类型，示例代码如下：
```java
public enum CourseTypeEnum {
    /**
     * 允许官方和讲师创建和运营
     */
    VIDEO_COURSE(1, ”录播课程"),

    /**
     * 只允许官方创建和运营。初始化必须设置合理的报名人数上限
     */
    LIVE_COURSE(2, ”直播课程")，

    /**
     * 只允许官方创建和运营
     */
    OFFLINE_COURSE(3, ”线下课程");
    
    private int seq;
    private String desc;
    
    CourseTypeEnum(int seq, String desc) {
        this.seq = seq;
        this.desc = desc;
    }
    
    public int getSeq() {
        return seq;
    }
    
    public String getDesc() {
        return desc;
    }
}
```
上述示例代码把课程类型分成三种：录播课程、直播课程、线下课程。枚举类型
几乎是固定不变的全局常量，使用频率高、范围广，所以枚举常量都需要添加清晰的
注释，比如业务相关信息或注意事项等。再把课程状态分为新课程、未审核课程、审
核通过、审核未通过、已删除五种状态。考虑到后续课程状态还会再追加，并且状态
没有扩展信息，所以用不能实例化的抽象类的全局常量来表示课程状态，示例代码如
下：
```java
public abstract class BaseCourseState {
    public static final int NEW_COURSE = 1;
    public static final int UNAUTHED_COURSE = 2;
    public static final int PASSED_COURSE = 3;
    public static final int NOT_PASSED_COURSE = 4;
    public static final int DELETED_COURSE = 5;
}
```
使用重构后的常量修改原有的魔法值，对比一下代码的可读性：
```java
public void getPackageCourse(Long packageId, Long userId) {
    if (packageId == CourseTypeEnum.OFFLINE_COURSE.getSeq()) {
        logger.error("线下课程，无法在线观看");
        return;
    }
    
    VideoCourse course = packageService.getByTeacherId(userId);
    if (course.getstate() == BaseCourseState.UNAUTHED_COURSE) {
        logger.error("未审核课程");
        return;
    }
}
```
我们认为，系统成长到某个阶段后，重构是一种必然选择。优秀的架构设计不是
去阻止未来一切重构的可能性，毕竟技术栈、业务方向和规模都在不断变化，而是尽
可能让重构来得晚一些，重构幅度小一些

即使类内常量和局部常量当前只使用一次，也需要赋予一个有意义的名称，目的
有两个：第一、望文知义，方便理解；第二、后期多次使用时能够保证值出同源。因此，
无论如何都不允许任何魔法值直接出现在代码中，避免魔法值随意使用导致取值不一
致，特别是对于字符串常量来说，应避免没有预先定义，就直接使用魔法值。所谓常
在河边走，哪有不湿鞋，在反复的复制与粘贴后，难免会出现问题，警示代码如下：
```java
String key = "Id#taobao_" + tradeId;
cache.put (key, value);
```
上述代码是保存信息到缓存中的方法，即使用魔法值组装Key。这就导致各个调
用方到处复制和粘贴字符串Id#taobao\_，这样似乎很合理。但某一天， 某个粗心的程
序员把Id#taobao\_复制成为Id#taobao，少了下画线。这个错误在测试过程中，并不
容易被发现，因为没有命中缓存，会自动访问数据库。但在大促时，数据库压力急剧
上升，进而发现缓存全部失效，导致连接占满，查询变慢。小处不小，再次说明魔法
值害人害己

某些公认的字面常量是不需要预先定义的，如for(int i=0;...)这里的0是可以直
接使用的。true和false也可以直接使用，但是如果具备了特殊的含义，就必须定义
出有意义的常量名称，比如在TreeMap源码中，表示红黑树节点颜色的true和false
就被定义成为类内常量，以方便理解：
```java
private static final boolean RED   = false;
private static final boolean BLACK = true;
```
常量命名应该全部大写，单词间用下画线隔开，力求语义表达完整清楚，不要嫌
名字长，比如，把最大库存数量命名为MAX_STOCK_COUNT，把缓存失效时间命
名为CACHE_EXPIRED_TIME

###### 3.1.2 变量
什么是变量?从广义来说，在程序中变量是一切通过分配内存并赋值的量，分为
不可变量(常量)和可变变量。从狭义来说，变量仅指在程序运行过程中可以改变其
值的量，包括成员变量和局部可变变量等

一般情况下，变量的命名需要满足小驼峰格式，命名体现业务含义即可。存在一
种特殊情况，在定义类成员变量时，特别是在POJO类中，针对布尔类型的变量，命
名不要加is前缀，否则部分框架解析会引起序列化错误。例如，定义标识是否删除的
成员变量为Boolean isDeleted， 它的getter方法也是isDeleted()，框架在反向解析的时
候，“误以为" 对应的属性名称是deleted,导致获取不到属性，进而抛出异常。但是
在数据库建表中，推荐表达是与否的值采用is_xxx的命名方式，针对此种情况，需要
在<resultMap>中设置，将数据表中的is_xxx 字段映射到POJO类中的属性Xxx

##### 3.2 代码展示风格
###### 3.2.1 缩进、空格与空行
缩进、空格与空行造就了代码的层次性和规律性，有助于直观、快速、准确地理
解业务逻辑。没有缩进、空格和空行的代码可读性极差。如下反例所示：
```java
table=newTab; 
if(oldTab!=null){
for(int j=0;j<oldCap;++j) {if((e=oldTab[j])!=nu11){
oldTab[j]=null;
if(e.next==null)
newTab[e.hash&(newCap-1)]=e;else if(e instanceof TreeNode)
if(loTail==null)loHead=e;else oTail.next=e;
modCount++;
if((tab=table)!=null&&size>=0) {
for(int i=0;i<tab.length;++i)tab[i]=null;
// 其他代码...
}
```
1. 缩进

缩进表示层次对应关系。使用Tab键缩进还是空格缩进长期以来备受争议，形成
两大阵营。每当在分享会现场调研缩进方式选择的时候，参与度几乎都是100%，通
常支持空格的人数多于支持Tab键的人数。这时候Tab键方一般都会提出：“空格不
是有2、4、8个之分吗?不如让空格方继续投票一下， 我们Tab键方还是非常团结一
致的”。某报告对40万个开源代码库进行了调研，发现近75%的代码文件使用了空
格进行缩进。对于团队协作来说，一致性风格很重要。我们推荐采用4个空格缩进，
禁止使用Tab键

由于不同编辑器对Tab的解析不一致，因此视觉体验会有差异，而空格在编辑器
之间是兼容的。2个空格缩进的层次区分度不明显，超过4个空格的缩进方式又留白
过多，且大多数IDE默认为4个空格缩进，所以我们采用4个空格的缩进方式。对
习惯用Tab键的工程师来说，唯一的福音是很多IDE工具提供了Tab键与空格之间
的快速转换设置。IDEA设置Tab键为4个空格时，请勿勾选Use tab character；而在
Eclipse中，必须勾选Insert spaces for tabs

2. 空格

空格用于分隔不同的编程元素。空格可以让运算符、数值、注释、参数等各种编
程元素之间错落有致，方便快速定位。空格的使用有如下约定：

(1) 任何二目、三目运算符的左右两边都必须加一个空格

(2) 注释的双斜线与注释内容之间有且仅有一个空格

(3) 方法参数在定义和传入时，多个参数逗号后边必须加空格

(4) 没有必要增加若干空格使变量的赋值等号与上一行对应位置的等号对齐

(5) 如果是大括号内为空，则简洁地写成{}即可，大括号中间无须换行和空格

(6) 左右小括号与括号内部的相邻字符之间不要出现空格

(7) 左大括号前需要加空格

例如，有些工程师习惯在多行赋值语句中对齐等号，如果增加了一条较长的赋值
语句，工程师需要更新之前所有的语句对齐格式，这种做法无疑提高了开发成本。此
外，虽然不推荐空大括号的代码出现，但可能会存在于某些测试代码或者流程语句中，
我们推荐空大括号中间无须换行和空格。详细的示例代码如下，重点看注释内容:
```java
public class SpaceCodeStyle {
    // 没有必要增加若干空格使变量的赋值等号与上一行对应位置的等号对齐
    private static Integer one = 1;
    private static Long two = 2L;
    private static Float three = 3F;
    private static StringBuilder sb = new StringBuilder("code style:");
    
    // 缩进4个空格(注意:本代码中的任何注释在双斜线与注释内容之间有且仅有一个空格)
    public static void main(String[] args) {
        // 继续缩进4个空格
        try {
            // 任何二目运算符的左右必须有一个空格
            int count = 0;
            // 三目运算符的左右两边都必须有一个空格
            boolean condition = (count == 0) ? true : false;
            // 关键词if与左侧小括号之间必须有一个空格
            // 左括号内的字母c与左括号、字母n与右括号都不需要空格
            // 右括号与左大括号前加空格且不换行，左大括号后必须换行
            if (condition) {
                System.out.println("world");
                // else的前后都必须加空格
                // 右大括号前换行，右大括号后有else时，不用换行
            } else {
                System.out.println("ok");
                // 在右大括号后直接结束，则必须换行
            }
        // 如果是大括号内为空，则简洁地写成{}即可，大括号中间无须换行和空格
        } catch (Exception e) {}
        
        // 在每个实参逗号之后必须有一个空格
        String result = getString(one, two, three, sb);
        System.out.println(result);
    }
    
    // 方法之间，通过空行进行隔断。在方法定义中，每个形参之后必须有一空格
    private static String getString(Integer one, Long two, Float three,
        StringBuilder sb) {
        // 任何二目运算符的左右必须有一个空格，包括赋值运算符，加号运算符等
        Float temp = one + two + three;
        sb.append(temp);
        return sb.toString();
    }
}
```
3. 空行

空行用来分隔功能相似、逻辑内聚、意思相近的代码片段，使得程序布局更加清
晰。在浏览代码时，空行可以起到自然停顿的作用，提升阅读代码的体验。哪些地方
需要空行呢?在方法定义之后、属性定义与方法之间、不同逻辑、不同语义、不同业
务的代码之间都需要通过空行来分隔

###### 3.2.2 换行与高度
1. 换行

代码中需要限定每行的字符个数，以便适配显示器的宽度，以及方便
CodeReview时进行diff比对。对于无节制的行数字符，需要不断地拉取左右滚动条
或者键盘移动光标，那是多么差的体验。因此，约定单行字符数不超过120个，超出
则需要换行，换行时遵循如下原则：

(1) 第二行相对第一行缩进4个空格，从第三行开始，不再继续缩进，参考示例

(2) 运算符与下文一起换行

(3) 方法调用的点符号与下文一起换行

(4) 方法调用中的多个参数需要换行时，在逗号后换行

(5) 在括号前不要换行
```java
StringBuffer sb = new StringBuffer() ;
// 超过120个字符的情况下，换行缩进4个空格，并且方法前的点号一起换行
sb.append("ma").append("chu")...
    .append("gao")...
    .append("xiao")... 
    .append("yeah");
```
2. 方法行数限制

水平方向上对字符数有限制，那么垂直方向上呢?对于类的长度，只要类功能内
聚，不做强制要求。但方法是执行单位，也是阅读代码逻辑的最高粒度模块。庞大的
方法容易引起阅读疲劳，让人抓不住重点。代码逻辑要分主次、个性和共性。不要把
不同层次的逻辑写在一个大方法体里，应该将次要逻辑抽取为独立方法，将共性逻辑
抽取成为共性方法(比如参数校验、权限判断等)，便于复用和维护，使主干代码逻
辑更加清晰

高内聚、低耦合是程序员最熟悉的口号。如何内聚和解耦，其实方法的行数限制
就引发了这些维度的思考。把相关的功能强内聚，把弱相关的功能拆解开来，重新抽
象、重新封装。在拆分方法的过程中，通常会纠结对参数的处理，因为拆分的各个方
法之间需要通过参数才能传递数据。有这种纠结的前提是方法需要传入大量的参数，
事实上这是另外一个话题。限制参数列表过长的方式有很多，比如包装成类、隐式传
递或放在集合中等

综上所述，约定单个方法的总行数不超过80行。详细的判定标准如下，除注释
之外，方法签名、左右大括号、方法内代码、空行、回车及任何不可见字符的总行数
不超过80行。为什么是80行?心理学认为人对事物的印象通常不能超过3这个魔法
数，三屏是人类短期记忆的极限，而80行在一般显示器上是两屏半的代码量。另外，
通过对阿里代码抽样调查显示，只有不到5%的方法才会超过80行，而这些方法通
常都有明显的优化空间

最后有人说，80 行的硬性要求会让程序员在写代码时刻意将多个变量定义在一
行，或者if后不写大括号，或者catch代码后使用空语句{}结束。每个公司都有一
些强制的代码风格，肯定有些是大家的代码素养决定的，少数人偏偏冒天下之大不韪，
被这个群体淘汰也是迟早的事情

###### 3.2.3 控制语句
控制语句是底层机器码跳转指令的实现。方法内部的跳转控制主要由条件判断语
句和循环语句实现。跳转能力使程序能够处理复杂逻辑，具备像人一样的判断能力和
记忆回溯能力。条件判断主要由if、switch、 三目运算符组成。循环严格意义上也是
一种跳转，主要由for、while、 do-while 组成

控制语句是最容易出现Bug的地方，所以特别需要代码风格的约束，而不是天
马行空地乱跳。控制语句必须遵循如下约定：

(1) 在if、else、for、while、do-while等语句中必须使用大括号。即使只有一行代码，
也需要加上大括号

(2) 在条件表达式中不允许有赋值操作，也不允许在判断表达式中出现复杂的
逻辑组合。有些控制语句的表达式逻辑相当复杂，与、或、取反混合运算甚至穿插了
赋值操作，理解成本非常高，甚至会产生误解。要解决这个问题，有一个非常简单的
办法：将复杂的逻辑运算赋值给一个具有业务含义的布尔变量。例如：
```java
// 逻辑判断中使用复杂的逻辑判断，不易于理解
if ((file.open(fileName, "w") != null) && (...) || !(...)) {
    ...
}

// 将复杂的逻辑运算赋值给一个易于理解的布尔变量，方便阅读代码
final boolean existed = (file.open(fileName, "W") != null)
    && (...) || !(...);

if (existed) {
   ...
}
```
(3) 多层嵌套不能超过3层。多层嵌套在哪里都不受欢迎，是因为条件判断和
分支逻辑数量呈指数关系。如果非得使用多层嵌套，请使用状态设计模式。对于超过
3层的if-else的逻辑判断代码，可以使用卫语句、策略模式、状态模式等来实现，其
中卫语句示例如下：
```java
public void today() {
    if (isBusy()) {
        System.out.println("change time.");
        return;
    }
    
    if (isFree()) {
        System.out.println("go to travel.");
        return;
    }
    
    System.out.println("stay at home to learn Easy Coding.");
    return;
}
```
(4) 避免采用取反逻辑运算符。取反逻辑不利于快速理解，并且取反逻辑写法
必然存在对应的正向逻辑写法。比如使用if (x < 628)表达x小于628，而不是使用if (!(x >= 628))

##### 3.3 代码注释
###### 3.3.1 注释三要素
注释是一个看起来简单，容易被忽视，但是作用又不容小觑的话题。好的注释能
起到指路明灯、拨云见日、警示等作用，具体包括：能够准确反映设计思想和代码逻
辑；能够描述业务含义，使其他工程师能迅速了解背景知识。与代码不同，注释没有
语法的限制，完全取决于编写者的能力和发挥，但这并不意味着注释可以天马行空。
书写注释要满足优雅注释三要素

1.  Nothing is strange

完全没有注释的大段代码对于阅读者来说形同天书。注释是给自己看的，即使离
写完代码很长时间，也能清晰地理解当时的思路；注释也是给维护者看的，使其能够
快速理解代码逻辑

相信大多数人阅读JDK源码时都十分吃力，比如并发控制、集合算法等，这些
天才级的程序基本上没有任何注释。JDK的代码稳定、高效压倒一切，不会朝编夕改。
但是业务代码需要被不断地维护更新，没有注释的代码给人一种陌生感。世界上最遥
远的距离是，我和要修改的代码间缺少一段注释。因此，我们提倡要写注释，然后才
是把注释写得精简

2. Less is more

从代码可读性及维护成本方面来讲，代码中的注释一定是精华中的精华

首先，真正好的代码是自解释的，准确的变量命名加上合理的代码逻辑，无须过
多的文字说明就足以让其他工程师理解代码的功能。如果代码需要大量的注释来说明
解释，那么工程师应该思考是否可以优化代码表现力

其次，泛滥的注释不但不能帮助工程师理解代码，而且会影响代码的可读性，甚
至会增加程序的维护成本。如下示例代码是滥用注释的样例，方法名put，加上两个
有意义的变量名elephant和fridge，已经明确表达了代码功能，完全不需要额外的注释。
在遇到修改代码逻辑时，注释泛滥会带来灾难性的负担
```java
// put elephant into fridge
put(elephant, fridge);
```
3.  Advance with the times

与时俱进的重要性对于开发工程师来说是不言而喻的。就像道路状况与导航软件
一样，如果导航软件严重滞后，就失去了导航的意义。同样，针对一段有注释的代码，
如果程序员修改了代码逻辑，但是没有修改注释，就会导致注释无法跟随代码前进的
脚步，误导后续开发者。因此，任何对代码的修改，都应该同时修改注释

###### 3.3.2 注释格式
注释格式主要分为两种：一种是Javadoc规范，另一种是简单注释

1.  Javadoc规范

类、类属性和类方法的注释必须遵循Javadoc规范，使用文档注释( /** */ )的格式。
按Javadoc规范编写的注释，可以生成规范的JavaAPI文档，为外部用户提供非常有
效的文档支持。而且在使用IDE工具编码时，IDE会自动提示所用到的类、方法等注
释，提高了编码的效率

这里要特别强调对枚举的注释是必需的。有人觉得枚举通常带了String name属
性，已经简要地说明了这个枚举属性值的意思，此时注释是多余的。其实不然，因为：

(1) 枚举实在太特殊了，它的代码极为稳定。如果它的定义和使用出现错误，
通常影响较大

(2) 注释的内容不仅限于解释属性值的含义，还可以包括注意事项、业务逻辑。
如果在原有枚举类上新增或修改一个属性值，还需要加上创建和修改时间，让使用者
零成本地知道这个枚举类的所有意图

(3) 枚举类的删除或者修改都存在很大的风险。不可直接删除过时属性，需要
标注为过时，同时注释说明过时的逻辑考虑和业务背景

2. 简单注释

包括单行注释和多行注释。特别强调此类注释不允许写在代码后方，必须写在代
码上方，这是为了避免注释的参差不齐，导致代码版式混乱。双画线注释往往使用在
方法内部，此时的注释是提供给程序开发者、维护者和关注方法细节的调用者查看的。
因此，注释的作用更应该是画龙点睛的，通常添加在非常必要的地方，例如复杂算法
或需要警示的特殊业务场景等
