#### 第8章 单元测试
计算机世界里的软件产品通常是由模块组合而成的，模块又可以分成诸多子模块。
比如淘宝系统由搜索模块、商品模块、交易模块等组成，而交易模块又分成下单模块、
支付模块、发货模块等子模块，如此细分下去，最终的子模块是由不可再分的程序单
元组成的。对这些程序单元的测试，即称为单元测试(Unit Testing，简称单测)。单
元的粒度要根据实际情况判定，可能是类、方法等，在面向对象编程中，通常认为最
小单元就是方法。单元测试的目的是在集成测试和功能测试之前对软件中的可测试单
元进行逐一检查和验证。单元测试是程序功能的基本保障，是软件产品上线前非常重
要的一环

虽然单元测试的概念众所周知，但是能够深入理解的人却屈指可数，精于单测之
道的工程师更是凤毛麟角。在很多人看来，单元测试是一件功不在当下的事情，快速
完成业务功能开发才是王道，特别是在评估工作量的时候，如果开发工程师说需要额
外时间来写单测，并因此延长项目工期，估计有些项目经理就按捺不住了。其实单元
测试是一件有情怀、有技术素养、有长远收益的工作，它是保证软件质量和效率的重
要手段之一。单元测试的好处包括但不限于以下几点：

1. 提升软件质量

优质的单元测试可以保障开发质量和程序的鲁棒性。在大多数互联网企业中，
开发工程师在研发过程中都会频繁地执行测试用例，运行失败的单测能帮助我们快速
排查和定位问题，使问题在被带到线上之前完成修复。正如软件工程界的一条金科玉
——越早发现的缺陷，其修复成本越低。一流的测试能发现未发生的故障；二流的
测试能快速定位故障的发生点；三流的测试则疲于奔命，一直跟在故障后面进行功能
回归

2. 促进代码优化

单元测试是由开发工程师编写和维护的，这会促使开发工程师不断重新审视自己
的代码，白盒地去思考代码逻辑，更好地对代码进行设计，甚至想方设法地优化测试
用例的执行效率。这个过程会促使我们不断地优化自己的代码，有时候这种优化的冲
动是潜意识的

3. 提升研发效率

编写单测表面上占用了项目研发时间，但磨刀不误砍柴工，在后续的联调、集成、
回归测试阶段，单元测试覆盖率高的代码通常缺陷少、问题易修复，有助于提升项目
的整体研发效率

4. 增加重构自信

代码重构往往是牵一发而动全身的。当修改底层数据结构时，上层服务经常会受
到影响。有时候只是简单地修改一个字段名称，就会引起一系列错误。但是在有单元
测试保障的前提下，重构代码时我们会很自然地多一分勇气，看到单元测试100%执
行通过的刹那充满自信和成就感

单元测试的好处不言而喻，同时我们也要摒弃诸如：单元测试是测试人员的工作，
单元测试代码不需要维护等常见误解。对于开发工程师来说，编写并维护单元测试不
仅仅是为了保证代码的正确性，更是一种基本素养的体现

##### 8.1 单元测试的基本原则
宏观上，单元测试要符合AIR原则；微观上，单元测试的代码层面要符合BCDE
原则

AIR即空气，单元测试亦是如此。当业务代码在线上运行时，可能感觉不到测试
用例的存在和价值，但在代码质量的保障上，却是非常关键的。新增代码应该同步增
加测试用例、修改代码逻辑时也，应该同步保证测试用例成功执行。AIR原则具体包括：

- A：Automatic (自动化)
- I：Independent (独立性)
- R：Repeatable (可重复)

单元测试应该是全自动执行的。测试用例通常会被频繁地触发执行，执行过程必
须完全自动化才有意义。如果单元测试的输出结果需要人工介入检查，那么它一定是
不合格的。单元测试中不允许使用System.out来进行人工验证，而必须使用断言来验证

为了保证单元测试稳定可靠且便于维护，需要保证其独立性。用例之间不允许互
相调用，也不允许出现执行次序的先后依赖。如下警示代码所示，testMethod2需要
调用testMethod1。在执行testMethod2时会重复执行验证testMethod1，导致运行效率
降低。更严重的是，testMethod1的验证失败会影响testMethod2的执行

```java
@Test
public void testMethod1() {
    ...
}

@Test
public void testMethod2() {
    testMethod1();
    ...
}
```
在主流测试框架中，JUnit的用例执行顺序是无序的，而TestNG支持测试用例的
顺序执行(默认测试类内部各测试用例是按字典序升序执行的，也可以通过XML或
注解priority的方式来配置执行顺序)

单元测试是可以重复执行的，不能受到外界环境的影响。比如，单元测试通常会
被放到持续集成中，每次有代码提交时单元测试都会被触发执行。如果单测对外部环
境(网络、服务、中间件等)有依赖，则很容易导致持续集成机制的不可用

编写单元测试时要保证测试粒度足够小，这样有助于精确定位问题，单元测试
用例默认是方法级别的。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试
需要覆盖的范围。编写单元测试用例时，为了保证被测模块的交付质量，需要符合
BCDE原则

- B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等
- C：Correct，正确的输入，并得到预期的结果
- D：Design，与设计文档相结合，来编写单元测试
- E：Error，单元测试的目标是证明程序有错，而不是程序无错。为了发现代
码中潜在的错误，我们需要在编写测试用例时有一些强制的错误输入(如非
法数据、异常流程、非业务允许输入等)来得到预期的错误结果

由于单元测试只是系统集成测试前的小模块测试，有些因素往往是不具备的，因
此需要进行Mock，例如：

(1) 功能因素。比如被测试方法内部调用的功能不可用

(2) 时间因素。比如双十一还没有到来，与此时间相关的功能点

(3) 环境因素。政策环境，如支付宝政策类新功能；多端环境，如PC、手机等

(4) 数据因素。线下数据样本过小，难以覆盖各种线上真实场景

(5) 其他因素。为了简化测试编写，开发者也可以将一些复杂的依赖采用Mock
方式实现

最简单的Mock方式是硬编码，更为优雅的方式是使用配置文件，最佳的方式是
使用相应的Mock框架，例如JMockit、EasyMock、JMock等。Mock的本质是让我
们写出更加稳定的单元测试，隔离上述因素对单元测试的影响，使结果变得可预测，
做到真正的“单元”测试

##### 8.2 单元测试覆盖率
单元测试是一种白盒测试，测试者依据程序的内部结构来实现测试代码。单测覆
盖率是指业务代码被单测测试的比例和程度，它是衡量单元测试好坏的一个很重要的
指标，各类覆盖率指标从粗到细、从弱到强排列如下

1. 粗粒度的覆盖

粗粒度的覆盖包括类覆盖和方法覆盖两种。类覆盖是指类中只要有方法或变量被
测试用例调用或执行到，那么就说这个类被测试覆盖了。方法覆盖同理，只要在测试
用例执行过程中，某个方法被调用了，则无论执行了该方法中的多少行代码，都可以
认为该方法被覆盖了。从实际测试场景来看，无论是以类覆盖率还是方法覆盖率来衡
量测试覆盖范围，其粒度都太粗了。以阿里研发场景为例，大多数开发工程师都能做
到类覆盖率和方法覆盖率达到100%，但这并不能说明测试用例已经写得很好，因为
这个标准是远远不够的

2. 细粒度的覆盖

细粒度的覆盖包括以下几种

(1) 行覆盖(Line Coverage)

行覆盖也称为语句覆盖，用来度量可执行的语句是否被执行到。行覆盖率的计算
公式的分子是执行到的语句行数，分母是总的可执行语句行数。示例代码如下：
```java
public class CoverageSampleMethods {
    public Boolean testMethod(int a, int b, int c) {
        boolean result = false;
        if (a == 1 && b == 2 || c == 3) {
            result = true;
        }
        return result;
    }
}
```
以上方法中有5行可执行语句和3个入参，针对此方法编写测试用例如下：
```java
@Test
@DisplayName("line coverage sample test")
void testLineCoverageSample() {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(1, 2, 0));
}
```
以上测试用例的行覆盖率是100%，但是在执行过程中c==3的条件判断根本没
有被执行到，a!=1并且c!=3的情况难道不应该测试一下吗? 由此可见，行覆盖的覆
盖强度并不高，但由于容易计算，因此在主流的覆盖率工具中，它依然是一个十分常
见的参考指标

(2) 分支覆盖(Branch Coverage)

分支覆盖也称为判定覆盖，用来度量程序中每一个判定分支是否都被执行到。分
支覆盖率的计算公式中的分子是代码中被执行到的分支数，分母是代码中所有分支的
总数。譬如前面例子中，(a == 1 && b == 2 || c ==3 )整个条件为一个判定，测试数据
应至少保证此判定为真和为假的情况都被覆盖到。分支覆盖容易与下面要说的条件判
定覆盖混淆，因此我们先介绍条件判定覆盖的定义，然后再对比介绍两者的区别

(3) 条件判定覆盖(Condition Decision Coverage)

条件判定覆盖要求设计足够的测试用例，能够让判定中每个条件的所有可能情况
至少被执行一次，同时每个判定本身的所有可能结果也至少执行一次。例如
(a == 1 && b == 2 || c == 3)这个判定中包含了3种条件，即a==1、b==2和c==3。为了便
于理解，下面我们仍使用行覆盖率中的testMethod方法作为被测方法,测试用例如下：

```java
@ParameterizedTest
@DisplayName("Condition Decision coverage sample test result true")
@CsvSource ({
    "0, 2, 3", 
    "1, 0, 3",
})
void testConditionDecisionCoverageTrue(int a, int b, int c) {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(a, b, c));
}

@DisplayName("Condition Decision coverage sample test result false")
void testConditionDecisionCoverageFalse() {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(0, 0, 0));
}
```
通过@ParameterizedTest，我们可以定义一个参数化测试，@CsvSource注解使
得我们可以通过定义一个String数组来定义多次运行测试时的参数列表，而每一个
String值通过逗号分隔后的结果，就是每一次测试运行时的实际参数值。我们通过两
个测试，用例分别测试判定结果为true和false这两种情况，第一个 测试用例
testConditionDecisionCoverageTrue会运行两次，a、b、c这3个参数的值分别为
0、2、3和1、0、3；第二个测试用例testConditionDecisionCoverageFalse的3个参数的值都0。
在被测方法testMethod中，有一个判定(a == 1 && b == 2 || c == 3)包含了三个条件
(a==1、b==2、c==3)，判定的结果显而易见有两种(true、false)，我们已经都覆盖到了。
另外，我们设计的测试用例，也使得上述三个条件真和假的结果都取到了。因此，这
个测试用例满足了条件判定覆盖

(4) 条件组合覆盖(Multiple Condition Coverage)

条件组合覆盖是指判定中所有条件的各种组合情况都出现至少一次。还是以
(a == 1 && b == 2 || c == 3)这个判定为例，我们在介绍条件判定覆盖时，忽略了如
a==1、b==2、 c==3等诸多情况。针对被测方法testMethod，满足条件组合覆盖的一
个测试用例如下：

```java
@ParameterizedTest
@DisplayName("Multiple Condition Coverage sample test result true")
@CsvSource ({
    "1, 2, 3",
    "1, 2, 0", 
    "1, 0, 3", 
    "0, 2, 3", 
    "0, 0, 3", 
})
void testMultipleConditionCoverageSampleTrue(int a, int b, int c) {
CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(a, b, c));
}

@ParameterizedTest
@DisplayName ("Multiple Condition Coverage sample test result false")
@CsvSource ({
    "1, 0, 0", 
    "0, 0, 0", 
    "0, 2, 0", 
})
void testMultipleConditionCoverageSampleFalse(int a, int b, int c) {
    CoverageSampleMethods coverageSampleMethods new CoverageSampleMethods();
    Assertions.assertFalse(coverageSampleMethods.testMethod(a, b, c));
}
```
这组测试用例同时满足了(a==1, b==2, c==3) 为(true, true, true)、 ( true, 
true, false)、(true, false, true)、(true, false, false)、 (false, true, true)、(false,
true, false) 、( false, false, true) 、(false, false, false) 这8种情况。对于一个
包含了n个条件的判定，至少需要2^n个测试用例才可以。虽然这种覆盖足够严谨，
但无疑给编写测试用例增加了指数级的工作量

(5)路径覆盖(Path Coverage)

路径覆盖要求能够测试到程序中所有可能的路径。在testMethod方法中，可能的
路径有：①a==1,b==2 ②a==1,b!=2,c==3 ③a==1,b!=2,c!=3 ④a!=1,c==3 ⑤a!=1,c!=3 
这5种。当存在“||” 时，如果第一个条件已经为true，则不再计算后边表达式的值；
而当存在“&&”时，如果第一个条件已经为false，则同样不再计算后边表达式的值。
满足路径覆盖的测试用例如下：
```java
@ParameterizedTest
@DisplayName("Path coverage sample test result true")
@CsvSource({
    "1, 2, 0",
    "1, 0, 3", 
    "0, 0, 3", 
})
void testPathCoverageSampleTrue(int a, int b, int c) {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(a, b, c));
}

@ParameterizedTest
@DisplayName ("Path coverage sample test result false")
@CsvSource ({
    "0, 0, 0", 
})
void testPathCoverageSampleFalse(int a, int b, int C) {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertFalse(coverageSampleMethods.testMethod2(a, b, c));
}
```

##### 8.3 单元测试编写
单元测试编写是开发工程师的日常工作之一，利用好各种测试框架并掌握好单元
测试编写技巧，往往可以达到事半功倍的效果。本节主要介绍如何编写JUnit测试用例。
我们先简要了解一下JUnit 单元测试框架

###### 8.3.1 JUnit单元测试框架
Java语言的单元测试框架相对统一， JUnit和TestNG几乎始终处于市场前两位。
其中JUnit以较长的发展历史和源源不断的功能演进，得到了大多数用户的青睐，也
是阿里内部目前使用最多的单元测试框架

JUnit项目的起源可以追溯到1997年。两位参加“面向对象程序系统语言
和应用大会”(Conference for Object-Oriented Programming Systems, Languages &
Applications)的极客开发者Kent Beck和Erich Gamma，在从瑞士苏黎世飞往美国亚
特兰大的飞机上，为了打发长途飞行的无聊时间，他们聊起了对当时Java测试过程
中缺乏成熟工具的无奈，然后决定一起设计一款更好用的测试框架，于是采用结对编
程的方式在飞机上完成了JUnit雏形，以及世界上第一个JUnit单元测试用例。经过
20余年的发展和几次重大版本的跃迁，JUnit于2017年9月正式发布了5.0稳定版本。
JUnit5对JDK8及以上版本有了更好的支持(如增加了对lambda表达式的支持)，
并且加入了更多的测试形式，如重复测试、参数化测试等。因此本书的测试用例会使
用JUnit5来编写，部分写法如果在JUnit4中不兼容，则会提前说明

JUnit5.x由以下三个主要模块组成

JUnit Platform：用于在JVM上启动测试框架，统一命令行、Gradle和Maven
等方式执行测试的入口

JUnit Jupiter：包含JUnit5.x全新的编程模型和扩展机制

JUnit Vintage：用于在新的框架中兼容运行JUnit3.x和JUnit4.x的测试用例

为了便于开发者将注意力放在测试编写上，即不必关心测试的执行流程和结果展
示，JUnit提供了一些辅助测试的注解，常用的测试注解说明如表8-1所示









###### 8.3.2 命名




###### 8.3.3 断言与假设




