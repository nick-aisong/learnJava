#### 第2章 面向对象
本章开始讲解面向对象思想，并以Java为载体讲述面向对象思想在具体编程语
言中的运用与实践。当前主流的编程语言有50种左右，主要分为两大阵营：面向对
象编程与面向过程编程

面向对象编程( Object-Oriented Programming, OOP )是划时代的编程思想变革，
推动了高级语言的快速发展和工业化进程。OOP的抽象、封装、继承、多态的理念
使软件大规模化成为可能，有效地降低了软件开发成本、维护成本和复用成本。面向
对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像搭积木一
样隔离可控、高效简单，是当今编程领域的一股势不可当的潮流。OOP实践了软件
工程的三个主要目标：可维护性、可重用性和可扩展性

##### 2.1 OOP理念
面向过程让计算机有步骤地顺次做一件事情，是一种过程化的叙事思维。但是在
大型软件开发过程中，发现用面向过程语言开发，软件维护、软件复用存在着巨大的
困难，代码开发变成了记流水账，久而久之就成为“面条”代码，模块之间互相耦合，
流程互相穿插，往往牵一发而动全身。面向对象提出一种计算机世界里解决复杂软件
工程的方法论，拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案

但是，编程语言仅是一个工具，就像练武之人的剑，武功高者草木皆剑，武功差
者即使莫邪剑在身也依然平庸。所以，能否将工具的价值发挥得淋漓尽致，最终还是
取决于开发工程师本身。优秀的开发工程师用面向过程的语言也能把程序写得非常内
聚，可扩展性好，具备一定的复用性；而平庸程序员用面向对象语言一样能把程序写
得松散随意、毫无抽象与建模、模块间耦合严重、维护性差

传统意义上，面向对象有三大特性：封装、继承、多态。本书明确将“抽象”作
为面向对象的特性之一，支持面向对象“四大特性”的说法。抽象是程序员的核心素
质之一，体现出程序员对业务的建模能力，以及对架构的宏观掌控力。虽然面向过程
也需要进行一定的抽象能力，但是相对来说，面向对象思维，以对象模型为核心，丰
富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象
能力显得尤为重要；封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，
更具有维护性；继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有
复用性；多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间

抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力
是后续的封装、继承、多态的基础，是软件大厦的基石。在面向对象的思维中，抽象
分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行
归一化的逻辑思维过程；后者则是从本质到具体，从共性到个性，逐步形象化的过程。
在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已
有问题解决方案的基础上，正确地找到合适的使用场景。演绎错误在使用集合时比较
常见，比如针对查多改少的业务场景，使用链表是非常不合理的；底层框架技术选型
时如果有错误，则有可能导致技术架构完全不适应业务的快速发展

Java之父Gosling 设计的Object类，是任何类的默认父类，是对万事万物的抽象，
是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知
道哲学的三大经典问题：我是谁，我从哪里来，我到哪里去。在Object类中，这些问
题都可以得到隐约的解答：

(1) 我是谁? getClass()说明本质上是谁，而toString()是当前职位的名片

(2) 我从哪里来? Object()构造方法是生产对象的基本步骤，clone()是繁殖对
象的另一种方式

(3) 我到哪里去? finalize()是在对象销毁时触发的方法

这里重点介绍clone()方法，它分为浅拷贝、一般深拷贝和彻底深拷贝。浅拷贝
只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指
向的实际对象；而彻底深拷贝是在成功clone一个对象之后，此对象与母对象在任何
引用路径上都不存在共享的实例对象，但是引用路径递归越深，则越接近JVM底层
对象，且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深
拷贝。归根结底，慎用Object的clone()方法来拷贝对象，因为对象的clone() 方法默
认是浅拷贝，若想实现深拷贝，则需要覆写clone() 方法实现引用对象的深度遍历式
拷贝

另外，Object还映射了社会科学领域的一些问题：

(1) 世界是否因你而不同?hashCode()和equals()就是判断与其他元素是否相
同的一组方法

(2) 与他人如何协调? wait()和notify()是对象间通信与协作的一组方法

随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如finalize()
方法在JDK9之后直接被标记为过时方法。而wait()和notify()同步方式事实上已经
被同步信号、锁、阻塞集合等取代

封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的
方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，
具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部
敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感
方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。封装使面向对象的世
界变得单纯，对象之间的关系变得简单，各人自扫门前雪，耦合度变弱，有利于维护。
智能化的时代，对封装的要求越来越高，产品使用更加简单方便、轻松自然。就像天
猫精灵，唯一的接口就是语音输入，隐藏了指令内部的细节实现和相关数据，使外部
用户无法访问，大大降低了使用成本，有效地保护内部数据安全

设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A模块使用
B模块的某个接口行为，对B模块中除此行为之外的其他信息知道得尽可能少。比如：
耳塞的插孔就是提供声音输出的行为接口，只需关心这个插孔是否有相应的耳塞标记，
是否是圆形的，有没有声音即可，至于内部CPU如何运算音频信息，以及各个电容
如何协同工作，根本不需要去关注，这使模块之间的协作只需忠于接口、忠于功能实
现即可

封装这件事情是由俭入奢易，由奢入俭难。属性值的访问与修改需要使用相应的
getter/setter方法，而不是直接对public的属性进行读取和修改，可能有些程序员存在
疑问，既然通过这两个方法来读取和修改，那与直接对属性进行操作有何区别?如果
某一天，类的提供方想在修改属性的setter方法上进行鉴权控制、日志记录，这是在
直接访问属性的情形中无法做到的。若是将已经公开的属性和行为直接暴力修改为
private，则依赖模块都会编译出错。所以，在不知道什么样的访问控制权限合适的时候，
优先推荐使用private控制级别

继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系，形成一
个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复
用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有
层次感，更有扩展性，为多态打下语法基础

人人都说继承是is-a关系，那么如何衡量当前的继承关系是否满足is-a关系呢?
判断标准即是否符合里氏代换原则(Liskov Substitution Principle，LSP)。LSP是指
任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方，
警察在枪战片中经常说：放下武器，把手举起来！而对面的匪徒们有的使用手枪，有
的使用匕首，这些都是武器的子类。父类出现的地方，即“放下武器”，那么，放下
手枪，是对的，放下匕首，也是对的!在实际代码环境中，如果父类引用直接使用子
类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个
类之间符合LSP原则，可以使用继承关系

继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。
想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样容易被滥
用，我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆
炸。方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为
的能力，比如鸟会飞，鸵鸟继承鸟，发现飞不了，这就是方法污染。子类继承父类，
则说明子类对象可以调用父类对象的一切行为。在这样的情况下，总不能在继承时，
添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方
法，抛出异常，以阻止别人的调用。方法爆炸是指继承树不断扩大，底层类拥有的方
法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，
很容易在实际编程中产生选择困难症。比如某些综合功能的类，经过多次继承后达到
上百个方法，造成了方法爆炸，因而带来使用不便和安全隐患。在实际故障中，因为
方法爆炸，父类的某些方法签名和子类非常相似，在IDE中，输入类名+点之后，
在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述，提倡组合
优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而
不是继承

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态是面向对象天空
中绚丽多彩的礼花，提升了对象的扩展能力和运行时的丰富想象力。我们来明确两个
非常容易混淆的概念：“override”和“overload"，"override"译成“覆写”，是子
类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直
方向上行为的不同实现。“overload”译成“重载”，方法名称是相同的，但是参数
类型或参数个数是不相同的，是水平方向上行为的不同实现。多态是指在编译层面无
法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由JVM进
行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态
绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。自然界的
多态最典型例子就是碳家族，据说某化学家告诉他女朋友将在她的生日晚会上送她一
块碳，女朋友当然不高兴，可收到的却是5克拉的钻石。钻石就是碳元素在不断进化
过程中的一种多态表现。严格意义上来说，多态并不是面向对象的一种特质，而是一
种由继承行为衍生而来的进化能力而已

##### 2.2 初识Java
面向对象编程思想把所有的有形或无形的事物都看作对象，并给对象赋予相应
的属性和行为，建立对象之间的联系，使程序员更加立体、形象地解决编程领域的问
题。面向对象语言的忠实代表是Java语言，它是一门富有生命力的语言，在最受欢
迎的语言排行榜上，多年位居第一。Java语言是1995年由Sun公司首次发布的。次
年Java开发工具包发布，即Java Development Kit，简称JDK1.0，这是Java发展的一
个重要里程碑，标志着Java成为一门独立的成熟语言。随后，Sun 公司再接再厉发布
了Just-in-time编译器，简称JIT，不断进步的JIT技术使Java的执行速度接近甚至超
过其他高级语言

JDK随着时代不断往前发展。在众多版本中，最具划时代影响力的版本是
JDK5，项目代号Tiger。Doug Lea推出的并发包，使Java如虎添翼，成为工业级语言，
在企业服务端得到极为广泛的应用。随着后续版本的陆续推出，Java的发展与时俱进，
推出了diamond语法、函数式、模块化、var 类型推断等新特性。最新的JDK版本是
JDK11

JRE (Java Runtime Environment)即Java运行环境，包括JVM、核心类库、核
心配置工具等。其中JVM (Java Virtual Machine)即Java虚拟机，它是整个Java体
系的底层支撑平台，把源文件编译成平台无关的字节码文件，屏蔽了Java源代码与
具体平台相关的信息，所以Java源代码不需要额外修改即可跨平台运行。JVM不
仅支撑着Java语言，还包括Kotlin、Scala、 Python 等其他流行语言。其中Kotlin 是
Jetbrains开发的跨平台语言,其语法简洁、类型安全,可以编译成字节码运行在JVM上，
与Java语言非常方便地进行混合编程。1999 年，Sun 公司发布公开版本的HotSpot,
它是当前主流的Java虚拟机。2006 年，在JavaOne大会上开源相关核心技术，启动
OpenJDK项目，逐步形成了活跃的OpenJDK社区。在社区的带动下，Java 生态也随
之繁荣，包括AJDK、Spring、 Hadoop、 Dubbo、 JStorm、 RocketMQ 等Java相关解决
方案，极大地提升了Java 语言的生产效率

Java语言拥有跨平台、分布式、多线程、健壮性等主要特点，是当下比较主流的
高级编程语言。它的类库相当丰富、功能强大、简单易用，对开发者相当友好，不仅
吸收了C++的优点，还摒弃了其难以掌控的多继承、指针等概念。Java比较好地实
现了面向对象理论，允许开发工程师以优雅的思维方式处理复杂的编程场景

##### 2.3 类
###### 2.3.1 类的定义
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有public和无访问控制符，类型分
为class、interface、 enum

Java类主要由两部分组成成员和方法。在定义Java类时，推荐首先定义变量，
然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展
示；保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法，因此重要
性仅次于公有方法；而私有方法对外部来说是一个 黑盒实现，因此一般不需要被特别
关注最后是getter/setter方法，虽然它们也是公有方法，但是因为承载的信息价值较低，
一般不包含业务逻辑，所以所有getter/setter方法须放在类最后

###### 2.3.2 接口与抽象类
正如面向对象四大特性(抽象、封装、继承、多态)所述，定义类的过程就是抽
象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行
为和特征。接口与抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例
对象。本节主要分析两者的不同之处，首先从语法上进行区分，如表2-1所示

抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。
与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方
法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等同于一个接口。is-a
关系需要符合里氏代换原则，例如Eagle is a Bird. Bird is an Object。can-do 关系要符
合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为，例如Plane can
fly. Bird can fly.中应该把fly定义成一个接口，而不是把fly()放在某个抽象类中，再
由Plane和Bird利用is-a关系去继承此抽象类。因为严格意义上讲，除fly这个行为外，
在Plane和Bird之间很难找到其他共同特征

抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，
性格偏内向，比如某品牌特定型号的汽车，底盘架构、控制电路、刹车系统等是抽象
出来的共同特征，但根据动感型、舒适型、豪华型的区分，内饰、车头灯、显示屏等
可以存在不同版本的实现。接口是开放的，性格偏外向，它就像一份合同， 定义了方
法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它，但如果想实现它的
类就必须遵守这份接口约定合同，比如，任何类型的车辆都必须实现如下接口：
```java
public interface VehicleSafe {
    /**
    * @param initSpeed 刹车时的初始速度
    * @param brakeTime 从initSpeed开始刹车到停止行驶的时间，单位是毫秒
    * @return 从initSpeed开始刹车到停止行驶的距高
    */
    double brake (int initSpeed, int brakeTime);
}
```
刹车是一个开放式的强制行为规范，任何车辆都必须具有刹车的能力，要明确在
特定初速度的情况下，刹车时间多久，刹车距离多长。此规范对任何车辆都是强约束
的，这就是契约

接口是顶级的“类”，虽然关键字是interface，但是编译之后的字节码扩展名还
是.class。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后
实现部分接口行为，其中AbstractCollection是最典型的抽象类：
```java
public abstract class AbstractCollection<E> implements Collection<E> {
    // Collection定义的抽象方法，但本类没有实现
    // Collection接口定义的方法，size()这个方法对于链表和顺序表有不同的实现方式
    public abstract int size();
    
    // 实现Collection接口的这个方法，因为对AbstractCollection的子类
    // 它们判空的方式是一致的，这就是模板式设计，对干所有它的子类，实现共同的方法体，
    // 通过多态调用到子类的具体size()实现
    public boolean isEmpty() {
        //实现Collection的方法
        return size() == 0;
    }
    
    //其他属性和部分方法实现....
}
```
Java语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚
至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的
绑定机制会变得非常复杂。接口继承接口，关键字是extends，而不是implements，
允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实
体类在实现多重继承后的接口时，只是说明"can do many things"。当纠结定义接口
还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接
口，然后再用抽象类去implements某些接口，这样做可方便后续的扩展和重构

###### 2.3.3 内部类
在一个.java源文件中，只能定义一个类名与文件名完全一致的公开类，使用
public class关键字来修饰。但在面向对象语言中，任何一个类都可以在内部定义另外
一个类，前者为外部类，后者为内部类。内部类本身就是类的一个属性，与其他属性
定义方式一致。 比如，属性字段private static String str，由访问控制符、是否静态、类型、
变量名组成，而内部类private static class Inner{}，也是按这样的顺序来定义的，类型
可以为class、enum，甚至是interface，当然在内部类中定义接口是不推荐的。内部类
可以是静态和非静态的，它可以出现在属性定义、方法体和表达式中，甚至可以匿名
出现，具体分为如下四种

- 静态内部类，如： static class StaticInnerClass{};

- 成员内部类，如:：private class InstanceInnerClass{};

- 局部内部类，定义在方法或者表达式内部;

- 匿名内部类，如： (new Thread(){}).start()

如下是最精简的4种内部类定义方式：
```java
public class OuterClass {
    // 成员内部类
    private class InstanceInnerClass {}
    // 静态内部类
    static class StaticInnerClass {}
    
    public static void main(String[] args) {
        // 两个匿名内部类，分别对应图2-1所示的OuterClass$1和OuterClasss2
        (new Thread() {}).start();
        (new Thread() {}).start();
        
        // 两个方法内部类，分别对应图2-1所示的OuterClasss1MethodClass1和
        // OuterClass$1MethodClass2
        class MethodClass1 {}
        class MethodClass2 {}
    }
}
```
无论是什么类型的内部类，都会编译成一个独立的.class文件，如图2-1所示

外部类与内部类之间使用$符号分隔，匿名内部类使用数字进行编号，而方法内
部类，在类名前还有一个编号来标识是哪个方法。匿名内部类和静态内部类是比较常
用的方式。在本书的示例代码中经常使用匿名类来启动线程，节约了若干行代码。而
静态内部类是最常用的内部表现形式，外部可以使用OuterClass.StaticInnerClass直接
访问，类加载与外部类在同一个阶段进行，在JDK源码中，定义包内可见静态内部
类的方式很常见，这样做的好处是：

(1) 作用域不会扩散到包外

(2) 可以通过“外部类.内部类”的方式直接访问

(3) 内部类可以访问外部类中的所有静态属性和方法

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K, V> next;
}
```
如上所示的源码是在ConcurrentHashMap中定义的Node静态内部类，用于
表示一个节点数据，属于包内可见，包内其他集合要用到这个Node时，直接使用
ConcurrentHashMap.Node。仅包内可见，可以阻止外部程序随意使用此类来生成对
象，Node的父类Entry是Map的静态内部类，之所以可以被Node成功继承，是
因为两个外部类同属一个包。在JDK源码中，使用内部类封装某种属性和操作的
方式比较常见，比如应用类加载器Launcher的AppClassLoader， ReentrantLock 中
继承自AbstractQueuedSynchronizer的内部类Sync，ArrayList中的私有静态内部类
SubList。内部类中还可以定义内部类，形成多层嵌套，如在ThreadLocal静态内部类
ThreadLocalMap中还定义一个内部类Entry，如图2-2所示

因为访问权限可见，所以在同一包内的Thread可以直接使用如下方式声明自己
的属性：
```java
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

###### 2.3.4 访问权限控制
面向对象的核心思想之一就是封装， 只把有限的方法和成员公开给别人，这也是
迪米特法则的内在要求，使外部调用方对方法体内的实现细节知道得尽可能少。如何
实现封装呢?需要使用某些关键字来限制类外部对类内属性和方法的随意访问，这些
关键字就是访问权限控制符。在详细介绍访问权限之前，我们明确一个概念——是否
可见，如下示例代码：
```java
package a;
public class VisibleScope {
    public void publicMethod() {}
    protected void protectedMethod() {}
    void noneMethod() {}
    private void privateMethod() {}
}
```
在package b中，图2-3左侧对VisibleScope类进行实例化，通过引用变量，仅
能看到publicMethod()方法，我们称为publicMethod()方法是当前可见的；使用同一
个类，图2-3右侧对VisibleScope子类VisibleScopeInvoke进行实例化，通过引用变量，
可以看到两个方法，新增了红色框内的protectedMethod()方法，那么这两个方法是当
前可见的；如果这个类也在package a中，那么noneMethod是可见的；在任何情况下，
类外部实例化出来的对象均无法调用私有方法，比如本示例中的privateMethod方法

- public：可以修饰外部类、属性、方法，表示公开的、无限制的，是访问限
制最松的一级,被其修饰的类、属性和方法不仅可以被包内访问，还可以跨类、
跨包访问，甚至允许跨工程访问

- protected：只能修饰属性和方法，表示受保护的、有限制的，被其修饰的属
性和方法能被包内及包外子类访问。注意，即使并非继承关系，protected 属
性和方法在同一包内也是可见的

- 无：即无任何访问权限控制符，如示例中的noneMethod方法，没有任何
修饰符。千万不要说成default，它并非访问权限控制符的关键字，另外，在
JDK8接口中引入default默认方法实现，更加容易混淆两者释义。无访问权
限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚；要么定
义公开类，即public class，包外也可以实例化

- private：只能修饰属性、方法、内部类。表示“私有的”，是访问限制最严
格的一-级，被其修饰的属性或方法只能在该类内部访问，子类、包内均不能
访问，更不允许跨包访问

由此可见，不同的访问权限控制符对应的可见范围不同。在定义类时，要慎重思
考该方法、属性、内部类的访问权限，提倡严控访问范围。过于宽泛的访问范围不利
于模块间解耦及未来的代码维护。试想，在进行代码重构时，private方法过旧，我们
可以直接删除，且无后顾之忧。可是如果想删除一个public的方法，是不是要谨慎又
谨慎地检查是否被调用。变量就像自己的小孩，要尽量控制在自己的视线范围内，如
果作用域太大，无限制地到处乱跑，就会担心其安危。因此，在定义类时，推荐访问
控制级别从严处理：

(1) 如果不允许外部直接通过new创建对象，构造方法必须是private

(2) 工具类不允许有public或default构造方法

(3) 类非static成员变量并且与子类共享，必须是protected

(4) 类非static成员变量并且仅在本类使用，必须是private

(5 )类static成员变量如果仅在本类使用，必须是private

(6 )若是static成员变量，必须考虑是否为final

(7) 类成员方法只供类内部调用，必须是private

(8) 类成员方法只对继承类公开，那么限制为protected

###### 2.3.5 this与super
对象实例化时，至少有一条从本类出发抵达Object的通路，而打通这条路的两
个主要工兵就是this和super，逢山开路，遇水搭桥。但是this和super往往是默默无
闻的，在很多情况下可以省略，比如：

- 本类方法调用本类属性

- 本类方法调用另一个本类方法

- 子类构造方法隐含调用super()

任何类在创建之初，都有一个默认的空构造方法，它是super()的一条默认通路。
构造方法的参数列表决定了调用通路的选择；如果子类指定调用父类的某个构造方法，
super就会不断往上溯源；如果没有指定，则默认调用super()。如果父类没有提供默
认的构造方法，子类在继承时就会编译错误，如图2-4所示

如果父类坚持不提供默认的无参构造方法，必须在本类的无参构造方法中使用
super方式调用父类的有参构造方法，如public Son(){ super(123); }

一个实例变量可以通过this.赋值另一个实例变量；一个实例方法可以通过this.
调用另一个实例方法；甚至一个构造方法都可以通过this.调用另一个构造方法。如
果this和super指代构造方法，则必须位于方法体的第一行。换句话说，在一个构造
方法中，this和super只能出现一个，且只能出现一次，否则在实例化对象时，会因
子类调用到多个父类构造方法而造成混乱

由于this和super都在实例化阶段调用，所以不能在静态方法和静态代码
块中使用this和super关键字。this还可以指代当前对象，比如在同步代码块
synchronized(this)...}中，super并不具备此能力。但super也有自己的特异功能，在
子类覆写父类方法时，可以使用super调用父类同名的实例方法。最后总结一下this
和super的异同点，如图2-5所示

###### 2.3.6 类关系
关系是指事物之间存在单向或相互的作用力或者影响力的状态。类与类之间的关
系可分成两种：有关系与没关系，这似乎是一句非常正确的废话，难点在于确定类与
类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问
题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了
没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。有关系的
情况下，包括如下5种类型：

- [继承 ] extends (is-a)

- [实现] implements (can-do)

- [组合] 类是成员变量(contains-a)

- [聚合] 类是成员变量(has-a)

- [依赖] import类(use-a)

继承和实现是比较容易理解的两种类关系。在架构设计中，要注意组合、聚合和
依赖这三者的区别

组合在汉语中的含义是把若干个独立部分组成整体，各个部分都有其独立的使用
价值和生命周期。而类关系中的组合是一种完全绑定的关系， 所有成员共同完成一件
使命，它们的生命周期是一样的。组合体现的是非常强的整体与部分的关系，同生共
死，部分不能在整体之间共享

聚合是一种可以拆分的整体与部分的关系，是非常松散的暂时组合，部分可以被
拆出来给另一个整体

依赖是除组合和聚合外的类与类之间的关系，这个类只要import，那就是依赖关系

在类图中，用空心的三角形表示继承，用实心的菱形表示组合，用空心的菱形表
示聚合，这三者都是用实线连接的。用三角形来表示实现，用一个箭头表示依赖，与
前面的区别是这两者都是用虚线连接的。在画类图时，菱形、箭头、三角形放在哪一
侧呢?在很多类图中，这个处理是非常随意的。如果方向画反了，那么类结构的认知
也就反了。有一个规律，有形状的图形符号一律放在权力强的这一侧，如表2-3所示

随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待
类图。比如表2-3中的Body和Head，如果有一天，动物的脑袋可以随意地移植，那
么就从组合关系变成聚合关系了。狗与狗绳之间的约束，虽然很弱，但是如果防疫局
在狗绳上标记疫苗记录，那么它们之间的关系就会变强，就变成组合关系了。在业务
重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一
种演变

###### 2.3.7 序列化
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数
据对象转换为二进制流的过程称为对象的序列化(Serialization)。反之，将二进制流
恢复为数据对象的过程称为反序列化(Deserialization)。序列化需要保留充分的信息
以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可
能小。序列化常见的使用场景是RPC框架的数据传输。常见的序列化方式有三种：

(1) Java原生序列化。Java类通过实现Serializable接口来实现该类对象的序列化，
这个接口非常特殊；没有任何方法，只起标识作用。Java 序列化保留了对象类的元数
据(如类、成员变量、继承类信息等)，以及对象数据等，兼容性最好，但不支持跨
语言，而且性能一般

实现Serializable接口的类建议设置serialVersionUID 字段值，如果不设置，那么
每次运行时，编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自
动生成serialVersionUID。如果类的源代码有修改，那么重新编译后serialVersionUID
的取值可能会发生变化。因此实现Serializable接口的类一定要显式地定义
serialVersionUID属性值。修改类时需要根据兼容性决定是否修改serialVersionUID值：

- 如果是兼容升级，请不要修改serialVersionUID字段，避免反序列化失败

- 如果是不兼容升级，需要修改serialVersionUID值，避免反序列化混乱

使用Java原生序列化需注意，Java反序列化时不会调用类的无参构造方法，而
是调用native方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不
推荐使用Java原生序列化

(2) Hessian序列化。Hessian序列化是一种支持动态类型、跨语言、基于对象
传输的网络协议。Java对象序列化的二进制流可以被其他语言(如C++、Python) 反
序列化。Hessian协议具有如下特性：

- 自描述序列化类型。不依赖外部描述文件或接口定义，用一个字节表示常用基础类型，极大缩短二进制流

- 语言无关，支持脚本语言

- 协议简单，比Java原生序列化高效

相比Hessian 1.0，Hessian 2.0中增加了压缩编码，其序列化二进制流大小是Java
序列化的50%，序列化耗时是Java序列化的30%，反序列化耗时是Java反序列化的
20%

Hessian会把复杂对象所有属性存储在一个Map中进行序列化。所以在父类、子
类存在同名成员变量的情况下，Hessian序列化时，先序列化子类，然后序列化父类，
因此反序列化结果会导致子类同名成员变量被父类的值覆盖

(3) JSON序列化。JSON (JavaScript Object Notation)是一种轻量级的数据交
换格式。JSON 序列化就是将数据对象转换为JSON字符串。在序列化过程中拋弃了
类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，
JSON可读性比较好，方便调试

序列化通常会通过网络传输对象，而对象中往往有敏感数据，所以序列化常常
成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序
列化的过程中执行任意代码。Java工程中广泛使用的Apache Commons Collections、
Jackson、fastison等都出现过反序列化漏洞。如何防范这种黑客攻击呢?有些对象的
敏感属性不需要进行序列化传输，可以加transient关键字，避免把此属性信息转化为
序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方
式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的
安全防范意识，对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受
到攻击

##### 2.4 方法
###### 2.4.1 方法签名
方法签名包括方法名称和参数列表，是JVM标识方法的唯一索引，不包括返回值，
更加不包括访问权限控制符、异常类型等。假如返回值可以是方法签名的一部分， 仅
从代码可读性角度来考虑，如下示例：
```java
long f() {
    return 1L;
}

double f() {
    return 1.0d;
}

var a = f();
```
那么类型推断的var到底是接收1.0d还是1L?从静态阅读的角度，根本无从知
道它调用的是哪个方法

###### 2.4.2 参数
在高中数学中计算函数f(x,y) = x^2 + 2y - 3，将x=3，y=7代入公式得到3^2+2*7 -
3=20，这里f(x,y)的x与y就是形式参数，简称形参；而3与7是实际参数，简称实
参。参数是自变量，而f(x,y)函数，即代码中的方法是因变量，是一个逻辑执行的结果。
参数又叫parameter，在代码注释中用 @param表示参数类型。参数在方法中，属于方
法签名的一部分，包括参数类型和参数个数，多个参数用逗号相隔，在代码风格中，
约定每个逗号后必须要有一个空格，不管是形参，还是实参。形参是在方法定义阶段，
而实参是在方法调用阶段，先来看看实参传递给形参的过程：
```java
public class ParamPassing {
    private static int intStatic = 222;
    private static String stringStatic = "old string";
    private static StringBuilder stringBuilderStatic = new StringBuilder("old stringBuilder");

    public static void main(String[] args) {
        // 实参调用
        method(intStatic);
        method(stringStatic);
        method(stringBuilderStatic, stringBuilderStatic);
        
        // 输出依然是222(第1处)
        System.out.println(intStatic);
        method();
        // 无参方法调用之后，反面修改为888(第2处)
        System.out.println(intStatic);
        // 输出依然是: old string
        System.out.println (stringStatic);
        // 输出结果参考下方分析
        System.out.println(stringBuilderStatic);
    }

    // A方法
    public static void method(int intStatic) {
        intStatic = 777;
    }
    
    // B方法
    public static void method() {
        intStatic = 888;
    }
    
    // C方法
    public static void method(String stringStatic) {
        // String是immutable对象，String没有提供任何方法用于修改对象
        stringStatic = "new string";
    }
    
    // D方法
    public static void method(StringBuilder stringBuilderStatic1, StringBuilder stringBuilderStatic2) {
        // 直接使用参数引用修改对象(第3处)
        stringBuilderStatic1.append(".method.first-");
        stringBuilderStatic2.append("method.second-");
        
        // 引用重新赋值
        stringBuilderStatic1 = new StringBuilder("new stringBuilder");
        stringBuilderStaticl.append("new method's append");
    }
}
```
如果不了解形参与实参的传递方式，对于第1处和第2处是存在疑问的。第1处，
通过有参方法执行intStatic=777， 居然没有修改成功，而使用无参的method方法却成
功地把静态变量intStatic的值修改为888。字节码实现如图2-6所示

有参的A方法字节码如图2-6(a)所示，参数是局部变量，拷贝静态变量的
777，并存入虚拟机栈中的局部变量表的第一个小格子内。 虽然在方法内部的intStatic
与静态变量同名，但是因为作用域就近原则，它是局部变量的参数，所有的操作与静
态变量是无关的。而无参的B方法字节码如图2-6(b)所示，先把本地赋值的888
压入虚拟机栈中的操作栈，然后给静态变量intStatic赋值。有两个参数的D方法中，
我们再分析第3处StringBuilder的疑问：
```java
public static method(Ljava/lang/StringBuilder;Ljava/lang/StringBuilder;)V
  L0
    ALOAD 0 
    LDC ".method.first"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
  L1
    ALOAD 1
    LDC "method.second"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
  L2
    NEW java/lang/StringBuilder
    DUP
    LDC "new stringBuilder"
    INVOKESPECIAL java/1ang/StringBuilder.<init> (Ljava/lang/String;)V
    ASTORE 0
  L3
    ALOAD 0
    LDC "new method's append"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
    RETURN
```
注意上述字节码中的两个ALOAD 0，是把静态变量的引用赋值给虛拟机栈的栈
帧中的局部变量表，然后ALOAD操作是把两个对象引用变量压入操作栈的栈顶。注
意，这两个引用都指向了静态引用变量指向的new StringBuilder("old stringBuilder")对
象在method(stringBuilderStatic, stringBuilderStatic) 的执行结果后的值，其中红绿字符
串分别是两次append的结果：

old stringBuilder<font color="red">.method.first-</font><font color="green">method.second-</font> 

在D方法中，new出来一个新的StringBuilder对象，赋值给stringBuilderStatic1。
注意，这是一个新的局部引用变量，使用ASTORE命令对局部变量表的第一个位
置的引用变量值进行了覆盖，然后再重新进行ALOAD到操作栈顶，所以后续对于
stringBuilderStatic1的append操作，与类的静态引用变量stringBuilderStatic没有任何
关系

综上所述，无论是对于基本数据类型，还是引用变量，Java 中的参数传递都是值
复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引
用变量修改指向对象的相关属性

再来介绍一种特殊的参数一可变参数。它是在JDK5版本中引入的，主要为了
解决当时的反射机制和printf方法问题，适用于不确定参数个数的场景。可变参数通
过“参数类型...”的方式定义，如PrintStream类中printf方法使用了可变参数：
```java
public PrintStream printf (String format, Object... args) {
    return format(format, args);
}
// 调用printf方法示例
System.out.printf("%d", n);  // (第1处)
System.out.printf("%d %s", n, "something");  //(第2处)
```
如上示例代码，虽然第1处调用传入了两个参数，第2处调用传入了三个参数，
但它们调用的都是printf(String format, Object... args) 方法。看上去可变参数使方法调
用更简单，省去了手工创建数组的麻烦。有人说可变参数是语法糖，个人觉得是恶魔
果实。如果在实际开发过程中使用不当，会严重影响代码的可读性和可维护性。因此，
使用时要谨慎小心，尽量不要使用可变参数编程。如果一定要使用，则只有相同参数
类型，相同业务含义的参数才可以，并且一个方法中只能有一个可变参数，且这个可
变参数必须是该方法的最后一个参数。 此外，建议不要使用Object 作为可变参数，如
下警示代码：
```java
public static void listUsers(Object... args) {
    System.out.println(args.length);
}
public static void main(String[] args) {
    // 以下代码输出结果为: 3
    listUsers(1, 2, 3);
    // 以下代码输出结果为: 1
    listUsers(new int[] {1, 2，3});
    // 以下代码输出结果为:2 (第1处)
    listUsers(3，new String[] {"1"， "2"});
    // 以下代码输出结果为:3 ( 第2处)
    listUsers(new Integer[] {1, 2, 3});
    // 以下代码输出结果为:2 (第3处)
    listUsers(3，new Integer[] {1, 2, 3});
}
```
通过上面的例子可以看到，使用Object作为可变参数时过于灵活，类型转换场
景不好预判，比如第2处和第3处中Integer[]可以转型为Object[]，也可以作为一个
Object对象，所以导致第2处输出结果为3，第3处输出结果为2。而int[]只能被当
作一个单纯的Object对象。同时Object又很容易破坏“可变参数具备相同类型，相
同业务含义”这个大前提，如上例中第1处的整型和字符串数组类型混用，因此要避
免使用Object作为可变参数

以上是参数定义的相关内容，那么如何正确地使用参数呢?方法定义方并不能保
证调用方会按照预期传入参数，因此在方法体中应该对传入的参数保持理性的不信任。
方法的第一步骤并不是功能实现，而应该是参数预处理。参数预处理包括两种：

(1) 入参保护。虽然“入参保护”被提及的频率和认知度远低于参数校验，但
是其重要性却不能被忽略。入参保护实质上是对服务提供方的保护，常见于批量接口。
虽然批量接口能处理一批数据， 但其处理能力并不是无限的，因此需要对入参的数据
量进行判断和控制，如果超出处理能力，可以直接返回错误给客户端。某业务曾发生
过一个严重故障，就是由一个用户批量查询的接口导致的。虽然在API文档中约定了
每次最多支持查询的用户ID个数，但在接口实现中没有做任何入参保护，导致当调
用方传入万级的用户ID集合查询信息时，服务器内存被塞满，再无任何处理能力

(2) 参数校验。参数作为方法间交互和传递信息的媒介，其重要性不言而喻。
基于防御式编程理念，在方法内，无论是对方法调用方传入参数的理性不信任，还是
对参数有效值的检测都是非常有必要的。但是，由于方法间交互是非常频繁的，如果
所有方法都进行参数校验，就会导致重复代码及不必要的检查影响代码性能。综合两
个方面考虑，汇总需要进行参数校验和无须处理的场景

需要进行参数校验的场景：

- 调用频度低的方法
- 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但
如果因为参数错误导致中间执行回退或者错误，则得不偿失
- 需要极高稳定性和可用性的方法
- 对外提供的开放接口
- 敏感权限入口

不需要进行参数校验的场景：
- 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查
- 底层调用频度较高的方法。参数错误不太可能到底层才会暴露问题。一般
DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以可以
省略DAO的参数校验
- 声明成private只会被自己代码调用的方法。如果能够确定调用方法的代码传
入参数已经做过检查或者肯定不会有问题，此时可以不校验参数

###### 2.4.3 构造方法
构造方法(Constructor)是方法名与类名相同的特殊方法，在新建对象时调用，
可以通过不同的构造方法实现不同方式的对象初始化，它有如下特征：

(1) 构造方法名称必须与类名相同

(2) 构造方法是没有返回类型的，即使是void也不能有。它返回对象的地址，
并赋值给引用变量

(3) 构造方法不能被继承，不能被覆写，不能被直接调用。调用途径有三种：
一是通过new关键字，二是在子类的构造方法中通过super调用父类的构造方法，三
是通过反射方式获取并使用

(4) 类定义时提供了默认的无参构造方法。但是如果显式定义了有参构造方法，
则此无参构造方法就会被覆盖；如果依然想拥有，就需要进行显式定义

(5) 构造方法可以私有。外部无法使用私有构造方法创建对象

在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在，它可以定义，但不能加public修饰，因为它默认是private的，是绝对的单例，
不允许外部以创建对象的方式生成枚举对象

一个类可以有多个参数不同的构造方法，称为构造方法的重载。为了方便阅读，
当一个类有多个构造方法时，这些方法应该被放置在一起。 同理，类中的其他同名方
法也应该遵循这个规则

单一职责，对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参
操作，所以不应该在构造方法中引入业务逻辑。如果在一个对象生产中， 需要完成初
始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤
出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件
不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如init()，当对象
确认完成所有初始化工作之后，再显式调用

类中的static{...}代码被称为类的静态代码块，在类初始化时执行，优先级很高。
下面看一下父子类静态代码块和构造方法的执行顺序：
```java
class Son extends Parent {
    static { System.out.println("Son 静态代码块"); }
    Son() { System.out.println("Son 构造方法"); }
    
    public static void main(String[] args) {
        new Son();
        new Son();
    }
}

class Parent {
    static { System.out.println("Parent 静态代码块"); }
    public Parent() { System.out.println("Parent 构造方法"); }
}
```
执行结果如下:
```text
Parent 静态代码块
Son 静态代码块
Parent 构造方法
Son 构造方法
Parent 构造方法
Son 构造方法
````
从以上示例可看出，在创建类对象时，会先执行父类和子类的静态代码块，然后
再执行父类和子类的构造方法。并不是执行完父类的静态代码块和构造方法后，再去
执行子类。静态代码块只运行一次，在第二次对象实例化时，不会运行

###### 2.4.4 类内方法
在面向过程的语言中，几乎所有的方法都是全局静态方法，在引入面向对象理念
之后，某些方法才归属于具体对象，即类内方法。构造方法无论是有形、无形、私有、
公有，在一个类中是必然存在的。除构造方法外，类中还可以有三类方法：实例方法、
静态方法、静态代码块

1. 实例方法

又称为非静态方法。实例方法比较简单，它必须依附于某个实际对象，并可以通
过引用变量调用其方法。类内部各个实例方法之间可以相互调用，也可以直接读写类
内变量，但是不包含this。当.class 字节码文件加载之后，实例方法并不会被分配方
法入口地址，只有在对象创建之后才会被分配。实例方法可以调用静态变量和静态方
法，当从外部创建对象后，应尽量使用“类名.静态方法"来调用，而不是对象名，
一来为编译器减负，二来提升代码可读性

2. 静态方法

又称为类方法。当类加载后，即分配了相应的内存空间，由于生命周期的限制，
使用静态方法需要注意两点：

(1) 静态方法中不能使用实例成员变量和实例方法

(2) 静态方法不能使用super和this关键字，这两个关键字指代的都是需要被
创建出来的对象

通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，那
么在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的

3. 静态代码块

在代码的执行方法体中，非静态代码块和静态代码块比较特殊。非静态代码块又
称为局部代码块，是极不推荐的处理方式，本节不再展开。而静态代码块在类加载的
时候就被调用，并且只执行一次。静态代码块是先于构造方法执行的特殊代码块。静
态代码块不能存在于任何方法体内，包括类静态方法和属性变量。观察如下示例代码：





###### 2.4.5 getter与setter






###### 2.4.6 同步与异步






###### 2.4.7 覆写






##### 2.5 重载






##### 2.6 泛型






##### 2.7 数据类型






###### 2.7.1 基本数据类型







###### 2.7.2 包装类型







###### 2.7.3 字符串


























