#### 第2章 面向对象
本章开始讲解面向对象思想，并以Java为载体讲述面向对象思想在具体编程语
言中的运用与实践。当前主流的编程语言有50种左右，主要分为两大阵营：面向对
象编程与面向过程编程

面向对象编程( Object-Oriented Programming, OOP )是划时代的编程思想变革，
推动了高级语言的快速发展和工业化进程。OOP的抽象、封装、继承、多态的理念
使软件大规模化成为可能，有效地降低了软件开发成本、维护成本和复用成本。面向
对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像搭积木一
样隔离可控、高效简单，是当今编程领域的一股势不可当的潮流。OOP实践了软件
工程的三个主要目标：可维护性、可重用性和可扩展性

##### 2.1 OOP理念
面向过程让计算机有步骤地顺次做一件事情，是一种过程化的叙事思维。但是在
大型软件开发过程中，发现用面向过程语言开发，软件维护、软件复用存在着巨大的
困难，代码开发变成了记流水账，久而久之就成为“面条”代码，模块之间互相耦合，
流程互相穿插，往往牵一发而动全身。面向对象提出一种计算机世界里解决复杂软件
工程的方法论，拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案

但是，编程语言仅是一个工具，就像练武之人的剑，武功高者草木皆剑，武功差
者即使莫邪剑在身也依然平庸。所以，能否将工具的价值发挥得淋漓尽致，最终还是
取决于开发工程师本身。优秀的开发工程师用面向过程的语言也能把程序写得非常内
聚，可扩展性好，具备一定的复用性；而平庸程序员用面向对象语言一样能把程序写
得松散随意、毫无抽象与建模、模块间耦合严重、维护性差

传统意义上，面向对象有三大特性：封装、继承、多态。本书明确将“抽象”作
为面向对象的特性之一，支持面向对象“四大特性”的说法。抽象是程序员的核心素
质之一，体现出程序员对业务的建模能力，以及对架构的宏观掌控力。虽然面向过程
也需要进行一定的抽象能力，但是相对来说，面向对象思维，以对象模型为核心，丰
富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象
能力显得尤为重要；封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，
更具有维护性；继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有
复用性；多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间

抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力
是后续的封装、继承、多态的基础，是软件大厦的基石。在面向对象的思维中，抽象
分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行
归一化的逻辑思维过程；后者则是从本质到具体，从共性到个性，逐步形象化的过程。
在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已
有问题解决方案的基础上，正确地找到合适的使用场景。演绎错误在使用集合时比较
常见，比如针对查多改少的业务场景，使用链表是非常不合理的；底层框架技术选型
时如果有错误，则有可能导致技术架构完全不适应业务的快速发展

Java之父Gosling 设计的Object类，是任何类的默认父类，是对万事万物的抽象，
是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知
道哲学的三大经典问题：我是谁，我从哪里来，我到哪里去。在Object类中，这些问
题都可以得到隐约的解答：

(1) 我是谁? getClass()说明本质上是谁，而toString()是当前职位的名片

(2) 我从哪里来? Object()构造方法是生产对象的基本步骤，clone()是繁殖对
象的另一种方式

(3) 我到哪里去? finalize()是在对象销毁时触发的方法

这里重点介绍clone()方法，它分为浅拷贝、一般深拷贝和彻底深拷贝。浅拷贝
只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指
向的实际对象；而彻底深拷贝是在成功clone一个对象之后，此对象与母对象在任何
引用路径上都不存在共享的实例对象，但是引用路径递归越深，则越接近JVM底层
对象，且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深
拷贝。归根结底，慎用Object的clone()方法来拷贝对象，因为对象的clone() 方法默
认是浅拷贝，若想实现深拷贝，则需要覆写clone() 方法实现引用对象的深度遍历式
拷贝

另外，Object还映射了社会科学领域的一些问题：

(1) 世界是否因你而不同?hashCode()和equals()就是判断与其他元素是否相
同的一组方法

(2) 与他人如何协调? wait()和notify()是对象间通信与协作的一组方法

随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如finalize()
方法在JDK9之后直接被标记为过时方法。而wait()和notify()同步方式事实上已经
被同步信号、锁、阻塞集合等取代

封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的
方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，
具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部
敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感
方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。封装使面向对象的世
界变得单纯，对象之间的关系变得简单，各人自扫门前雪，耦合度变弱，有利于维护。
智能化的时代，对封装的要求越来越高，产品使用更加简单方便、轻松自然。就像天
猫精灵，唯一的接口就是语音输入，隐藏了指令内部的细节实现和相关数据，使外部
用户无法访问，大大降低了使用成本，有效地保护内部数据安全

设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A模块使用
B模块的某个接口行为，对B模块中除此行为之外的其他信息知道得尽可能少。比如：
耳塞的插孔就是提供声音输出的行为接口，只需关心这个插孔是否有相应的耳塞标记，
是否是圆形的，有没有声音即可，至于内部CPU如何运算音频信息，以及各个电容
如何协同工作，根本不需要去关注，这使模块之间的协作只需忠于接口、忠于功能实
现即可

封装这件事情是由俭入奢易，由奢入俭难。属性值的访问与修改需要使用相应的
getter/setter方法，而不是直接对public的属性进行读取和修改，可能有些程序员存在
疑问，既然通过这两个方法来读取和修改，那与直接对属性进行操作有何区别?如果
某一天，类的提供方想在修改属性的setter方法上进行鉴权控制、日志记录，这是在
直接访问属性的情形中无法做到的。若是将已经公开的属性和行为直接暴力修改为
private，则依赖模块都会编译出错。所以，在不知道什么样的访问控制权限合适的时候，
优先推荐使用private控制级别

继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系，形成一
个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复
用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有
层次感，更有扩展性，为多态打下语法基础

人人都说继承是is-a关系，那么如何衡量当前的继承关系是否满足is-a关系呢?
判断标准即是否符合里氏代换原则(Liskov Substitution Principle，LSP)。LSP是指
任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方，
警察在枪战片中经常说：放下武器，把手举起来！而对面的匪徒们有的使用手枪，有
的使用匕首，这些都是武器的子类。父类出现的地方，即“放下武器”，那么，放下
手枪，是对的，放下匕首，也是对的!在实际代码环境中，如果父类引用直接使用子
类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个
类之间符合LSP原则，可以使用继承关系

继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。
想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样容易被滥
用，我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆
炸。方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为
的能力，比如鸟会飞，鸵鸟继承鸟，发现飞不了，这就是方法污染。子类继承父类，
则说明子类对象可以调用父类对象的一切行为。在这样的情况下，总不能在继承时，
添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方
法，抛出异常，以阻止别人的调用。方法爆炸是指继承树不断扩大，底层类拥有的方
法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，
很容易在实际编程中产生选择困难症。比如某些综合功能的类，经过多次继承后达到
上百个方法，造成了方法爆炸，因而带来使用不便和安全隐患。在实际故障中，因为
方法爆炸，父类的某些方法签名和子类非常相似，在IDE中，输入类名+点之后，
在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述，提倡组合
优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而
不是继承

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态是面向对象天空
中绚丽多彩的礼花，提升了对象的扩展能力和运行时的丰富想象力。我们来明确两个
非常容易混淆的概念：“override”和“overload"，"override"译成“覆写”，是子
类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直
方向上行为的不同实现。“overload”译成“重载”，方法名称是相同的，但是参数
类型或参数个数是不相同的，是水平方向上行为的不同实现。多态是指在编译层面无
法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由JVM进
行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态
绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。自然界的
多态最典型例子就是碳家族，据说某化学家告诉他女朋友将在她的生日晚会上送她一
块碳，女朋友当然不高兴，可收到的却是5克拉的钻石。钻石就是碳元素在不断进化
过程中的一种多态表现。严格意义上来说，多态并不是面向对象的一种特质，而是一
种由继承行为衍生而来的进化能力而已

##### 2.2 初识Java
面向对象编程思想把所有的有形或无形的事物都看作对象，并给对象赋予相应
的属性和行为，建立对象之间的联系，使程序员更加立体、形象地解决编程领域的问
题。面向对象语言的忠实代表是Java语言，它是一门富有生命力的语言，在最受欢
迎的语言排行榜上，多年位居第一。Java语言是1995年由Sun公司首次发布的。次
年Java开发工具包发布，即Java Development Kit，简称JDK1.0，这是Java发展的一
个重要里程碑，标志着Java成为一门独立的成熟语言。随后，Sun 公司再接再厉发布
了Just-in-time编译器，简称JIT，不断进步的JIT技术使Java的执行速度接近甚至超
过其他高级语言

JDK随着时代不断往前发展。在众多版本中，最具划时代影响力的版本是
JDK5，项目代号Tiger。Doug Lea推出的并发包，使Java如虎添翼，成为工业级语言，
在企业服务端得到极为广泛的应用。随着后续版本的陆续推出，Java的发展与时俱进，
推出了diamond语法、函数式、模块化、var 类型推断等新特性。最新的JDK版本是
JDK11

JRE (Java Runtime Environment)即Java运行环境，包括JVM、核心类库、核
心配置工具等。其中JVM (Java Virtual Machine)即Java虚拟机，它是整个Java体
系的底层支撑平台，把源文件编译成平台无关的字节码文件，屏蔽了Java源代码与
具体平台相关的信息，所以Java源代码不需要额外修改即可跨平台运行。JVM不
仅支撑着Java语言，还包括Kotlin、Scala、 Python 等其他流行语言。其中Kotlin 是
Jetbrains开发的跨平台语言,其语法简洁、类型安全,可以编译成字节码运行在JVM上，
与Java语言非常方便地进行混合编程。1999 年，Sun 公司发布公开版本的HotSpot,
它是当前主流的Java虚拟机。2006 年，在JavaOne大会上开源相关核心技术，启动
OpenJDK项目，逐步形成了活跃的OpenJDK社区。在社区的带动下，Java 生态也随
之繁荣，包括AJDK、Spring、 Hadoop、 Dubbo、 JStorm、 RocketMQ 等Java相关解决
方案，极大地提升了Java 语言的生产效率

Java语言拥有跨平台、分布式、多线程、健壮性等主要特点，是当下比较主流的
高级编程语言。它的类库相当丰富、功能强大、简单易用，对开发者相当友好，不仅
吸收了C++的优点，还摒弃了其难以掌控的多继承、指针等概念。Java比较好地实
现了面向对象理论，允许开发工程师以优雅的思维方式处理复杂的编程场景

##### 2.3 类
###### 2.3.1 类的定义
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有public和无访问控制符，类型分
为class、interface、 enum

Java类主要由两部分组成成员和方法。在定义Java类时，推荐首先定义变量，
然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展
示；保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法，因此重要
性仅次于公有方法；而私有方法对外部来说是一个 黑盒实现，因此一般不需要被特别
关注最后是getter/setter方法，虽然它们也是公有方法，但是因为承载的信息价值较低，
一般不包含业务逻辑，所以所有getter/setter方法须放在类最后

###### 2.3.2 接口与抽象类
正如面向对象四大特性(抽象、封装、继承、多态)所述，定义类的过程就是抽
象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行
为和特征。接口与抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例
对象。本节主要分析两者的不同之处，首先从语法上进行区分，如表2-1所示

抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。
与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方
法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等同于一个接口。is-a
关系需要符合里氏代换原则，例如Eagle is a Bird. Bird is an Object。can-do 关系要符
合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为，例如Plane can
fly. Bird can fly.中应该把fly定义成一个接口，而不是把fly()放在某个抽象类中，再
由Plane和Bird利用is-a关系去继承此抽象类。因为严格意义上讲，除fly这个行为外，
在Plane和Bird之间很难找到其他共同特征

抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，
性格偏内向，比如某品牌特定型号的汽车，底盘架构、控制电路、刹车系统等是抽象
出来的共同特征，但根据动感型、舒适型、豪华型的区分，内饰、车头灯、显示屏等
可以存在不同版本的实现。接口是开放的，性格偏外向，它就像一份合同， 定义了方
法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它，但如果想实现它的
类就必须遵守这份接口约定合同，比如，任何类型的车辆都必须实现如下接口：
```java
public interface VehicleSafe {
    /**
    * @param initSpeed 刹车时的初始速度
    * @param brakeTime 从initSpeed开始刹车到停止行驶的时间，单位是毫秒
    * @return 从initSpeed开始刹车到停止行驶的距高
    */
    double brake (int initSpeed, int brakeTime);
}
```
刹车是一个开放式的强制行为规范，任何车辆都必须具有刹车的能力，要明确在
特定初速度的情况下，刹车时间多久，刹车距离多长。此规范对任何车辆都是强约束
的，这就是契约

接口是顶级的“类”，虽然关键字是interface，但是编译之后的字节码扩展名还
是.class。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后
实现部分接口行为，其中AbstractCollection是最典型的抽象类：
```java
public abstract class AbstractCollection<E> implements Collection<E> {
    // Collection定义的抽象方法，但本类没有实现
    // Collection接口定义的方法，size()这个方法对于链表和顺序表有不同的实现方式
    public abstract int size();
    
    // 实现Collection接口的这个方法，因为对AbstractCollection的子类
    // 它们判空的方式是一致的，这就是模板式设计，对干所有它的子类，实现共同的方法体，
    // 通过多态调用到子类的具体size()实现
    public boolean isEmpty() {
        //实现Collection的方法
        return size() == 0;
    }
    
    //其他属性和部分方法实现....
}
```
Java语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚
至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的
绑定机制会变得非常复杂。接口继承接口，关键字是extends，而不是implements，
允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实
体类在实现多重继承后的接口时，只是说明"can do many things"。当纠结定义接口
还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接
口，然后再用抽象类去implements某些接口，这样做可方便后续的扩展和重构

###### 2.3.3 内部类
在一个.java源文件中，只能定义一个类名与文件名完全一致的公开类，使用
public class关键字来修饰。但在面向对象语言中，任何一个类都可以在内部定义另外
一个类，前者为外部类，后者为内部类。内部类本身就是类的一个属性，与其他属性
定义方式一致。 比如，属性字段private static String str，由访问控制符、是否静态、类型、
变量名组成，而内部类private static class Inner{}，也是按这样的顺序来定义的，类型
可以为class、enum，甚至是interface，当然在内部类中定义接口是不推荐的。内部类
可以是静态和非静态的，它可以出现在属性定义、方法体和表达式中，甚至可以匿名
出现，具体分为如下四种

- 静态内部类，如： static class StaticInnerClass{};

- 成员内部类，如:：private class InstanceInnerClass{};

- 局部内部类，定义在方法或者表达式内部;

- 匿名内部类，如： (new Thread(){}).start()

如下是最精简的4种内部类定义方式：
```java
public class OuterClass {
    // 成员内部类
    private class InstanceInnerClass {}
    // 静态内部类
    static class StaticInnerClass {}
    
    public static void main(String[] args) {
        // 两个匿名内部类，分别对应图2-1所示的OuterClass$1和OuterClasss2
        (new Thread() {}).start();
        (new Thread() {}).start();
        
        // 两个方法内部类，分别对应图2-1所示的OuterClasss1MethodClass1和
        // OuterClass$1MethodClass2
        class MethodClass1 {}
        class MethodClass2 {}
    }
}
```
无论是什么类型的内部类，都会编译成一个独立的.class文件，如图2-1所示

外部类与内部类之间使用$符号分隔，匿名内部类使用数字进行编号，而方法内
部类，在类名前还有一个编号来标识是哪个方法。匿名内部类和静态内部类是比较常
用的方式。在本书的示例代码中经常使用匿名类来启动线程，节约了若干行代码。而
静态内部类是最常用的内部表现形式，外部可以使用OuterClass.StaticInnerClass直接
访问，类加载与外部类在同一个阶段进行，在JDK源码中，定义包内可见静态内部
类的方式很常见，这样做的好处是：

(1) 作用域不会扩散到包外

(2) 可以通过“外部类.内部类”的方式直接访问

(3) 内部类可以访问外部类中的所有静态属性和方法

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K, V> next;
}
```
如上所示的源码是在ConcurrentHashMap中定义的Node静态内部类，用于
表示一个节点数据，属于包内可见，包内其他集合要用到这个Node时，直接使用
ConcurrentHashMap.Node。仅包内可见，可以阻止外部程序随意使用此类来生成对
象，Node的父类Entry是Map的静态内部类，之所以可以被Node成功继承，是
因为两个外部类同属一个包。在JDK源码中，使用内部类封装某种属性和操作的
方式比较常见，比如应用类加载器Launcher的AppClassLoader， ReentrantLock 中
继承自AbstractQueuedSynchronizer的内部类Sync，ArrayList中的私有静态内部类
SubList。内部类中还可以定义内部类，形成多层嵌套，如在ThreadLocal静态内部类
ThreadLocalMap中还定义一个内部类Entry，如图2-2所示

因为访问权限可见，所以在同一包内的Thread可以直接使用如下方式声明自己
的属性：
```java
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

###### 2.3.4 访问权限控制
面向对象的核心思想之一就是封装， 只把有限的方法和成员公开给别人，这也是
迪米特法则的内在要求，使外部调用方对方法体内的实现细节知道得尽可能少。如何
实现封装呢?需要使用某些关键字来限制类外部对类内属性和方法的随意访问，这些
关键字就是访问权限控制符。在详细介绍访问权限之前，我们明确一个概念——是否
可见，如下示例代码：
```java
package a;
public class VisibleScope {
    public void publicMethod() {}
    protected void protectedMethod() {}
    void noneMethod() {}
    private void privateMethod() {}
}
```
在package b中，图2-3左侧对VisibleScope类进行实例化，通过引用变量，仅
能看到publicMethod()方法，我们称为publicMethod()方法是当前可见的；使用同一
个类，图2-3右侧对VisibleScope子类VisibleScopeInvoke进行实例化，通过引用变量，
可以看到两个方法，新增了红色框内的protectedMethod()方法，那么这两个方法是当
前可见的；如果这个类也在package a中，那么noneMethod是可见的；在任何情况下，
类外部实例化出来的对象均无法调用私有方法，比如本示例中的privateMethod方法

- public：可以修饰外部类、属性、方法，表示公开的、无限制的，是访问限
制最松的一级,被其修饰的类、属性和方法不仅可以被包内访问，还可以跨类、
跨包访问，甚至允许跨工程访问

- protected：只能修饰属性和方法，表示受保护的、有限制的，被其修饰的属
性和方法能被包内及包外子类访问。注意，即使并非继承关系，protected 属
性和方法在同一包内也是可见的

- 无：即无任何访问权限控制符，如示例中的noneMethod方法，没有任何
修饰符。千万不要说成default，它并非访问权限控制符的关键字，另外，在
JDK8接口中引入default默认方法实现，更加容易混淆两者释义。无访问权
限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚；要么定
义公开类，即public class，包外也可以实例化

- private：只能修饰属性、方法、内部类。表示“私有的”，是访问限制最严
格的一-级，被其修饰的属性或方法只能在该类内部访问，子类、包内均不能
访问，更不允许跨包访问

由此可见，不同的访问权限控制符对应的可见范围不同。在定义类时，要慎重思
考该方法、属性、内部类的访问权限，提倡严控访问范围。过于宽泛的访问范围不利
于模块间解耦及未来的代码维护。试想，在进行代码重构时，private方法过旧，我们
可以直接删除，且无后顾之忧。可是如果想删除一个public的方法，是不是要谨慎又
谨慎地检查是否被调用。变量就像自己的小孩，要尽量控制在自己的视线范围内，如
果作用域太大，无限制地到处乱跑，就会担心其安危。因此，在定义类时，推荐访问
控制级别从严处理：

(1) 如果不允许外部直接通过new创建对象，构造方法必须是private

(2) 工具类不允许有public或default构造方法

(3) 类非static成员变量并且与子类共享，必须是protected

(4) 类非static成员变量并且仅在本类使用，必须是private

(5 )类static成员变量如果仅在本类使用，必须是private

(6 )若是static成员变量，必须考虑是否为final

(7) 类成员方法只供类内部调用，必须是private

(8) 类成员方法只对继承类公开，那么限制为protected

###### 2.3.5 this与super
对象实例化时，至少有一条从本类出发抵达Object的通路，而打通这条路的两
个主要工兵就是this和super，逢山开路，遇水搭桥。但是this和super往往是默默无
闻的，在很多情况下可以省略，比如：

- 本类方法调用本类属性

- 本类方法调用另一个本类方法

- 子类构造方法隐含调用super()

任何类在创建之初，都有一个默认的空构造方法，它是super()的一条默认通路。
构造方法的参数列表决定了调用通路的选择；如果子类指定调用父类的某个构造方法，
super就会不断往上溯源；如果没有指定，则默认调用super()。如果父类没有提供默
认的构造方法，子类在继承时就会编译错误，如图2-4所示

如果父类坚持不提供默认的无参构造方法，必须在本类的无参构造方法中使用
super方式调用父类的有参构造方法，如public Son(){ super(123); }

一个实例变量可以通过this.赋值另一个实例变量；一个实例方法可以通过this.
调用另一个实例方法；甚至一个构造方法都可以通过this.调用另一个构造方法。如
果this和super指代构造方法，则必须位于方法体的第一行。换句话说，在一个构造
方法中，this和super只能出现一个，且只能出现一次，否则在实例化对象时，会因
子类调用到多个父类构造方法而造成混乱

由于this和super都在实例化阶段调用，所以不能在静态方法和静态代码
块中使用this和super关键字。this还可以指代当前对象，比如在同步代码块
synchronized(this)...}中，super并不具备此能力。但super也有自己的特异功能，在
子类覆写父类方法时，可以使用super调用父类同名的实例方法。最后总结一下this
和super的异同点，如图2-5所示

###### 2.3.6 类关系
关系是指事物之间存在单向或相互的作用力或者影响力的状态。类与类之间的关
系可分成两种：有关系与没关系，这似乎是一句非常正确的废话，难点在于确定类与
类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问
题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了
没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。有关系的
情况下，包括如下5种类型：

- [继承 ] extends (is-a)

- [实现] implements (can-do)

- [组合] 类是成员变量(contains-a)

- [聚合] 类是成员变量(has-a)

- [依赖] import类(use-a)

继承和实现是比较容易理解的两种类关系。在架构设计中，要注意组合、聚合和
依赖这三者的区别

组合在汉语中的含义是把若干个独立部分组成整体，各个部分都有其独立的使用
价值和生命周期。而类关系中的组合是一种完全绑定的关系， 所有成员共同完成一件
使命，它们的生命周期是一样的。组合体现的是非常强的整体与部分的关系，同生共
死，部分不能在整体之间共享

聚合是一种可以拆分的整体与部分的关系，是非常松散的暂时组合，部分可以被
拆出来给另一个整体

依赖是除组合和聚合外的类与类之间的关系，这个类只要import，那就是依赖关系

在类图中，用空心的三角形表示继承，用实心的菱形表示组合，用空心的菱形表
示聚合，这三者都是用实线连接的。用三角形来表示实现，用一个箭头表示依赖，与
前面的区别是这两者都是用虚线连接的。在画类图时，菱形、箭头、三角形放在哪一
侧呢?在很多类图中，这个处理是非常随意的。如果方向画反了，那么类结构的认知
也就反了。有一个规律，有形状的图形符号一律放在权力强的这一侧，如表2-3所示

随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待
类图。比如表2-3中的Body和Head，如果有一天，动物的脑袋可以随意地移植，那
么就从组合关系变成聚合关系了。狗与狗绳之间的约束，虽然很弱，但是如果防疫局
在狗绳上标记疫苗记录，那么它们之间的关系就会变强，就变成组合关系了。在业务
重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一
种演变

###### 2.3.7 序列化
内存中的数据对象只有转换为二进制流才可以进行数据持久化和网络传输。将数
据对象转换为二进制流的过程称为对象的序列化(Serialization)。反之，将二进制流
恢复为数据对象的过程称为反序列化(Deserialization)。序列化需要保留充分的信息
以恢复数据对象，但是为了节约存储空间和网络带宽，序列化后的二进制流又要尽可
能小。序列化常见的使用场景是RPC框架的数据传输。常见的序列化方式有三种：

(1) Java原生序列化。Java类通过实现Serializable接口来实现该类对象的序列化，
这个接口非常特殊；没有任何方法，只起标识作用。Java 序列化保留了对象类的元数
据(如类、成员变量、继承类信息等)，以及对象数据等，兼容性最好，但不支持跨
语言，而且性能一般

实现Serializable接口的类建议设置serialVersionUID 字段值，如果不设置，那么
每次运行时，编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自
动生成serialVersionUID。如果类的源代码有修改，那么重新编译后serialVersionUID
的取值可能会发生变化。因此实现Serializable接口的类一定要显式地定义
serialVersionUID属性值。修改类时需要根据兼容性决定是否修改serialVersionUID值：

- 如果是兼容升级，请不要修改serialVersionUID字段，避免反序列化失败

- 如果是不兼容升级，需要修改serialVersionUID值，避免反序列化混乱

使用Java原生序列化需注意，Java反序列化时不会调用类的无参构造方法，而
是调用native方法将成员变量赋值为对应类型的初始值。基于性能及兼容性考虑，不
推荐使用Java原生序列化

(2) Hessian序列化。Hessian序列化是一种支持动态类型、跨语言、基于对象
传输的网络协议。Java对象序列化的二进制流可以被其他语言(如C++、Python) 反
序列化。Hessian协议具有如下特性：

- 自描述序列化类型。不依赖外部描述文件或接口定义，用一个字节表示常用基础类型，极大缩短二进制流

- 语言无关，支持脚本语言

- 协议简单，比Java原生序列化高效

相比Hessian 1.0，Hessian 2.0中增加了压缩编码，其序列化二进制流大小是Java
序列化的50%，序列化耗时是Java序列化的30%，反序列化耗时是Java反序列化的
20%

Hessian会把复杂对象所有属性存储在一个Map中进行序列化。所以在父类、子
类存在同名成员变量的情况下，Hessian序列化时，先序列化子类，然后序列化父类，
因此反序列化结果会导致子类同名成员变量被父类的值覆盖

(3) JSON序列化。JSON (JavaScript Object Notation)是一种轻量级的数据交
换格式。JSON 序列化就是将数据对象转换为JSON字符串。在序列化过程中拋弃了
类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，
JSON可读性比较好，方便调试

序列化通常会通过网络传输对象，而对象中往往有敏感数据，所以序列化常常
成为黑客的攻击点，攻击者巧妙地利用反序列化过程构造恶意代码，使得程序在反序
列化的过程中执行任意代码。Java工程中广泛使用的Apache Commons Collections、
Jackson、fastison等都出现过反序列化漏洞。如何防范这种黑客攻击呢?有些对象的
敏感属性不需要进行序列化传输，可以加transient关键字，避免把此属性信息转化为
序列化的二进制流。如果一定要传递对象的敏感属性，可以使用对称与非对称加密方
式独立传输，再使用某个方法把属性还原到对象中。应用开发者对序列化要有一定的
安全防范意识，对传入数据的内容进行校验或权限控制，及时更新安全漏洞，避免受
到攻击

##### 2.4 方法
###### 2.4.1 方法签名
方法签名包括方法名称和参数列表，是JVM标识方法的唯一索引，不包括返回值，
更加不包括访问权限控制符、异常类型等。假如返回值可以是方法签名的一部分， 仅
从代码可读性角度来考虑，如下示例：
```java
long f() {
    return 1L;
}

double f() {
    return 1.0d;
}

var a = f();
```
那么类型推断的var到底是接收1.0d还是1L?从静态阅读的角度，根本无从知
道它调用的是哪个方法

###### 2.4.2 参数
在高中数学中计算函数f(x,y) = x^2 + 2y - 3，将x=3，y=7代入公式得到3^2+2*7 -
3=20，这里f(x,y)的x与y就是形式参数，简称形参；而3与7是实际参数，简称实
参。参数是自变量，而f(x,y)函数，即代码中的方法是因变量，是一个逻辑执行的结果。
参数又叫parameter，在代码注释中用 @param表示参数类型。参数在方法中，属于方
法签名的一部分，包括参数类型和参数个数，多个参数用逗号相隔，在代码风格中，
约定每个逗号后必须要有一个空格，不管是形参，还是实参。形参是在方法定义阶段，
而实参是在方法调用阶段，先来看看实参传递给形参的过程：
```java
public class ParamPassing {
    private static int intStatic = 222;
    private static String stringStatic = "old string";
    private static StringBuilder stringBuilderStatic = new StringBuilder("old stringBuilder");

    public static void main(String[] args) {
        // 实参调用
        method(intStatic);
        method(stringStatic);
        method(stringBuilderStatic, stringBuilderStatic);
        
        // 输出依然是222(第1处)
        System.out.println(intStatic);
        method();
        // 无参方法调用之后，反面修改为888(第2处)
        System.out.println(intStatic);
        // 输出依然是: old string
        System.out.println (stringStatic);
        // 输出结果参考下方分析
        System.out.println(stringBuilderStatic);
    }

    // A方法
    public static void method(int intStatic) {
        intStatic = 777;
    }
    
    // B方法
    public static void method() {
        intStatic = 888;
    }
    
    // C方法
    public static void method(String stringStatic) {
        // String是immutable对象，String没有提供任何方法用于修改对象
        stringStatic = "new string";
    }
    
    // D方法
    public static void method(StringBuilder stringBuilderStatic1, StringBuilder stringBuilderStatic2) {
        // 直接使用参数引用修改对象(第3处)
        stringBuilderStatic1.append(".method.first-");
        stringBuilderStatic2.append("method.second-");
        
        // 引用重新赋值
        stringBuilderStatic1 = new StringBuilder("new stringBuilder");
        stringBuilderStaticl.append("new method's append");
    }
}
```
如果不了解形参与实参的传递方式，对于第1处和第2处是存在疑问的。第1处，
通过有参方法执行intStatic=777， 居然没有修改成功，而使用无参的method方法却成
功地把静态变量intStatic的值修改为888。字节码实现如图2-6所示

有参的A方法字节码如图2-6(a)所示，参数是局部变量，拷贝静态变量的
777，并存入虚拟机栈中的局部变量表的第一个小格子内。 虽然在方法内部的intStatic
与静态变量同名，但是因为作用域就近原则，它是局部变量的参数，所有的操作与静
态变量是无关的。而无参的B方法字节码如图2-6(b)所示，先把本地赋值的888
压入虚拟机栈中的操作栈，然后给静态变量intStatic赋值。有两个参数的D方法中，
我们再分析第3处StringBuilder的疑问：
```java
public static method(Ljava/lang/StringBuilder;Ljava/lang/StringBuilder;)V
  L0
    ALOAD 0 
    LDC ".method.first"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
  L1
    ALOAD 1
    LDC "method.second"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
  L2
    NEW java/lang/StringBuilder
    DUP
    LDC "new stringBuilder"
    INVOKESPECIAL java/1ang/StringBuilder.<init> (Ljava/lang/String;)V
    ASTORE 0
  L3
    ALOAD 0
    LDC "new method's append"
    INVOKEVIRTUAL java/lang/StringBuilder.append (Ljava/lang/String;)
    Ljava/lang/StringBuilder;
    POP
    RETURN
```
注意上述字节码中的两个ALOAD 0，是把静态变量的引用赋值给虛拟机栈的栈
帧中的局部变量表，然后ALOAD操作是把两个对象引用变量压入操作栈的栈顶。注
意，这两个引用都指向了静态引用变量指向的new StringBuilder("old stringBuilder")对
象在method(stringBuilderStatic, stringBuilderStatic) 的执行结果后的值，其中红绿字符
串分别是两次append的结果：

old stringBuilder<font color="red">.method.first-</font><font color="green">method.second-</font> 

在D方法中，new出来一个新的StringBuilder对象，赋值给stringBuilderStatic1。
注意，这是一个新的局部引用变量，使用ASTORE命令对局部变量表的第一个位
置的引用变量值进行了覆盖，然后再重新进行ALOAD到操作栈顶，所以后续对于
stringBuilderStatic1的append操作，与类的静态引用变量stringBuilderStatic没有任何
关系

综上所述，无论是对于基本数据类型，还是引用变量，Java 中的参数传递都是值
复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引
用变量修改指向对象的相关属性

再来介绍一种特殊的参数一可变参数。它是在JDK5版本中引入的，主要为了
解决当时的反射机制和printf方法问题，适用于不确定参数个数的场景。可变参数通
过“参数类型...”的方式定义，如PrintStream类中printf方法使用了可变参数：
```java
public PrintStream printf (String format, Object... args) {
    return format(format, args);
}
// 调用printf方法示例
System.out.printf("%d", n);  // (第1处)
System.out.printf("%d %s", n, "something");  //(第2处)
```
如上示例代码，虽然第1处调用传入了两个参数，第2处调用传入了三个参数，
但它们调用的都是printf(String format, Object... args) 方法。看上去可变参数使方法调
用更简单，省去了手工创建数组的麻烦。有人说可变参数是语法糖，个人觉得是恶魔
果实。如果在实际开发过程中使用不当，会严重影响代码的可读性和可维护性。因此，
使用时要谨慎小心，尽量不要使用可变参数编程。如果一定要使用，则只有相同参数
类型，相同业务含义的参数才可以，并且一个方法中只能有一个可变参数，且这个可
变参数必须是该方法的最后一个参数。 此外，建议不要使用Object 作为可变参数，如
下警示代码：
```java
public static void listUsers(Object... args) {
    System.out.println(args.length);
}
public static void main(String[] args) {
    // 以下代码输出结果为: 3
    listUsers(1, 2, 3);
    // 以下代码输出结果为: 1
    listUsers(new int[] {1, 2，3});
    // 以下代码输出结果为:2 (第1处)
    listUsers(3，new String[] {"1"， "2"});
    // 以下代码输出结果为:3 ( 第2处)
    listUsers(new Integer[] {1, 2, 3});
    // 以下代码输出结果为:2 (第3处)
    listUsers(3，new Integer[] {1, 2, 3});
}
```
通过上面的例子可以看到，使用Object作为可变参数时过于灵活，类型转换场
景不好预判，比如第2处和第3处中Integer[]可以转型为Object[]，也可以作为一个
Object对象，所以导致第2处输出结果为3，第3处输出结果为2。而int[]只能被当
作一个单纯的Object对象。同时Object又很容易破坏“可变参数具备相同类型，相
同业务含义”这个大前提，如上例中第1处的整型和字符串数组类型混用，因此要避
免使用Object作为可变参数

以上是参数定义的相关内容，那么如何正确地使用参数呢?方法定义方并不能保
证调用方会按照预期传入参数，因此在方法体中应该对传入的参数保持理性的不信任。
方法的第一步骤并不是功能实现，而应该是参数预处理。参数预处理包括两种：

(1) 入参保护。虽然“入参保护”被提及的频率和认知度远低于参数校验，但
是其重要性却不能被忽略。入参保护实质上是对服务提供方的保护，常见于批量接口。
虽然批量接口能处理一批数据， 但其处理能力并不是无限的，因此需要对入参的数据
量进行判断和控制，如果超出处理能力，可以直接返回错误给客户端。某业务曾发生
过一个严重故障，就是由一个用户批量查询的接口导致的。虽然在API文档中约定了
每次最多支持查询的用户ID个数，但在接口实现中没有做任何入参保护，导致当调
用方传入万级的用户ID集合查询信息时，服务器内存被塞满，再无任何处理能力

(2) 参数校验。参数作为方法间交互和传递信息的媒介，其重要性不言而喻。
基于防御式编程理念，在方法内，无论是对方法调用方传入参数的理性不信任，还是
对参数有效值的检测都是非常有必要的。但是，由于方法间交互是非常频繁的，如果
所有方法都进行参数校验，就会导致重复代码及不必要的检查影响代码性能。综合两
个方面考虑，汇总需要进行参数校验和无须处理的场景

需要进行参数校验的场景：

- 调用频度低的方法
- 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但
如果因为参数错误导致中间执行回退或者错误，则得不偿失
- 需要极高稳定性和可用性的方法
- 对外提供的开放接口
- 敏感权限入口

不需要进行参数校验的场景：
- 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查
- 底层调用频度较高的方法。参数错误不太可能到底层才会暴露问题。一般
DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以可以
省略DAO的参数校验
- 声明成private只会被自己代码调用的方法。如果能够确定调用方法的代码传
入参数已经做过检查或者肯定不会有问题，此时可以不校验参数

###### 2.4.3 构造方法
构造方法(Constructor)是方法名与类名相同的特殊方法，在新建对象时调用，
可以通过不同的构造方法实现不同方式的对象初始化，它有如下特征：

(1) 构造方法名称必须与类名相同

(2) 构造方法是没有返回类型的，即使是void也不能有。它返回对象的地址，
并赋值给引用变量

(3) 构造方法不能被继承，不能被覆写，不能被直接调用。调用途径有三种：
一是通过new关键字，二是在子类的构造方法中通过super调用父类的构造方法，三
是通过反射方式获取并使用

(4) 类定义时提供了默认的无参构造方法。但是如果显式定义了有参构造方法，
则此无参构造方法就会被覆盖；如果依然想拥有，就需要进行显式定义

(5) 构造方法可以私有。外部无法使用私有构造方法创建对象

在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特
殊的存在，它可以定义，但不能加public修饰，因为它默认是private的，是绝对的单例，
不允许外部以创建对象的方式生成枚举对象

一个类可以有多个参数不同的构造方法，称为构造方法的重载。为了方便阅读，
当一个类有多个构造方法时，这些方法应该被放置在一起。 同理，类中的其他同名方
法也应该遵循这个规则

单一职责，对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参
操作，所以不应该在构造方法中引入业务逻辑。如果在一个对象生产中， 需要完成初
始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤
出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来处理异常就是一件
不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如init()，当对象
确认完成所有初始化工作之后，再显式调用

类中的static{...}代码被称为类的静态代码块，在类初始化时执行，优先级很高。
下面看一下父子类静态代码块和构造方法的执行顺序：
```java
class Son extends Parent {
    static { System.out.println("Son 静态代码块"); }
    Son() { System.out.println("Son 构造方法"); }
    
    public static void main(String[] args) {
        new Son();
        new Son();
    }
}

class Parent {
    static { System.out.println("Parent 静态代码块"); }
    public Parent() { System.out.println("Parent 构造方法"); }
}
```
执行结果如下:
```text
Parent 静态代码块
Son 静态代码块
Parent 构造方法
Son 构造方法
Parent 构造方法
Son 构造方法
````
从以上示例可看出，在创建类对象时，会先执行父类和子类的静态代码块，然后
再执行父类和子类的构造方法。并不是执行完父类的静态代码块和构造方法后，再去
执行子类。静态代码块只运行一次，在第二次对象实例化时，不会运行

###### 2.4.4 类内方法
在面向过程的语言中，几乎所有的方法都是全局静态方法，在引入面向对象理念
之后，某些方法才归属于具体对象，即类内方法。构造方法无论是有形、无形、私有、
公有，在一个类中是必然存在的。除构造方法外，类中还可以有三类方法：实例方法、
静态方法、静态代码块

1. 实例方法

又称为非静态方法。实例方法比较简单，它必须依附于某个实际对象，并可以通
过引用变量调用其方法。类内部各个实例方法之间可以相互调用，也可以直接读写类
内变量，但是不包含this。当.class 字节码文件加载之后，实例方法并不会被分配方
法入口地址，只有在对象创建之后才会被分配。实例方法可以调用静态变量和静态方
法，当从外部创建对象后，应尽量使用“类名.静态方法"来调用，而不是对象名，
一来为编译器减负，二来提升代码可读性

2. 静态方法

又称为类方法。当类加载后，即分配了相应的内存空间，由于生命周期的限制，
使用静态方法需要注意两点：

(1) 静态方法中不能使用实例成员变量和实例方法

(2) 静态方法不能使用super和this关键字，这两个关键字指代的都是需要被
创建出来的对象

通常静态方法用于定义工具类的方法等，静态方法如果使用了可修改的对象，那
么在并发时会存在线程安全问题。所以，工具类的静态方法与单例通常是相伴而生的

3. 静态代码块

在代码的执行方法体中，非静态代码块和静态代码块比较特殊。非静态代码块又
称为局部代码块，是极不推荐的处理方式，本节不再展开。而静态代码块在类加载的
时候就被调用，并且只执行一次。静态代码块是先于构造方法执行的特殊代码块。静
态代码块不能存在于任何方法体内，包括类静态方法和属性变量。观察如下示例代码：
```java
public class StaticCode {
    // prior 必须定义在last前边，否则编译出错: illegal forward reference
    static String prior = "done";
    // 依次调用f()的结果，三目运算符为true，执行g()，最后赋值成功
    static String last = f() ? g() : prior;
    
    public static boolean f() {
        return true;
    }
    
    public static String g() {
        return "hello world";
    }
    
    static {
        // 静态代码块可以访问静态变量和静态方法
        System.out.println(last);
        g();
    }
}
```
在上述代码中，由于last依赖了变量prior，所以两者之间存在先后关系，而静
态方法与静态变量之间没有先后关系。在实际应用中例如容器初始化时，可以使用静
态代码块实现类加载判断、属性初始化、环境配置等。很多容器框架会在单例对象初
始化成功后调用默认init()方法，完成例如RPC注册中心服务器判断、应用通用底层
数据初始化等工作。某框架的初始化代码如下所示：
```java
public class RpcProviderBean{
    public void init() throws RpcRuntimeException {
        this.initRegister();
        this.publish();
        //其他逻辑
    }
    
    public void initRegister() {
        if (this.inited.compareAndSet(false, true)) {
            this.checkConfig();
            this.metadata.init();
        }
    }
    
    public void publish() {
        // 将本地服务信息发送到注册中心
    }
}
```
###### 2.4.5 getter与setter
在实例方法中有一类特殊的方法，即getter与setter方法，它们一般不包含任何
业务逻辑，仅仅是为类成员属性提供读取和修改的方法，这样设计有两点好处：

(1) 满足面向对象语言封装的特性。尽可能将类中的属性定义为private， 针对
属性值的访问与修改需要使用相应的getter与setter方法，而不是直接对public的属
性进行读取和修改

(2) 有利于统一控制。虽然直接对属性进行读取、修改的方式和使用相应的
getter与setter方法在效果上是一样的，但是前者难以应对业务的变化。例如，业务
要求对某个属性值的修改要增加统一的权限控制，如果有setter作为统一的属性修改
方法则更容易实现，这种情况在一些使 用反射的框架中作用尤其明显

因此，在类成员属性需要被外部访问的类中，getter与setter方法是必备的。除
特殊情况需要增加业务逻辑外，它们仅仅是对成员属性的访问和修改操作，其承载的
信息价值比较低，所以，建议在类定义中，类内方法定义顺序依次是：公有方法或保
护方法 > 私有方法 > gettersetter方法

最典型的getter与setter方法使用是在POJO(Plain Ordinary Java Object，简单的
Java对象)类中。在本书中，POJO专指只包含getter、setter、 toString方法的简单类，
常见的POJO类包括DO(Domain Object)、BO(Business Object)、DTO(Data Transfer
Object)、VO(View Object)、AO(Application Object)。POJO 作为数据载体，通常用于
数据传输，不应该包含任何业务逻辑。因此，在POJO类中，getter 与setter不但是重
要的组成部分，更是与外界进行信息交换的桥梁。getter 与setter方法定义参考示例
如下：
```java
public class TicketDO {
    private Long id;
    // 目的地
    private String destination;
    
    // getter方法，要求：直接返回相应属性值，不增加业务逻辑
    public Long getId() {
        return id;
    }
    public String getDestination() {
        return destination;
    }
    
    // 参数名称与类成员变量名称一致，定义中this.成员名=参数名，尽量不增加业务逻辑
    public void setId(Long id) {
       this.id = id;
    }
    public void setDestination(String destination) {
        this.destination = destination;
    }
}
```

getter与setter方法的定义非常简单，正因如此，工程师们会放松对它们的警惕，
导致在实际应用中因为不当操作出现问题。下面来罗列那些易出错的getter与setter
方法定义方式：

(1)  getter/setter中添加业务逻辑。问题出现时，程序员的惯性思维会忽略
getter/setter方法的嫌疑，这会增加排查问题的难度。如下示例代码，在getData()中
增加了逻辑判断，修改了原属性值，如出现属性值不一致的情况，这里可能会是程序
员最后被排查到的地方
```java
public Integer getData() {
    if (condition) {
        return this.data + 100;
    } else {
        return this.data - 100;
    }
}
```
(2) 同时定义isXxx()和getXxx()。在类定义中，两者同时存在会在iBATIS、
JSON序列化等场景下引起冲突。比如，iBATIS通过反射机制解析加载属性的getter
方法时，首先会获取对象所有的方法，然后筛选出以get和is开头的方法，并存储到
类型为HashMap的getMethods变量中。其中key为属性名称，value为getter方法。
因此isXxx()和getXxx()方法只能保留一个，哪个方法被后存储到getMethods变量中，
就会保留哪个方法，具有一定的随机性。所以当两者定义不同时，会导致误用，进而
产生问题

(3) 相同的属性名容易带来歧义。在编程过程中，应该尽量避免在子父类的成
员变量之间、不同代码块的局部变量之间采用完全相同的命名。虽然这样定义是合法
的，但是要避免。这样使用非常容易引起混淆，在使用参数时，难以明确属性的作用
域，最终难以分清到底是父类的属性还是子类的属性。扩展开来，对于非setter/getter
的参数名称也要避免与成员变量名称相同
```java
public class ConfusingName {
    public int alibaba;
    // 反例：非 setter/getter 方法的参数名称，不允许与本类成员变量同名
    public void get(String alibaba) {
        if(true) {
            final int taobao = 15;
                ...
        }
        
        for (int i = 0; i < 10; i++) {
            // 在同一方法体中，不允许与其他代码块中的taobao命名相同
            final int taobao = 15;
            ...
        }
    }
}

class Son extends ConfusingName {
    // 反例：不允许与父类的成员变量名称相同
    public int alibaba;
}
```

###### 2.4.6 同步与异步
同步调用是刚性调用，是阻塞式操作，必须等待调用方法体执行结束。而异步调
用是柔性调用，是非阻塞式操作，在执行过程中，如调用其他方法，自己可以继续执
行而不被阻塞等待方法调用完毕。异步调用通常用在某些耗时长的操作上，这个耗时
方法的返回结果，可以使用某种机制反向通知，或者再启动一个线程轮询。反向通知
方式需要异步系统和各个调用它的系统进行耦合；而轮询对于没有执行完的任务会不
断地请求，从而加大执行机器的压力

异步处理的任务是非时间敏感的。比如，在连接池中，异步任务会定期回收空闲
线程。举个现实中的例子，在代码管理平台中，提交代码的操作是同步调用，需要实
时返回给用户结果。但是当前库的代码相关活动记录不是时间敏感的，在提交代码时，
发送一个消息到后台的缓存队列中，后台服务器定时消费这些消息即可

某些框架提供了丰富的异步处理方式，或者是把同步任务拆解成多个异步任务等

###### 2.4.7 覆写
多态中的override，本书翻译成覆写。如果翻译成重写，那么与重构意思过于
接近；如果翻译成覆盖，那么少了“写”这个核心动词。如果父类定义的方法达不到
子类的期望，那么子类可以重新实现方法覆盖父类的实现。因为有些子类是延迟加载
的，甚至是网络加载的，所以最终的实现需要在运行期判断，这就是所谓的动态绑定。
动态绑定是多态性得以实现的重要因素，元空间有一个方法表保存着每个可以实例化
类的方法信息，JVM可以通过方法表快速地激活实例方法。如果某个类覆写了父类
的某个方法，则方法表中的方法指向引用会指向子类的实现处。代码通常是用这样的
方式来调用子类的方法，通常这也被称作向，上转型：
```java
Father father = new Son();
// Son覆写了此方法
father.doSomething();
```
向上转型时，通过父类引用执行子类方法时需要注意以下两点：

(1) 无法调用到子类中存在而父类本身不存在的方法

(2) 可以调用到子类中覆写了父类的方法，这是一种多态实现

想成功地覆写父类方法，需要满足以下4个条件：

(1) 访问权限不能变小。访问控制权限变小意味着在调用时父类的可见方法无
法被子类多态执行，比如父类中方法是用public修饰的，子类覆写时变成private。设
想如果编译器为多态开了后门，让在父类定义中可见的方法随着父类调用链路下来，
执行了子类更小权限的方法，则破坏了封装。如下代码所示，在实际编码中不允许将
方法访问权限缩小：
```java
class Father {
    public void method() {
        System.out.println("Father's method");
    }
}

class Son extends Father {
    // 编译报错，不允许修改为访问权限更严格的修饰符
    @override
    private void method() {
        System.out.println("Son's method");
    }
}
```
(2) 返回类型能够向上转型成为父类的返回类型。虽然方法返回值不是方法签
名的一部分，但是在覆写时，父类的方法表指向了子类实现方法，编译器会检查返
回值是否向上兼容。注意，这里的向上转型必须是严格的继承关系，数据类型基本
不存在通过继承向上转型的问题。比如int与Integer是非兼容返回类型，不会自动装
箱。再比如，如果子类方法返回int，而父类方法返回long，虽然数据表示范围更大，
但是它们之间没有继承关系。返回类型是Object的方法，能够兼容任何对象，包括
class、enum、 interface 等类型

(3) 异常也要能向上转型成为父类的异常。异常分为checked和unhecked两种
类型。如果父类抛出一个checked异常，则子类只能抛出此异常或此异常的子类。而
unchecked异常不用显式地向上抛出，所以没有任何兼容问题

(4) 方法名、参数类型及个数必须严格一致。为了使编译器准确地判断是否是
覆写行为，所有的覆写方法必须加@Override注解。此时编译器会自动检查覆写方
法签名是否一致，避免了覆写时因写错方法名或方法参数而导致覆写失败。例如，
AbstractCollection的clear方法，当覆写此方法时，写成c1ear, 注意是数字的1，这
会导致定义了两个不同的方法。此外，@Override注解还可以避免因权限控制可见范
围导致的覆写失败。如图2-7所示，Father和Son属于不同的包，它们的method()方
法无权限控制符修饰，是默认仅包内可见的。Father 的method的方法在Son中是不
可见的。所以，Son中定义的method方法是一个“新方法”，如果加上@Override,
则会提示： Method does not override method from its superclass

综上所述，方法的覆写可以总结成容易记忆的口诀：“一 大两小两同”

- 一大：子类的方法访问权限控制符只能相同或变大
- 两小：抛出异常和返回值只能变小，能够转型成父类对象。子类的返回值、
抛出异常类型必须与父类的返回值、抛出异常类型存在继承关系
- 两同：方法名和参数必须完全相同

根据这个原则，再看一个编译和运行都正确的覆写示例代码：
```java
class Father {
    protected Number doSomething(int a, Integer b, Object c) throws SQLException {
        System.out.println("Father's doSomething");
        return new Integer(7);
    }
}

class Son extends Father {
    /**
     * 1. 权限扩大， 由protected到public (一大)
     * 2. 返回值是父类的Number的子类(两小)
     * 3. 抛出异常是SQLException的子类
     * 4. 方法名必须严格一致(两同)
     * 5. 参数类型与个数必须严格一致
     * 6. 必须加@Override
     */
    @Override
    public Integer doSomething(int a, Integer b, Object c) throws SQLClientInfoException {
        if(a == 0)
            throw new SQLClientInfoException();
        }
        return new Integer(17);
    }
}
```
覆写只能针对非静态、非final、非构造方法。由于静态方法属于类，如果父类
和子类存在同名静态方法，那么两者都可以被正常调用。如果方法有final修饰，则
表示此方法不可被覆写

如果想在子类覆写的方法中调用父类方法，则可以使用super关键字。在上述示.
例代码中，在Son的doSomething方法体里可以使用super.doSomething(a, b, c)调用父
类方法。如果与此同时在父类方法的代码中写一句this.doSomething()，会得出什么样
的运行结果呢?
```java
public class Father {
    protected void doSomething() {
        System.out.println("Father's doSomething");
        this.doSomething();
    }
    public static void main(String[] args) {
        Father father = new Son();
        father.doSomething();
    }
}
    
class Son extends Father {
    @Override
    public void doSomething() {
        System.out.println("Son's doSomething");
        super.doSomething();
    }
}
```
在经过了一系列的父子方法循环调用后，JVM崩溃了，发生了StackOverflowError，如图2-8所示

##### 2.5 重载
在同一个类中，如果多个方法有相同的名字、不同的参数，即称为重载，比如一
个类中有多个构造方法。String 类中的valueOf也是比较著名的重载案例，它有9个
方法，可以将输入的基本数据类型、数组、Object等转化成为字符串。在编译器的眼里，
方法名称 + 参数类型 + 参数个数，组成一个唯一键，称为方法签名，JVM通过这个
唯一键决定调用哪种重载的方法。注意，方法返回值并非是这个组合体中的一员，所
以在使用重载机制时，不能有两个方法名称完全相同，参数类型和个数也相同，但是
返回类型不同的方法。如下示例代码：
```java
public class SameMethodSignature {
    public void methodForOverload() {}
    
    // 编译出错。返回值并不是方法签名的一部分
    public final int methodForOverload() {
        return 7;
    }
    
    // 编译出错。访问控制符也不是方法签名的一部分
    private void methodForOverload() {}
    
    // 编译出错。静态标识符也不是方法签名的一部分
    public static void methodForOverload() {}
    
    // 编译出错。final标识符也不是方法签名的一部分
    private final void methodForOverload() {}
}
```
重载似乎是比较容易理解和掌握的编程技能，有时仅凭肉眼判断就能知道应调用
哪种重载方法，特别是如下代码所示的第一种方法和第二种方法。前者是无参的，后
者参数是int param，但是后边的三种方法，只是参数类型不同罢了。这时，如果调用
methodForOverload(7)，猜猜，到底调用的是谁呢?
```java
public class OverloadMethods {
    // 第一种方法：无参
    public void overloadMethod() {
        System.out.println("无参方法");
    }
    
    // 第二种方法：基本数据类型
    public void methodForOverload(int param) {
        System.out.println("参数为基本类型int的方法");
    }
    
    // 第三种方法：包装数据类型
    public void methodForOverload(Integer param) {
        System.out.println("参数为包装类型Integer的方法");
    }
    
    // 第四种方法：可变参数，可以接受0~n个Integer对象
    public void methodForOverload(Integer... param) {
        System.out.println("可变参数方法");
    }
    
    // 第五种方法：Object对象
    public void methodForOverload(Object param) {
        System.out.println("参数为Object的方法");
    }
}
```
先看这五种方法对应的字节签名有何异同点
```java
// V 表示Void返回值
public overloadMethod()V

// I 就是代表int基本数据类型，而非Integer
public methodForOverload(I)V

// L 表示输入参数是对象，然后跟着 package + 类名   (第1处)
public methodForoverload(Ljava/lang/Integer;)V

// varargs 表示可变参数    (第2处)
public varargs methodForOverload([Ljava/lang/Integer;]V

// L 同样表示对象参数
public methodForOverload(Ljava/lang/object;)V
```
第1处与第2处的区别是后者加了varargs标识，即可变参数，参数个数可以
是0或多个，也就是说，它和第1、2、3个方法都是有可能争抢地盘的。首先，如
果调用methodForOverload()，假如在无参方法缺席的情况下，也会调用到可变参
数方法。但是如果无参方法在场，就不需要可变参数方法了。现在对这个类来说，
methodForOverload(7)到底花落谁家? JVM在重载方法中，选择合适的目标方法的顺
序如：

(1) 精确匹配

(2) 如果是基本数据类型，自动转换成更大表示范围的基本类型

(3) 通过自动拆箱与装箱

(4) 通过子类向，上转型继承路线依次匹配

(5) 通过可变参数匹配

精确匹配优先，这是毫无疑问的。int在和Integer的较量中胜出，因为不需要自
动装箱，所以7会调用int参数的方法。如果是new Integer(7) 的话，Integer参数的方
法胜出

如果本方法只有methodForOverload(long)，则可以接收methodForOverload(3)的
实参调用；反之，如果只有methodForOverload(int)，而传入long值，则会编译出
错。基本数据类型转化为表示范围更大的基本数据类型优先于自动装箱，即int转为
long，优先于装箱为Integer

注意，null可以匹配任何类对象，在查找目标方法时，是从最底层子类依次向上
查找的。在本例中，如果methodForOverload(nulI)，则会调用参数为Integer的方法。
第一，因为Integer是一个类；第二，它是Object的子类。在示例代码中，如果还有
单个String类型参数的方法，则会编译出错，因为null不知道该选择Integer，还是
String

根据上述匹配顺序，可变参数在竞争中明显处于弱势地位。如果调用
methodForOverload(13, 14)，此时有两个参数，虽然有自动装箱的开销，但可变参数仍
会执行这种方法请求

最后，有些程序员好奇心特别强，刚才不是说7是匹配基本数据类型优先，而
new Integer(7)是匹配包装类优先的，那如果这样定义：
```java
public void methodForOverload(int param1, Integer param2) {}
public void methodForOverload(Integer param3, int param4) {}
```
这种定义方式就是在考验编译器的忍耐底线，虽然编译器的内心是崩
溃的，但是这样定义是可以编译通过的，这也是一种重载方式。但此时调用
methodForOverload(13, 14)会彻底让编译器失控，如图2-9所示

最后，假如一个类中只有methodForOverload(Object param)
和methodForOverload(Integer... param)两种方法，根据目标方法匹配顺序,
methodForOverload(7)先自动装箱，然后向上转型，遇到Object。这个规则优先
于调用可变参数的重载方法

父类的公有实例方法与子类的公有实例方法可以存在重载关系。不管继承关系如
何复杂，重载在编译时可以根据规则知道调用哪种目标方法。所以，重载又称为静态
绑定

##### 2.6 泛型
泛型的本质是类型参数化，解决不确定具体对象类型的问题。在面向对象编程语
言中，允许程序员在强类型校验下定义某些可变部分，以达到代码复用的目的。泛型
( generic)、天才( genius)、基因( gene)三个英文单词的词根都是gen，最神奇的
是，它们无论是拼写还是发音都十分相像，在沟通中往往比较含糊。可以这样理解，
泛型就是这些拥有天才基因的大师们发明的

Java在引入泛型前，表示可变类型，往往存在类型安全的风险。举一个生活中的
例子，微波炉最主要的功能是加热食物，即加热肉、加热汤都有可能。在没有泛型的
场景中，往往会写出：
```java
class Stove {
    public static Object heat(Object food) {
        System.out.println(food + "is done");
        return food;
    }
    public static void main(String[] args) {
        Meat meat = new Meat();
        meat = (Meat)Stove.heat(meat);
        Soup soup = new Soup();
        soup = (Soup)Stove.heat(soup);
    }
}
```
为了避免给每种食材定义一个加热方法，如heatMeat()、heatSoup()等， 将heat()
的参数和返回值定义为Object，用“向上转型”的方式，让其具备可以加热任意类型
对象的能力。这种方式增强了类的灵活性，但却会让客户端产生困惑，因为客户端对
加热的内容一无所知， 在取出来时进行强制转换就会存在类型转换风险。泛型则可以
完美地解决这个问题

泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来
解析泛型。在泛型定义时，约定俗成的符号包括：E代表Element，用于集合中的元素；
T代表the Type of object,表示某个类； K代表Key、V代表Value，用于键值对元素。
我们用一个示例彻底地记住泛型定义的概念，对泛型不再有恐惧心理。如果下面代码
编译出错，请指出编译出错的位置在哪里：
```java
public class GenericDefinitionDemo<T> {
    static <String, T, Alibaba> String get(String string, Alibaba alibaba) {
        return string;
    }
    
    public static void main(String[] args) {
        Integer first = 222;
        Long second = 333L;
        // 调用上方定义的get方法
        Integer result = get(first, second) ;
    }
}
```
事实上，以上代码编译正确且能够正常运行，get()是一个泛型方法，first并非是
java.lang.String类型，而是泛型标识<String>，second指代Alibaba。get() 中其他没有被用
到的泛型符号并不会导致编译出错，类名后的T与尖括号内的T相同也是合法的。当然
在实际应用时，并不会存在这样的定义方式，这里只是期望能够对以下几点加深理解：

(1) 尖括号里的每个元素都指代一种未知类型。String出现在尖括号里，它就
不是java.lang.String,而仅仅是一个代号。 类名后方定义的泛型<T>和get()前方定
义的<T>是两个指代，可以完全不同，互不影响

(2) 尖括号的位置非常讲究，必须在类名之后或方法返回值之前

(3) 泛型在定义处只具备执行Object方法的能力。因此想在get()内部执行
string.longValue() + alibaba.intValue()是做不到的，此时泛型只能调用Object类中的方
法，如toString()

(4) 对于编译之后的字节码指令，其实没有这些花头花脑的方法签名，充分说
明了泛型只是一种编写代码时的语法检查。在使用泛型元素时，会执行强制类型转换：
```java
INVOKESTATIC com/alibaba/easy/coding/generic/GenericDefinitionDemo.get
           (Ljava/lang/Object;Ljava/lang/Object;) Ljava/lang/Object;
CHECKCAST java/lang/Integer
```
这就是坊间盛传的类型擦除。CHECKCAST指令在运行时会检查对象实例的类
型是否匹配，如果不匹配，则抛出运行时异常ClassCastException。与C++根据模板
类生成不同的类的方式不同，Java 使用的是类型擦除的方式。编译后，get()的参数是
两个Object，返回值也是Object,尖括号里很多内容消失了，参数中也没有String和
Alibaba两个类型。数据返回给Integer result时，进行了类型强制转化。因此，泛型
就是在编译期增加了一道检查而已，目的是促使程序员在使用泛型时安全放置和使用
数据。使用泛型的好处包括：

- 类型安全。放置的是什么，取出来的自然是什么，不用担心会抛出
ClassCastException异常

- 提升可读性。从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类
型是什么

- 代码重用。泛型合并了同类型的处理代码，使代码重用度变高

回到本节开头微波炉加热食材的例子，使用泛型可以很好地实现，示例代码如下：
```java
class Stove {
    public static <T> T heat(T food) {
        System.out.println(food + "is done");
        return food;
    }
    public static void main(String[] args) {
        Meat meat = new Meat();
        meat = Stove.heat(meat);
        Soup soup = new Soup();
        soup = Stove.heat(soup);
    }
}
```
通过使用泛型，既可以避免对加热肉和加热汤定义两种不同的方法，也可以避免
使用Object作为输入和输出，带来强制转换的风险。只要这种强制转换的风险存在，
依据墨菲定律，就一定会发生ClassCastException异常。特别是在复杂的代码逻辑中，
会形成网状的调用关系，如果任意使用强制转换，无论可读性还是安全性都存在问题

最后，泛型与集合的联合使用，可以把泛型的功能发挥到极致，很多程序员
不清楚List、List\<Object\>、List<?> 三者的区别，更加不能区分<? extends T>与<? super T>
的使用场景。具体请参考第6.5节

##### 2.7 数据类型
###### 2.7.1 基本数据类型
虽然Java是面向对象编程语言，一切皆是对象，但是为了兼容人类根深蒂固的
数据处理习惯，加快常规数据的处理速度，提供了9种基本数据类型，它们都不具备
对象的特性，没有属性和行为。基本数据类型是指不可再分的原子数据类型，内存
中直接存储此类型的值，通过内存地址即可直接访问到数据，并且此内存区域只能
存放这种类型的值。Java的9种基本数据类型包括boolean、byte、char、short、int、
long、float、double和refvar。前8种数据类型表示生活中的真假、字符、整数和小
数，最后一种refvar是面向对象世界中的引用变量，也叫引用句柄。本书认为它也
是一种基本数据类型。前8种都有相应的包装数据类型，除char的对应包装类名为
Character，int 为Integer外，其他所有对应的包装类名就是把首字母大写即可。这8
种基本数据类型的默认值、空间占用大小、表示范围及对应的包装类等信息如表2-4
所示

默认值虽然都与0有关，但是它们之间是存在区别的。比如，boolean的默认值
以0表示的false，JVM并没有针对boolean数据类型进行赋值的专用字节码指令，
boolean flag = false就是用ICONST_ 0，即常数0来进行赋值；byte的默认值以一个字
节的0表示，在默认值的表示上使用了强制类型转化； float的默认值以单精度浮点数
0.0f表示，浮点数的0.0使用后缀f和d区别标识：char的默认值只能是单引号的'\'u0000'
表示NUL，注意不是null，它就是一个空的不可见字符，在码表中是第一个，其码值
为0，与'\n'换行之类的不可见控制符的理解角度是一样的。 注意，不可以用双引号
方式对char进行赋值，那是字符串的表示方式。在代码中直接出现的没有任何上下
文的0和0.0分别默认为int和double类型，可以使用JDK10的类型推断证明：var
a=0; Long b=a;代码编译出错，因为在自动装箱时，0默认是int类型，自动装箱为
Integer，无法转化为Long类型

所有数值类型都是有符号的，最大值与最小值如表2-4所示。因为浮点数无法
表示零值，所以表示范围分为两个区间：正数区间和负数区间。表2-4中的float和
double的最小值与最大值均指正数区间，它们对应的包装类并没有缓存任何数值

引用分成两种数据类型：引用变量本身和引用指向的对象。为了强化这两个概念
的区分，本书把引用变量(Reference Variable)称为refvar， 而把引用指向的实际对
象(Referred Object)简称为refobj

refvar是基本的数据类型，它的默认值是null，存储refobj的首地址，可以直接
使用双等号==进行等值判断。而平时使用refvar.hashCode()返回的值，只是对象的
某种哈希计算，可能与地址有关，与refvar本身存储的内存单元地址是两回事。作为
一个引用变量，不管它是指向包装类、集合类、字符串类还是自定义类，refvar均占
用4B空间。注意它与真正对象refobj之间的区别。无论refobj是多么小的对象，最
小占用的存储空间是12B (用于存储基本信息，称为对象头)，但由于存储空间分配
必须是8B的倍数，所以初始分配的空间至少是16B

一个refvar至多存储一个refobj的首地址，一个refobj可以被多个refvar存储下
它的首地址，即一个堆内对象可以被多个refvar引用指向。如果refobj没有被任何
refvar指向，那么它迟早会被垃圾回收。而refvar的内存释放，与其他基本数据类型
类似

基本数据类型int占用4个字节，而对应的包装类Integer实例对象占用16个字
节。这里可能会有人问：Integer里边的代码就只占用16B?这是因为字段属性除成
员属性int value外，其他的如MAX_VALUE、 MIN_VALUE等都是静态成员变量，
在类加载时就分配了内存，与实例对象容量无关。此外，类定义中的方法代码不占用
实例对象的任何空间。IntegerCache是Integer的静态内部类，容量占用也与实例对象
无关。由于refobj对象的基础大小是12B，再加上int是4B，所以Integer实例对象占
用16B，按此推算Double对象占用的存储容量是24B，示例代码如下：
```java
class RefObj Demo {
    // 对象头最小占用空间12个字节 (第1处)
    
    // 下方4个byte类型分配后，对象占用大小是16个字节
    byte b1;
    byte b2;
    byte b3;
    byte b4;
    
    // 下方每个引用变量占用是4个字节，共20个字节
    Object obj1;
    Object obj2;
    Object obj3;
    Object obj4;
    Object obj5;
    
    // RefObjOther 实例占用空间并不计算在本对象内，依然只计算引用变量大小4个字节
    RefObjOther o1 = new RefObjOther() ;
    RefObjOther o2 = new RefObjOther() ;
    
    // 综上，RefObjDemo对象占用: 12B + (1BX4) + (4BX5) + (4BX2) = 44个字节
    // 取8的倍数为48个字节
}

class RefObjOther {
    // double类型占用8个字节，但此处是数组引用变量
    // 所以对象头12B + 4B = 16B，并非是8012个字节
    // 这个数组引用的是double[] 类型，指向实际分配的数组空间首地址
    // 在new对象时，已经实际分配空间
    double[] d = new double[1000];
}
```
在上述示例代码中，第1处提到的对象头最小占用空间12为个字节，其内部存
储的是什么信息呢?下面来分析其内部结构，如图2-10所示，对象分为三块存储区域

(1) 对象头(Object Header)

对象头占用12个字节，存储内容包括对象标记(markOop)和类元信息(klassOop)。
对象标记存储对象本身运行时的数据，如哈希码、GC标记、锁信息、线程关联信息等，
这部分数据在64位JVM上占用8个字节，称为"Mark Word”。为了存储更多的状
态信息，对象标记的存储格式是非固定的(具体与JVM的实现有关)。类元信息存
储的是对象指向它的类元数据(即Klass)的首地址，占用4个字节，与refvar开销一致

(2) 实例数据(Instance Data)

存储本类对象的实例成员变量和所有可见的父类成员变量。如Integer的实例
成员只有一个private int value，占用4个字节，所以加上对象头为16个字节；再
如，上述示例代码的RefObjDemo对象大小为48个字节，一个子类RefObjSon继承
RefObjDemo，即使子类内部是空的，new RefObjSon的对象也是占用48个字节

(3 )对齐填充(Padding)

对象的存储空间分配单位是8个字节，如果一个占用大小为16个字节的对象，
增加一个成员变量byte类型，此时需要占用17个字节，但是也会分配24个字节进
行对齐填充操作

###### 2.7.2 包装类型
前8种基本数据类型都有相应的包装类，因为Java的设计理念是一切皆是对
象，在很多情况下，需要以对象的形式操作，比如hashCode()获取哈希值，或者
getClass()获取类等。包装类的存在解决了基本数据类型无法做到的事情：泛型类型
参数、序列化、类型转换、高频区间数据缓存。尤其是最后一项， 我们都知道Integer
会缓存-128~127之间的值，对于Integer var=?在-128~127之间的赋值，Integer 对
象由IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使
用==进行判断，但是这个区间之外的所有数据都会在堆上产生，并不会复用已有对象，
这是一个大问题。因此，推荐所有包装类对象之间值的比较，全部使用equals()方法

事实上，除Float和Double外，其他包装数据类型都会缓存，6个包装类直接赋
值时，就是调用对应包装类的静态工厂方法valueOf()，以Integer为例，源码如下：
```java
@HotSpotIntrinsicCandidate
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
如上源代码，赋值数据i在缓存区间内直接返回缓存中的Integer对象，否则就
会new一个对象。在JDK9直接把new的构造方法过时，推荐使用valueOf()，合理
利用缓存，提升程序性能。各个包装类的缓存区间如下：

- Boolean：使用静态final变量定义，valueOf()就是返回这两个静态值

- Byte：表示范围是-128~127，全部缓存

- Short：表示范围是-32768~32767，缓存范围是-128~127

- Character：表示范围是0~65535，缓存范围是0~127

- Long：表示范围是[-2^63, 2^63-1]，缓存范围是-128~127

- Integer：表示范围是[-2^31, 2^31-1]。最后详细介绍Integer，因为它是Java数
据世界里应用最广的数据类型，缓存范围是-128~127。但它是唯一可以修改
缓存范围的包装类，在VM options加入参数-XX:AutoBoxCacheMax=7777,
即可设置最大缓存值为7777，示例代码如下：
```java
public class LongIntegerCacheTest  {
    public static void main(String[] args) {
        Long a = 127L;
        Long b = 127L;
        System.out.println("Long max cached value is 127, ”
            + "and the result is: " + (a == b));
        
        Long a1 = 128L;
        Long b1 = 128L;
        System.out.println("Long=128 cache is " + (a1 == b1));
        
        Long c = -128L;
        Long d = -128L;
        System.out.println("Long min cached value is -128, "
            + "and the result is: " + (c == d));
        
        Long c1 = -129L;
        Long d1 = -129L;
        System.out.println("Long=-129 cache is ” + (c1 == d1));
                           
        // Long 类型只缓存-128 ~ 127之间的数值
        Long e = 1000L;
        Long f = 1000L;
        System.out.println("Long=1000 is ” + (e == f));
                           
        // JVM AutoBoxCacheMax 只对Integer对象有效
        Integer x = 1001;
        Integer y = 1001;
        System.out.println("Integer=1001 is " + (x == y));
    }
}
```
执行结果如下: 
```text
Long max cached value is 127, and the result is: true
Long=128 cache is false
Long min cached value is -128, and the result is: true
Long=-129 cache is false
Long=1000 is false
Integer=1001 is true
```
该例很好地说明了Long只是缓存了-128~127之间的值，而1000L没有被缓存；
在将Integer最大缓存值改为7777后，1001被成功缓存。合理掌握包装类的缓存策略，
防止遇到问题是一个方面，使自己的程序性能最大化，更是程序员的情怀所在。在选
择使用包装类还是基本数据类型时，推荐使用如下方式：

(1) 所有的POJO类属性必须使用包装数据类型

(2) RPC方法的返回值和参数必须使用包装数据类型

(3) 所有的局部变量推荐使用基本数据类型

###### 2.7.3 字符串
字符串类型是常用的数据类型，它在JVM中的地位并不比基本数据类型低，
JVM对字符串也做了特殊处理。String就像是流落到基本数据类型部落的一个副首领，
虽然很神气，但是终归难以得到族人对它的认同，毕竟它是堆上分配来的

字符串相关类型主要有三种：String、StringBuilder、StringBuffer。 String 是只读
字符串，典型的immutable对象，对它的任何改动，其实都是创建一个新对象， 再把
引用指向该对象。String对象赋值操作后，会在常量池中进行缓存，如果下次申请创
建对象时，缓存中已经存在，则直接返回相应引用给创建者。而StringBuffer则可以
在原对象上进行修改，是线程安全的。JDK5 引入的StringBuilder与StringBuffer均继
承自AbstractStringBuilder，两个子类的很多方法都是通过"super. 方法()”的方式调
用抽象父类中的方法，此抽象类在内部与String一样，也是以字符数组的形式存储字
符串的。StringBuilder是非线程安全的，把是否需要进行多线程加锁交给工程师决定，
操作效率比StringBuffer高。线程安全的对象先产生是因为计算机的发展总是从单线
程到多线程，从单机到分布式

在非基本数据类型的对象中，String是仅支持直接相加操作的对象。这样操作比
较方便，但在循环体内，字符串的连接方式应该使用StringBuilder的append方法进
行扩展。如下的方式是不推荐的：
```java
String str = "start";
for(int i = 0; i < 100; i++) {
    str = str + "hello";
}
```
此段代码的内部实现逻辑是每次循环都会new一个StringBuilder对象，然后进
行append操作，最后通过toString方法返回String对象，不但造成了内存资源浪费，
而且性能更差
