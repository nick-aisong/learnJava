#### 第2章 面向对象
本章开始讲解面向对象思想，并以Java为载体讲述面向对象思想在具体编程语
言中的运用与实践。当前主流的编程语言有50种左右，主要分为两大阵营：面向对
象编程与面向过程编程

面向对象编程( Object-Oriented Programming, OOP )是划时代的编程思想变革，
推动了高级语言的快速发展和工业化进程。OOP的抽象、封装、继承、多态的理念
使软件大规模化成为可能，有效地降低了软件开发成本、维护成本和复用成本。面向
对象编程思想完全不同于传统的面向过程编程思想，使大型软件的开发就像搭积木一
样隔离可控、高效简单，是当今编程领域的一股势不可当的潮流。OOP实践了软件
工程的三个主要目标：可维护性、可重用性和可扩展性

##### 2.1 OOP理念
面向过程让计算机有步骤地顺次做一件事情，是一种过程化的叙事思维。但是在
大型软件开发过程中，发现用面向过程语言开发，软件维护、软件复用存在着巨大的
困难，代码开发变成了记流水账，久而久之就成为“面条”代码，模块之间互相耦合，
流程互相穿插，往往牵一发而动全身。面向对象提出一种计算机世界里解决复杂软件
工程的方法论，拆解问题复杂度，从人类思维角度提出解决问题的步骤和方案

但是，编程语言仅是一个工具，就像练武之人的剑，武功高者草木皆剑，武功差
者即使莫邪剑在身也依然平庸。所以，能否将工具的价值发挥得淋漓尽致，最终还是
取决于开发工程师本身。优秀的开发工程师用面向过程的语言也能把程序写得非常内
聚，可扩展性好，具备一定的复用性；而平庸程序员用面向对象语言一样能把程序写
得松散随意、毫无抽象与建模、模块间耦合严重、维护性差

传统意义上，面向对象有三大特性：封装、继承、多态。本书明确将“抽象”作
为面向对象的特性之一，支持面向对象“四大特性”的说法。抽象是程序员的核心素
质之一，体现出程序员对业务的建模能力，以及对架构的宏观掌控力。虽然面向过程
也需要进行一定的抽象能力，但是相对来说，面向对象思维，以对象模型为核心，丰
富模型的内涵，扩展模型的外延，通过模型的行为组合去共同解决某一类问题，抽象
能力显得尤为重要；封装是一种对象功能内聚的表现形式，使模块之间耦合度变低，
更具有维护性；继承使子类能够继承父类，获得父类的部分属性和行为，使模块更有
复用性；多态使模块在复用性基础上更加有扩展性，使运行期更有想象空间

抽象是面向对象思想最基础的能力之一，正确而严谨的业务抽象和建模分析能力
是后续的封装、继承、多态的基础，是软件大厦的基石。在面向对象的思维中，抽象
分为归纳和演绎。前者是从具体到本质，从个性到共性，将一类对象的共同特征进行
归一化的逻辑思维过程；后者则是从本质到具体，从共性到个性，逐步形象化的过程。
在归纳的过程中，需要抽象出对象的属性和行为的共性，难度大于演绎。演绎是在已
有问题解决方案的基础上，正确地找到合适的使用场景。演绎错误在使用集合时比较
常见，比如针对查多改少的业务场景，使用链表是非常不合理的；底层框架技术选型
时如果有错误，则有可能导致技术架构完全不适应业务的快速发展

Java之父Gosling 设计的Object类，是任何类的默认父类，是对万事万物的抽象，
是在哲学方向上进行的延伸思考，高度概括了事物的自然行为和社会行为。我们都知
道哲学的三大经典问题：我是谁，我从哪里来，我到哪里去。在Object类中，这些问
题都可以得到隐约的解答：

(1) 我是谁? getClass()说明本质上是谁，而toString()是当前职位的名片

(2) 我从哪里来? Object()构造方法是生产对象的基本步骤，clone()是繁殖对
象的另一种方式

(3) 我到哪里去? finalize()是在对象销毁时触发的方法

这里重点介绍clone()方法，它分为浅拷贝、一般深拷贝和彻底深拷贝。浅拷贝
只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指
向的实际对象；而彻底深拷贝是在成功clone一个对象之后，此对象与母对象在任何
引用路径上都不存在共享的实例对象，但是引用路径递归越深，则越接近JVM底层
对象，且发现彻底深拷贝实现难度越大。介于浅拷贝和彻底深拷贝之间的都是一般深
拷贝。归根结底，慎用Object的clone()方法来拷贝对象，因为对象的clone() 方法默
认是浅拷贝，若想实现深拷贝，则需要覆写clone() 方法实现引用对象的深度遍历式
拷贝

另外，Object还映射了社会科学领域的一些问题：

(1) 世界是否因你而不同?hashCode()和equals()就是判断与其他元素是否相
同的一组方法

(2) 与他人如何协调? wait()和notify()是对象间通信与协作的一组方法

随着时代的发展，当初的抽象模型部分不适用当下的技术潮流，比如finalize()
方法在JDK9之后直接被标记为过时方法。而wait()和notify()同步方式事实上已经
被同步信号、锁、阻塞集合等取代

封装是在抽象基础上决定信息是否公开，以及公开等级，核心问题是以什么样的
方式暴露哪些信息。抽象是要找到属性和行为的共性，属性是行为的基本生产资料，
具有一定的敏感性，不能直接对外暴露；封装的主要任务是对属性、数据、部分内部
敏感行为实现隐藏。对属性的访问与修改必须通过定义的公共接口来进行，某些敏感
方法或者外部不需要感知的复杂逻辑处理，一般也会进行封装。封装使面向对象的世
界变得单纯，对象之间的关系变得简单，各人自扫门前雪，耦合度变弱，有利于维护。
智能化的时代，对封装的要求越来越高，产品使用更加简单方便、轻松自然。就像天
猫精灵，唯一的接口就是语音输入，隐藏了指令内部的细节实现和相关数据，使外部
用户无法访问，大大降低了使用成本，有效地保护内部数据安全

设计模式七大原则之一的迪米特法则就是对于封装的具体要求，即A模块使用
B模块的某个接口行为，对B模块中除此行为之外的其他信息知道得尽可能少。比如：
耳塞的插孔就是提供声音输出的行为接口，只需关心这个插孔是否有相应的耳塞标记，
是否是圆形的，有没有声音即可，至于内部CPU如何运算音频信息，以及各个电容
如何协同工作，根本不需要去关注，这使模块之间的协作只需忠于接口、忠于功能实
现即可

封装这件事情是由俭入奢易，由奢入俭难。属性值的访问与修改需要使用相应的
getter/setter方法，而不是直接对public的属性进行读取和修改，可能有些程序员存在
疑问，既然通过这两个方法来读取和修改，那与直接对属性进行操作有何区别?如果
某一天，类的提供方想在修改属性的setter方法上进行鉴权控制、日志记录，这是在
直接访问属性的情形中无法做到的。若是将已经公开的属性和行为直接暴力修改为
private，则依赖模块都会编译出错。所以，在不知道什么样的访问控制权限合适的时候，
优先推荐使用private控制级别

继承是面向对象编程技术的基石，允许创建具有逻辑等级结构的类体系，形成一
个继承树，让软件在业务多变的客观条件下，某些基础模块可以被直接复用、间接复
用或增强复用，父类的能力通过这种方式赋予子类。继承把枯燥的代码世界变得更有
层次感，更有扩展性，为多态打下语法基础

人人都说继承是is-a关系，那么如何衡量当前的继承关系是否满足is-a关系呢?
判断标准即是否符合里氏代换原则(Liskov Substitution Principle，LSP)。LSP是指
任何父类能够出现的地方，子类都能够出现。从字面上很难深入理解，先打个比方，
警察在枪战片中经常说：放下武器，把手举起来！而对面的匪徒们有的使用手枪，有
的使用匕首，这些都是武器的子类。父类出现的地方，即“放下武器”，那么，放下
手枪，是对的，放下匕首，也是对的!在实际代码环境中，如果父类引用直接使用子
类引用来代替，可以编译正确并执行，输出结果符合子类场景的预期，那么说明两个
类之间符合LSP原则，可以使用继承关系

继承的使用成本很低，一个关键字就可以使用别人的方法，似乎更加轻量简单。
想复用别人的代码，跳至脑海的第一反应是继承它，所以继承像抗生素一样容易被滥
用，我们传递的理念是谨慎使用继承，认清继承滥用的危害性，即方法污染和方法爆
炸。方法污染是指父类具备的行为，通过继承传递给子类，子类并不具备执行此行为
的能力，比如鸟会飞，鸵鸟继承鸟，发现飞不了，这就是方法污染。子类继承父类，
则说明子类对象可以调用父类对象的一切行为。在这样的情况下，总不能在继承时，
添加注释说明哪几个父类方法不能在子类中执行，更不能覆写这些无法执行的父类方
法，抛出异常，以阻止别人的调用。方法爆炸是指继承树不断扩大，底层类拥有的方
法虽然都能够执行，但是由于方法众多，其中部分方法并非与当前类的功能定位相关，
很容易在实际编程中产生选择困难症。比如某些综合功能的类，经过多次继承后达到
上百个方法，造成了方法爆炸，因而带来使用不便和安全隐患。在实际故障中，因为
方法爆炸，父类的某些方法签名和子类非常相似，在IDE中，输入类名+点之后，
在自动提示的极为相似的方法签名中选择错误，导致线上异常。综上所述，提倡组合
优先原则来扩展类的能力，即优先采用组合或聚合的类关系来复用其他类的能力，而
不是继承

多态是以上述的三个面向对象特性为基础，根据运行时的实际对象类型，同一个
方法产生不同的运行结果，使同一个行为具有不同的表现形式。多态是面向对象天空
中绚丽多彩的礼花，提升了对象的扩展能力和运行时的丰富想象力。我们来明确两个
非常容易混淆的概念：“override”和“overload"，"override"译成“覆写”，是子
类实现接口，或者继承父类时，保持方法签名完全相同，实现不同的方法体，是垂直
方向上行为的不同实现。“overload”译成“重载”，方法名称是相同的，但是参数
类型或参数个数是不相同的，是水平方向上行为的不同实现。多态是指在编译层面无
法确定最终调用的方法体，以覆写为基础来实现面向对象特性，在运行期由JVM进
行动态绑定，调用合适的覆写方法体来执行。重载是编译期确定方法调用，属于静态
绑定，本质上重载的结果是完全不同的方法，所以本书认为多态专指覆写。自然界的
多态最典型例子就是碳家族，据说某化学家告诉他女朋友将在她的生日晚会上送她一
块碳，女朋友当然不高兴，可收到的却是5克拉的钻石。钻石就是碳元素在不断进化
过程中的一种多态表现。严格意义上来说，多态并不是面向对象的一种特质，而是一
种由继承行为衍生而来的进化能力而已

##### 2.2 初识Java
面向对象编程思想把所有的有形或无形的事物都看作对象，并给对象赋予相应
的属性和行为，建立对象之间的联系，使程序员更加立体、形象地解决编程领域的问
题。面向对象语言的忠实代表是Java语言，它是一门富有生命力的语言，在最受欢
迎的语言排行榜上，多年位居第一。Java语言是1995年由Sun公司首次发布的。次
年Java开发工具包发布，即Java Development Kit，简称JDK1.0，这是Java发展的一
个重要里程碑，标志着Java成为一门独立的成熟语言。随后，Sun 公司再接再厉发布
了Just-in-time编译器，简称JIT，不断进步的JIT技术使Java的执行速度接近甚至超
过其他高级语言

JDK随着时代不断往前发展。在众多版本中，最具划时代影响力的版本是
JDK5，项目代号Tiger。Doug Lea推出的并发包，使Java如虎添翼，成为工业级语言，
在企业服务端得到极为广泛的应用。随着后续版本的陆续推出，Java的发展与时俱进，
推出了diamond语法、函数式、模块化、var 类型推断等新特性。最新的JDK版本是
JDK11

JRE (Java Runtime Environment)即Java运行环境，包括JVM、核心类库、核
心配置工具等。其中JVM (Java Virtual Machine)即Java虚拟机，它是整个Java体
系的底层支撑平台，把源文件编译成平台无关的字节码文件，屏蔽了Java源代码与
具体平台相关的信息，所以Java源代码不需要额外修改即可跨平台运行。JVM不
仅支撑着Java语言，还包括Kotlin、Scala、 Python 等其他流行语言。其中Kotlin 是
Jetbrains开发的跨平台语言,其语法简洁、类型安全,可以编译成字节码运行在JVM上，
与Java语言非常方便地进行混合编程。1999 年，Sun 公司发布公开版本的HotSpot,
它是当前主流的Java虚拟机。2006 年，在JavaOne大会上开源相关核心技术，启动
OpenJDK项目，逐步形成了活跃的OpenJDK社区。在社区的带动下，Java 生态也随
之繁荣，包括AJDK、Spring、 Hadoop、 Dubbo、 JStorm、 RocketMQ 等Java相关解决
方案，极大地提升了Java 语言的生产效率

Java语言拥有跨平台、分布式、多线程、健壮性等主要特点，是当下比较主流的
高级编程语言。它的类库相当丰富、功能强大、简单易用，对开发者相当友好，不仅
吸收了C++的优点，还摒弃了其难以掌控的多继承、指针等概念。Java比较好地实
现了面向对象理论，允许开发工程师以优雅的思维方式处理复杂的编程场景

##### 2.3 类
###### 2.3.1 类的定义
类的定义由访问级别、类型、类名、是否抽象、是否静态、泛型标识、继承或实
现关键字、父类或接口名称等组成。类的访问级别有public和无访问控制符，类型分
为class、interface、 enum

Java类主要由两部分组成成员和方法。在定义Java类时，推荐首先定义变量，
然后定义方法。由于公有方法是类的调用者和维护者最关心的方法，因此最好首屏展
示；保护方法虽然只被子类关心，但也可能是模板设计模式下的核心方法，因此重要
性仅次于公有方法；而私有方法对外部来说是一个 黑盒实现，因此一般不需要被特别
关注最后是getter/setter方法，虽然它们也是公有方法，但是因为承载的信息价值较低，
一般不包含业务逻辑，所以所有getter/setter方法须放在类最后

###### 2.3.2 接口与抽象类
正如面向对象四大特性(抽象、封装、继承、多态)所述，定义类的过程就是抽
象和封装的过程，而接口与抽象类则是对实体类进行更高层次的抽象，仅定义公共行
为和特征。接口与抽象类的共同点是都不能被实例化，但可以定义引用变量指向实例
对象。本节主要分析两者的不同之处，首先从语法上进行区分，如表2-1所示

抽象类在被继承时体现的是is-a关系，接口在被实现时体现的是can-do关系。
与接口相比，抽象类通常是对同类事物相对具体的抽象，通常包含抽象方法、实体方
法、属性变量。如果一个抽象类只有一个抽象方法，那么它就等同于一个接口。is-a
关系需要符合里氏代换原则，例如Eagle is a Bird. Bird is an Object。can-do 关系要符
合接口隔离原则，实现类要有能力去实现并执行接口中定义的行为，例如Plane can
fly. Bird can fly.中应该把fly定义成一个接口，而不是把fly()放在某个抽象类中，再
由Plane和Bird利用is-a关系去继承此抽象类。因为严格意义上讲，除fly这个行为外，
在Plane和Bird之间很难找到其他共同特征

抽象类是模板式设计，而接口是契约式设计。抽象类包含一组相对具体的特征，
性格偏内向，比如某品牌特定型号的汽车，底盘架构、控制电路、刹车系统等是抽象
出来的共同特征，但根据动感型、舒适型、豪华型的区分，内饰、车头灯、显示屏等
可以存在不同版本的实现。接口是开放的，性格偏外向，它就像一份合同， 定义了方
法名、参数、返回值，甚至抛出异常的类型。谁都可以来实现它，但如果想实现它的
类就必须遵守这份接口约定合同，比如，任何类型的车辆都必须实现如下接口：
```java
public interface VehicleSafe {
    /**
    * @param initSpeed 刹车时的初始速度
    * @param brakeTime 从initSpeed开始刹车到停止行驶的时间，单位是毫秒
    * @return 从initSpeed开始刹车到停止行驶的距高
    */
    double brake (int initSpeed, int brakeTime);
}
```
刹车是一个开放式的强制行为规范，任何车辆都必须具有刹车的能力，要明确在
特定初速度的情况下，刹车时间多久，刹车距离多长。此规范对任何车辆都是强约束
的，这就是契约

接口是顶级的“类”，虽然关键字是interface，但是编译之后的字节码扩展名还
是.class。抽象类是二当家，接口位于顶层，而抽象类对各个接口进行了组合，然后
实现部分接口行为，其中AbstractCollection是最典型的抽象类：
```java
public abstract class AbstractCollection<E> implements Collection<E> {
    // Collection定义的抽象方法，但本类没有实现
    // Collection接口定义的方法，size()这个方法对于链表和顺序表有不同的实现方式
    public abstract int size();
    
    // 实现Collection接口的这个方法，因为对AbstractCollection的子类
    // 它们判空的方式是一致的，这就是模板式设计，对干所有它的子类，实现共同的方法体，
    // 通过多态调用到子类的具体size()实现
    public boolean isEmpty() {
        //实现Collection的方法
        return size() == 0;
    }
    
    //其他属性和部分方法实现....
}
```
Java语言中类的继承采用单继承形式，避免继承泛滥、菱形继承、循环继承，甚
至“四不像”实现类的出现。在JVM中，一个类如果有多个直接父类，那么方法的
绑定机制会变得非常复杂。接口继承接口，关键字是extends，而不是implements，
允许多重继承，是因为接口有契约式的行为约定，没有任何具体实现和属性，某个实
体类在实现多重继承后的接口时，只是说明"can do many things"。当纠结定义接口
还是抽象类时，优先推荐定义为接口，遵循接口隔离原则，按某个维度划分成多个接
口，然后再用抽象类去implements某些接口，这样做可方便后续的扩展和重构

###### 2.3.3 内部类
在一个.java源文件中，只能定义一个类名与文件名完全一致的公开类，使用
public class关键字来修饰。但在面向对象语言中，任何一个类都可以在内部定义另外
一个类，前者为外部类，后者为内部类。内部类本身就是类的一个属性，与其他属性
定义方式一致。 比如，属性字段private static String str，由访问控制符、是否静态、类型、
变量名组成，而内部类private static class Inner{}，也是按这样的顺序来定义的，类型
可以为class、enum，甚至是interface，当然在内部类中定义接口是不推荐的。内部类
可以是静态和非静态的，它可以出现在属性定义、方法体和表达式中，甚至可以匿名
出现，具体分为如下四种

- 静态内部类，如： static class StaticInnerClass{};

- 成员内部类，如:：private class InstanceInnerClass{};

- 局部内部类，定义在方法或者表达式内部;

- 匿名内部类，如： (new Thread(){}).start()

如下是最精简的4种内部类定义方式：
```java
public class OuterClass {
    // 成员内部类
    private class InstanceInnerClass {}
    // 静态内部类
    static class StaticInnerClass {}
    
    public static void main(String[] args) {
        // 两个匿名内部类，分别对应图2-1所示的OuterClass$1和OuterClasss2
        (new Thread() {}).start();
        (new Thread() {}).start();
        
        // 两个方法内部类，分别对应图2-1所示的OuterClasss1MethodClass1和
        // OuterClass$1MethodClass2
        class MethodClass1 {}
        class MethodClass2 {}
    }
}
```
无论是什么类型的内部类，都会编译成一个独立的.class文件，如图2-1所示

外部类与内部类之间使用$符号分隔，匿名内部类使用数字进行编号，而方法内
部类，在类名前还有一个编号来标识是哪个方法。匿名内部类和静态内部类是比较常
用的方式。在本书的示例代码中经常使用匿名类来启动线程，节约了若干行代码。而
静态内部类是最常用的内部表现形式，外部可以使用OuterClass.StaticInnerClass直接
访问，类加载与外部类在同一个阶段进行，在JDK源码中，定义包内可见静态内部
类的方式很常见，这样做的好处是：

(1) 作用域不会扩散到包外

(2) 可以通过“外部类.内部类”的方式直接访问

(3) 内部类可以访问外部类中的所有静态属性和方法

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    volatile V val;
    volatile Node<K, V> next;
}
```
如上所示的源码是在ConcurrentHashMap中定义的Node静态内部类，用于
表示一个节点数据，属于包内可见，包内其他集合要用到这个Node时，直接使用
ConcurrentHashMap.Node。仅包内可见，可以阻止外部程序随意使用此类来生成对
象，Node的父类Entry是Map的静态内部类，之所以可以被Node成功继承，是
因为两个外部类同属一个包。在JDK源码中，使用内部类封装某种属性和操作的
方式比较常见，比如应用类加载器Launcher的AppClassLoader， ReentrantLock 中
继承自AbstractQueuedSynchronizer的内部类Sync，ArrayList中的私有静态内部类
SubList。内部类中还可以定义内部类，形成多层嵌套，如在ThreadLocal静态内部类
ThreadLocalMap中还定义一个内部类Entry，如图2-2所示

因为访问权限可见，所以在同一包内的Thread可以直接使用如下方式声明自己
的属性：
```java
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
```

###### 2.3.4 访问权限控制
面向对象的核心思想之一就是封装， 只把有限的方法和成员公开给别人，这也是
迪米特法则的内在要求，使外部调用方对方法体内的实现细节知道得尽可能少。如何
实现封装呢?需要使用某些关键字来限制类外部对类内属性和方法的随意访问，这些
关键字就是访问权限控制符。在详细介绍访问权限之前，我们明确一个概念——是否
可见，如下示例代码：
```java
package a;
public class VisibleScope {
    public void publicMethod() {}
    protected void protectedMethod() {}
    void noneMethod() {}
    private void privateMethod() {}
}
```
在package b中，图2-3左侧对VisibleScope类进行实例化，通过引用变量，仅
能看到publicMethod()方法，我们称为publicMethod()方法是当前可见的；使用同一
个类，图2-3右侧对VisibleScope子类VisibleScopeInvoke进行实例化，通过引用变量，
可以看到两个方法，新增了红色框内的protectedMethod()方法，那么这两个方法是当
前可见的；如果这个类也在package a中，那么noneMethod是可见的；在任何情况下，
类外部实例化出来的对象均无法调用私有方法，比如本示例中的privateMethod方法

- public：可以修饰外部类、属性、方法，表示公开的、无限制的，是访问限
制最松的一级,被其修饰的类、属性和方法不仅可以被包内访问，还可以跨类、
跨包访问，甚至允许跨工程访问

- protected：只能修饰属性和方法，表示受保护的、有限制的，被其修饰的属
性和方法能被包内及包外子类访问。注意，即使并非继承关系，protected 属
性和方法在同一包内也是可见的

- 无：即无任何访问权限控制符，如示例中的noneMethod方法，没有任何
修饰符。千万不要说成default，它并非访问权限控制符的关键字，另外，在
JDK8接口中引入default默认方法实现，更加容易混淆两者释义。无访问权
限控制符仅对包内可见。虽然无访问权限控制符还可以修饰外部类，但是定
义外部类极少使用无控制符的方式，要么定义为内部类，功能内聚；要么定
义公开类，即public class，包外也可以实例化

- private：只能修饰属性、方法、内部类。表示“私有的”，是访问限制最严
格的一-级，被其修饰的属性或方法只能在该类内部访问，子类、包内均不能
访问，更不允许跨包访问

由此可见，不同的访问权限控制符对应的可见范围不同。在定义类时，要慎重思
考该方法、属性、内部类的访问权限，提倡严控访问范围。过于宽泛的访问范围不利
于模块间解耦及未来的代码维护。试想，在进行代码重构时，private方法过旧，我们
可以直接删除，且无后顾之忧。可是如果想删除一个public的方法，是不是要谨慎又
谨慎地检查是否被调用。变量就像自己的小孩，要尽量控制在自己的视线范围内，如
果作用域太大，无限制地到处乱跑，就会担心其安危。因此，在定义类时，推荐访问
控制级别从严处理：

(1) 如果不允许外部直接通过new创建对象，构造方法必须是private

(2) 工具类不允许有public或default构造方法

(3) 类非static成员变量并且与子类共享，必须是protected

(4) 类非static成员变量并且仅在本类使用，必须是private

(5 )类static成员变量如果仅在本类使用，必须是private

(6 )若是static成员变量，必须考虑是否为final

(7) 类成员方法只供类内部调用，必须是private

(8) 类成员方法只对继承类公开，那么限制为protected

###### 2.3.5 this与super
对象实例化时，至少有一条从本类出发抵达Object的通路，而打通这条路的两
个主要工兵就是this和super，逢山开路，遇水搭桥。但是this和super往往是默默无
闻的，在很多情况下可以省略，比如：

- 本类方法调用本类属性

- 本类方法调用另一个本类方法

- 子类构造方法隐含调用super()

任何类在创建之初，都有一个默认的空构造方法，它是super()的一条默认通路。
构造方法的参数列表决定了调用通路的选择；如果子类指定调用父类的某个构造方法，
super就会不断往上溯源；如果没有指定，则默认调用super()。如果父类没有提供默
认的构造方法，子类在继承时就会编译错误，如图2-4所示

如果父类坚持不提供默认的无参构造方法，必须在本类的无参构造方法中使用
super方式调用父类的有参构造方法，如public Son(){ super(123); }

一个实例变量可以通过this.赋值另一个实例变量；一个实例方法可以通过this.
调用另一个实例方法；甚至一个构造方法都可以通过this.调用另一个构造方法。如
果this和super指代构造方法，则必须位于方法体的第一行。换句话说，在一个构造
方法中，this和super只能出现一个，且只能出现一次，否则在实例化对象时，会因
子类调用到多个父类构造方法而造成混乱

由于this和super都在实例化阶段调用，所以不能在静态方法和静态代码
块中使用this和super关键字。this还可以指代当前对象，比如在同步代码块
synchronized(this)...}中，super并不具备此能力。但super也有自己的特异功能，在
子类覆写父类方法时，可以使用super调用父类同名的实例方法。最后总结一下this
和super的异同点，如图2-5所示

###### 2.3.6 类关系
关系是指事物之间存在单向或相互的作用力或者影响力的状态。类与类之间的关
系可分成两种：有关系与没关系，这似乎是一句非常正确的废话，难点在于确定类与
类之间是否存在相互作用。证明类之间没关系是一个涉及业务、架构、模块边界的问
题，往往由于业务模型的抽象角度不同而不同，是一件非常棘手的事情。如果找到了
没有关系的点，就可以如庖丁解牛一样，进行架构隔离、模块解耦等工作。有关系的
情况下，包括如下5种类型：

- [继承 ] extends (is-a)

- [实现] implements (can-do)

- [组合] 类是成员变量(contains-a)

- [聚合] 类是成员变量(has-a)

- [依赖] import类(use-a)

继承和实现是比较容易理解的两种类关系。在架构设计中，要注意组合、聚合和
依赖这三者的区别

组合在汉语中的含义是把若干个独立部分组成整体，各个部分都有其独立的使用
价值和生命周期。而类关系中的组合是一种完全绑定的关系， 所有成员共同完成一件
使命，它们的生命周期是一样的。组合体现的是非常强的整体与部分的关系，同生共
死，部分不能在整体之间共享

聚合是一种可以拆分的整体与部分的关系，是非常松散的暂时组合，部分可以被
拆出来给另一个整体

依赖是除组合和聚合外的类与类之间的关系，这个类只要import，那就是依赖关系

在类图中，用空心的三角形表示继承，用实心的菱形表示组合，用空心的菱形表
示聚合，这三者都是用实线连接的。用三角形来表示实现，用一个箭头表示依赖，与
前面的区别是这两者都是用虚线连接的。在画类图时，菱形、箭头、三角形放在哪一
侧呢?在很多类图中，这个处理是非常随意的。如果方向画反了，那么类结构的认知
也就反了。有一个规律，有形状的图形符号一律放在权力强的这一侧，如表2-3所示

随着业务和架构的发展，类与类的关系是会发生变化的，必须用发展的眼光看待
类图。比如表2-3中的Body和Head，如果有一天，动物的脑袋可以随意地移植，那
么就从组合关系变成聚合关系了。狗与狗绳之间的约束，虽然很弱，但是如果防疫局
在狗绳上标记疫苗记录，那么它们之间的关系就会变强，就变成组合关系了。在业务
重构过程中，往往会把原来强组合的关系拆开来，供其他模块调用，这就是类图的一
种演变

###### 2.3.7 序列化







##### 2.4 方法







###### 2.4.1 方法签名







###### 2.4.2 参数






###### 2.4.3 构造方法






###### 2.4.4 类内方法






###### 2.4.5 getter与setter






###### 2.4.6 同步与异步






###### 2.4.7 覆写






##### 2.5 重载






##### 2.6 泛型






##### 2.7 数据类型






###### 2.7.1 基本数据类型







###### 2.7.2 包装类型







###### 2.7.3 字符串


























