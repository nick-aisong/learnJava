#### 第5章 异常与日志
人类在日常活动中常常会遇到各种各样不可预料的问题，比如为了保证准时乘坐
某一航班，早早赶到了机场，却因忘带身份证件而导致无法登机，或者由于突降大雨
而使航班延迟起飞等都会使得我们的活动受阻。系统工程亦是如此，无论保护措施如
何完善，事前预案如何周密，异常现象或多或少、或早或迟地都会发生。系统发生异
常后，往往需要人工介入处理，否则将会扩大异常影响面，或者引发新的异常。在计
算机世界中，在运行程序时，发生了意料之外的事件，阻止了程序的正常执行，这种
情况被称为程序异常。处理程序异常，需要解决以下3个问题：

(1) 哪里发生异常?

(2) 谁来处理异常?

(3 )如何处理异常?

这三个问题就像把大象装进冰箱的三个步骤一样， 听来轻松，但实际上很难准确
操控，即使是有经验的程序员，处理起来也会难以应付。下面就围绕这三个问题来探
讨如何才能建立一套完善的异常处理机制

首先，需要明确在哪里发生异常。在代码中通过try-catch来发现异常，但是有些
程序员往往将大段代码定义在一个try-catch块内，这样非常不利于定位问题，是一种
不负责任的做法。捕获异常时需要分清稳定代码和非稳定代码，稳定代码指的是无论
如何都不会出错的代码，例如int a = 0。异常捕获是针对非稳定代码的，捕获时要区
分异常类型并做相应的处理。比如，当用户输入了错误的用户名，提示用户账号错误；
正确的用户名下，错误的密码请重试；重试次数超过限制，则封锁账户等

其次，判断谁来处理异常，在回答这个问题之前，需要明确两个关键字throw和
throws的区别，如下是数据访问层生成订单Id的示例代码：
```java
public Long generateOrderId(Long userId) throws DAOException {
    try {
        return orderIdSequence.nextValue() * 1000 + (userId * 1000) + (userId / 1000);
    } catch(Exception e) {
        throw new DAOException("Sequence error, userId=" + userId, e);
    }
}
```
在与数据库交互时可能会发生网络连接不通、数据库锁超时、插入数据失败等异
常，向上归一化为DAOException异常。这里的throw是方法内部抛出具体异常类对
象的关键字，而throws则用在方法signature上，表示方法调用者可以通过此方法声
明向上抛出异常对象

了解了throw和throws的作用后，我们再来判断当前被捕获的异常是否需要自
己处理。如果异常在当前方法的处理能力范围之内且没有必要对外透出，那么就直接
捕获异常并做相应处理；否则向上抛出，由上层方法或者框架来处理

最后，无论采用哪种方式处理异常，都严禁捕获异常后什么都不做或打印一行日
志了事。如果在方法内部处理异常，需要根据不同的业务场景进行定制处理，如重试、
回滚等操作。如果向上抛出异常，如上例所示，需要在异常对象中添加上下文参数、
局部变量、运行环境等信息，这样有利于排查问题

##### 5.1 异常分类
JDK中定义了一套完整的异常机制，所有异常都是Throwable的子类，分
为Error(致命异常)和Exception(非致命异常)。Error是一种非常特殊的异
常类型，它的出现标识着系统发生了不可控的错误，例如StackOverflowError、
OutOfMemoryError。针对此类错误，程序无法处理，只能人工介入。Exception又分
为checked异常(受检异常)和unchecked异常(非受检异常)

checked异常是需要在代码中显式处理的异常，否则会编译出错。如果能自行处
理则可以在当前方法中捕获异常；如果无法处理，则继续向调用方抛出异常对象。
常见的checked异常包括JDK中定义的SQLException、ClassNotFoundException等。
checked异常可以进一 步细分为两类：

- 无能为力、引起注意型。针对此类异常，程序无法处理，如字段超长等导致
的SQLException，即使做再多的重试对解决异常也没有任何帮助，一般处理
此类异常的做法是完整地保存异常现场，供开发工程师介入解决

- 力所能及、坦然处置型。如发生未授权异常(UnAuthorizedException)，程
序可跳转至权限申请页面

在Exception中，unchecked异常是运行时异常，它们都继承自RuntimeException，
不需要程序进行显式的捕捉和处理，unchecked异常可以进一步细分为3类：

- 可预测异常(Predicted Exception)：常见的可预测异常包括
IndexOutOfBoundsException、NullPointerException等，基于对代码的性能和
稳定性要求，此类异常不应该被产生或者抛出，而应该提前做好边界检查、
空指针判断等处理。显式的声明或者捕获此类异常会对程序的可读性和运行
效率产生很大影响

- 需捕捉异常(Caution Exception)，例如在使用Dubbo框架进行RPC调用时
产生的远程服务超时异常DubboTimeoutException，此类异常是客户端必须显
式处理的异常，不能因服务端的异常导致客户端不可用，此时处理方案可以
是重试或者降级处理等

- 可透出异常(Ignored Exception)，主要是指框架或系统产生的且会自行处理
的异常，而程序无须关心。例如针对Spring 框架中抛出的NoSuchRequestHa
ndlingMethodException异常，Spring 框架会自己完成异常的处理，默认将自
身抛出的异常自动映射到合适的状态码，比如启动防护机制跳转到404页面

综上所述，异常分类结构如图5-1所示

为了加深理解，下面我们结合出国旅行的例子说明一下异常分类

第一，机场地震，属于不可抗力，对应异常分类中的Error。 在制订出行计划时，
根本不需要把这个部分的异常考虑进去

第二，堵车属于checked异常，应对这种异常，我们可以提前出发，或者改签机票。
而飞机延误异常，虽然也需要check，但我们无能为力，只能持续关注航班动态

第三，没有带护照，明显属于可提前预测的异常，只要出发前检查即可避免。去
机场路上车子抛锚，这个异常是突发的，虽然难以预料，但是必须处理，属于需要捕
捉的异常，可以通过更换交通工具应对。检票机器故障则属于可透出异常，交由航空
公司处理，我们无须关心

全面了解了异常分类之后，当遇到需要处理异常的场景时，要明确该异常属
于哪种类型，是需要调用方关注并处理的checked异常，还是由更高层次框架处
理的unchecked异常。不论是哪一类异常。如果需要向上抛出，推荐的做法是根
据当前场景自定义具有业务含义的异常，为了避免异常泛滥，可以优先使用业界
或者团队已定义过的异常。例如，远程服务调用中发生服务超时会抛出自定义的
DubboTimeoutException，而不是直接抛出RuntimeException，更不是抛出Exception
或Throwable

###### 5.2 try代码块
try-catch-finally是处理程序异常的三部曲。当存在try时，可以只有catch代码块，
也可以只有finally代码块，就是不能单独只有try这个光杆司令。下面分别说一下各
个代码块的作用

(1) try代码块：监视代码执行过程，一但发现异常则直接跳转至catch，如果
没有catch，则直接跳转至finally

(2) catch代码块：可选执行的代码块，如果没有任何异常发生则不会执行；如
果发现异常则进行处理或向上抛出。这一切都在catch代码块中执行

(3) finally代码块：必选执行的代码块，不管是否有异常产生，即使发生
OutOfMemoryError也会执行，通常用于处理善后清理工作。如果finally代码块没有
执行，那么有三种可能：

- 没有进入try代码块

- 进入try代码块，但是代码运行中出现了死循环或死锁状态

- 进入try代码块，但是执行了System.exit()操作

注意，finally是在return表达式运行后执行的，此时将要return的结果已经被暂
存起来，待finally代码块执行结束后再将之前暂存的结果返回，示例代码如下：

```java
public static int finallyNotWork() {
    int temp = 10000;
    try {
        throw new Exception();
    } catch (Exception e) {
        return ++temp;
    } finally {
        temp = 99999;
    }
}
```
此方法最终的返回值是10001，而不是99999，字节码忠实地给出了答案：
```text
// 对变量temp进行+1操作
IINC 0 1
ILOAD 0
// return表达式的计算结果存储在slot_2上
ISTORE 2
// finally 存储99999到slot_0上
LDC 99999
ISTORE 0
// 方法返回的时候，直接提取的是slot_2的值，即10001
ILOAD 2
IRETURN
```
我们分析finally的脾气秉性，是为了避免用错，而不是深入地分析为什么JVM
不支持这样的赋值方式。finally代码块的职责不在于对变量进行赋值等操作，而是清
理资源、释放连接、关闭管道流等操作，此时如果有异常也要做try-catch

相对在finally代码块中赋值，更加危险的做法是在finally块中使用return操作，
这样的代码会使返回值变得非常不可控，警示代码如下：
```java
public class TryCatchFinally {
    static int X = 1;
    static int y = 10;
    static int z = 100;
    
    public static void main(String[] args) {
        int value = finallyReturn();
        System.out.println("value=" + value);
        
        System.out.println("x=" + x) ;
        System.out.println("y=" + y) ;
        System.out.println("z=" + z) ;
    }
    
    public static int finallyReturn() {
        try {
            // ...
            return ++x;
        } catch(Exception e) {
            return ++y;
        } finally {
            return ++z;
        }
    }
}
```
执行结果如下：
```text
value=101
x=2
y=10
z=101
```
以上执行结果说明：

(1) 最后return的动作是由finally代码块中的return ++z完成的，所以方法返回的结果是101

(2) 语句return ++x中的++x被成功执行，所以运行结果是x=2

(3) 如果有异常抛出，那么运行结果将会是y=11，而x=1

finally代码块中使用return语句，使返回值的判断变得复杂，所以避免返回值不
可控，我们不要在finally代码块中使用return语句

最后分析try代码块与锁的关系，lock方法可能会抛出unchecked异常，如果放
在try代码块中，必然触发finally中的unlock方法执行。对未加锁的对象解锁会抛
出unchecked异常，如IllegalMonitorStateException，虽然是因为加锁失败而造成程
序中断的，但是真正加锁失败的原因可能会被后者覆盖。所以在try代码块之前调用
lock()方法，避免由于加锁失败导致finally调用unlock()抛出异常。警示代码中的红
色代码应该移到try代码块的上方，如下所示

```java
Lock lock = new XxxLock();
preDo();
try {
    // 无论加锁是否成功，unlock都会执行,应该吧lock()移到try代码块的上方
    lock.lock();
    doSomething();
} finally {
    lock.unlock();
}
```
Lock、ThreadLocal、InputStream等这些需要进行强制释放和清除的对象都得在
finally代码块中进行显式的清理，避免产生内存泄漏，或者资源消耗

###### 5.3 异常的抛与接
在谍战剧里的行动信息传递中，信息的传递方与接收方是需要严格匹配的，比如
窗口放置一盆花，表示有紧急异常情况，行动取消；窗帘拉开，表示情况正常，可以
行动。一旦传递方信息传递错误，或者接收方理解错误，都会有严重的后果。同样，
异常的抛与接，也一样需要严格的对等传递异常信息机制。我们要使捕获的异常与被
抛出的异常是完全匹配的，或者捕获的异常是被抛出异常的父类

传递异常信息的方式是通过抛出异常对象，还是把异常信息转成信号量封装在特
定对象中，这需要方法提供者和方法调用者之间达成契约，只有大家都照章办事，才
不会产出误解。推荐对外提供的开放接口使用错误码；公司内部跨应用远程服务调用
优先考虑使用Result对象来封装错误码、错误描述信息；而应用内部则推荐直接抛出
异常对象

为什么在远程服务调用中推荐使用Result对象封装异常信息?如果使用抛异常
的返回方式，一旦调用方没有捕获，就会产生运行时错误，导致程序中断。此外，如
果抛出的异常中不添加栈信息，只是new自定义异常并加入自定义的错误信息，对于
调用端解决问题的帮助不会太大。如果加了栈信息，在频繁调用出错的情况下，信息
序列化和传输的性能损耗也是问题。

我们都知道空指针异常(NPE)是程序世界里最常见的异常之一，为了避免出现
NPE，应该是提供方需要明确可以返回null值，调用方进行非空判断，还是服务方保
证返回类似于Optional、空对象或者空集合?这个争论直到某次断网演练时才有了定
论。服务A与服务B在同一机房，是超级稳定的服务依赖，服务可用率接近100%，
因为服务B已经明确不会返回null，所以约定调用方A中不需要做空值判断。但是
断网演练开始后，无法调用到服务B，此时连空集合都无法返回，所以在演练时间内
服务A频繁抛出NPE。自此之后，契约式编程理念就完全处于防御式编程理念的下风，
所以我们推荐方法的返回值可以为null，不强制返回空集合或者空对象等，但是必须
添加注释充分说明什么情况下会返回null值。防止NPE一定是调用方的责任，需要
调用方进行事先判断

##### 5.4 日志
"日志”这个词最早见于航海领域，是记录航行主要情况的载体文件，内容包括
操作指令、气象、潮流、航向、航速、旅客、货物等，是处理海事纠纷或者海难的原
始依据之一。尔后延伸到航空领域，黑匣子就是一个重要的航空日志载体，调查空难
原因时第一反应是找到黑匣子，并通过解析其中的日志信息来还原空难的事实真相

同理，记录应用系统日志主要有三个原因：记录操作轨迹、监控系统运行状况、
回溯系统故障

记录操作行为及操作轨迹数据，可以数据化地分析用户偏好，有助于优化业务逻
辑，为用户提供个性化的服务。例如，通过access.log记录用户的操作频度和跳转链接，
有助于分析用户的后续行为

全面有效的日志系统有助于建立完善的应用监控体系，由此工程师可以实时监控
系统运行状况，及时预警，避免故障发生。监控系统运行状况，是指对服务器使用状
态，如内存、CPU等使用情况；应用运行情况，如响应时间，QPS等交互状态；应
用错误信息，如空指针、SQL异常等的监控。例如，在CPU使用率大于60%，四核
服务器中load大于4时发出报警，提醒工程师及时处理，避免发生故障

当系统发生线上问题时，完整的现场日志有助于工程师快速定位问题。例如当系
统内存溢出时，如果日志系统记录了问题发生现场的堆信息，就可以通过这个日志分
析是什么对象在大量产生并且没有释放内存，回溯系统故障，从而定位问题

###### 5.4.1 日志规范
为了统一认知，降低沟通和学习成本，应用中的扩展日志命名方式应该有统一
的约定，通过命名能直观明了地表明当前日志文件是什么功能，如监控、访问日志
等。推荐的日志文件命名方式为：appName_logType_logName.log。 其中，logType为
日志类型，推荐分类有stats、monitor、visit等；logName为日志描述。这种命名的
好处是通过文件名就可以知道日志文件属于什么应用，什么类型，什么目的，也有利
于归类查找。例如，mppserver应用中单独监控时区转换异常的日志文件名定义为：
mppserver_monitor_timeZoneConvert.log

以上对日志名称进行了约定，将工程师从纷繁复杂的日志命名中解放出来，而困
扰工程师的另一个问题是日志文件需要保存多久呢?由于存储空间有限，日志不可能
永久地存储在磁盘中，文件的生命周期应该如何定义呢?如果日志存储周期较短，如
7天，那么针对有些具备以“周”为频次发生的异常就无法被发现；相反，若日志保
存周期过长，又会对磁盘存储空间造成较大压力，产生不必要的资源消耗。因此综合
两个方面考虑，代码规约推荐日志文件至少保存15天，可以根据日志文件的重要程度、
文件大小及磁盘空间再自行延长保存时间

日志是有级别的。针对不同的场景，日志被分为五种不同的级别，按照重要程度
由低到高排序：

- DEBUG 级别日志记录对调试程序有帮助的信息

- INFO 级别日志用来记录程序运行现场，虽然此处并未发生错误，但是对排
查其他错误具有指导意义

- WARN 级别日志也可以用来记录程序运行现场，但是更偏向于表明此处有出
现潜在错误的可能

- ERROR 级别日志表明当前程序运行发生了错误，需要被关注。但是当前发
生的错误，没有影响系统的继续运行

- FATAL 级别日志表明当前程序运行出现了严重的错误事件，并且将会导致应
用程序中断

可以看出，以上不同级别的日志优先级和重要性不同，因此在打印日志时针对不
同的日志级别要有不同的处理方式

1. 预先判断日志级别

对DEBUG、INFO级别的日志，必须使用条件输出或者使用占位符的方式打印。
该约定综合考虑了程序的运行效率和日志打印需求。例如，在某个配置了打印日志
级别为WARN的应用中，如果针对DEBUG级别的日志，仅仅在程序中写出
```logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);```
，那么该日志不会被打印，但是会执行字符串拼接操作；如果symbol是对象，还会执行toString()
方法，白白浪费了系统资源。如下示例代码为正确的打印日志方式：

```java
// 使用条件判断形式
if (logger.isDebugEnabled()) {
    logger.debug("Processing trade with id: " + id + " and symbol:" + symbol);
}

// 使用占位符形式
logger.debug("Processing trade with id: {} and symbol: {}", id, symbol);
```

2. 避免无效日志打印

生产环境禁止输出DEBUG日志且有选择地输出INFO日志

使用INFO、WARN级别来记录业务行为信息时，一定要控制日志输出量，以免
磁盘空间不足。同时要为日志文件设置合理的生命周期，及时清理过期的日志

避免重复打印，务必在日志配置文件中设置additivity-false，示例如下：
```xml
<logger name="com.taobao.ecrm.member.config" additivity="false">
```

3. 区别对待错误日志

WARN、ERROR都是与错误有关的日志级别，但不要一发生错误就笼统地输出
ERROR级别日志。一些业务异常是可以通过引导重试就能恢复正常的，例如用户输
入参数错误。在这种情况下，记录日志是为了在用户咨询时可以还原现场，如果输出
为ERROR级别就表示一旦出现就需要人为介入，这显然不合理。所以，ERROR级
别只记录系统逻辑错误、异常或者违反重要的业务规则，其他错误都可以归为WARN
级别

4. 保证记录内容完整

日志记录的内容包括现场上下文信息与异常堆栈信息，所以打印时需要注意以下
两点：

(1) 记录异常时一定要输出异常堆栈，例如logger.error("xxx" + e.getMessage(), e)

(2) 日志中如果输出对象实例，要确保实例类重写了toString方法，否则只会
输出对象的hashCode值，没有实际意义

综上所述，日志是一个系统必不可少的组成部分，但日志打印并非多多益善，过
多的日志会降低系统性能，也不利于快速定位问题，所以记录日志时一定请思考三个
问题：①日志是否有人看；②看到这条日志能做什么；③能不能提升问题排查效率

###### 5.4.2 日志框架
说到日志工具，日常工作或学习中肯定听过这些名词：log4j、logback、jdk-
logging、slf4j、commons-logging等，它们之间有什么关系，在整个日志体系中又扮
演什么角色呢?日志框架分为三大部分，包括日志门面、日志适配器、日志库。利用
门面设计模式，即Facade来进行解耦，使日志使用变得更加简单，如图5-2所示

1. 日志门面

门面设计模式是面向对象设计模式中的一种，日志框架采用的就是这种模式，类
似JDBC的设计理念。它只提供一套接口规范，自身不负责日志功能的实现，目的是
让使用者不需要关注底层具体是哪个日志库来负责日志打印及具体的使用细节等。目
前用得最为广泛的日志门面有两种：slf4j和commons-logging

2. 日志库

它具体实现了日志的相关功能，主流的日志库有三个，分别是log4j、log-jdk、
logback。最早Java要想记录日志只能通过System.out或System.err来完成，非常不方便。
log4j就是为了解决这一问题而提出的， 它是最早诞生的日志库。接着JDK也在1.4版
本引入了一个日志库java.util.logging.Logger，简称log-jdk。这样市面上就出现两种日志
功能的实现，开发者在使用时需要关注所使用的日志库的具体细节。logback是最晚出
现的，它与log4j出自同一个作者，是log4j的升级版且本身就实现了slf4j的接口

3. 日志适配器

日志适配器分两种场景：

(1) 日志门面适配器，因为slf4j规范是后来提出的，在此之前的日志库是没有
实现sIf4j的接口的，例如log4j：所以，在工程里要想使用slf4j+log4j的模式，就额
外需要一个适配器(slf4j-log4j12)来解决接口不兼容的问题

(2) 日志库适配器，在一些老的工程里，一开始为了开发简单而直接使用了日
志库API来完成日志打印，随着时间的推移想将原来直接调用日志库的模式改为业界
标准的门面模式(例如slf4j+logback组合)，但老工程代码里打印日志的地方太多, 
难以改动，所以需要一个适配器来完成从旧日志库的API到sIf4j的路由，这样在不
改动原有代码的情况下也能使用slf4j来统一管理日志，而且后续自由替换具体日志
库也不成问题

我们了解了日志家族里的成员及其作用，接下来将以Maven工程为例介绍如何
在工程里进行日志集成

如果是新工程，则推荐使用slf4j+logback模式。因为logback自身实现了slf4j的
接口，无须额外引入适配器，另外logback是log4j的升级版，具备比log4j更多的优点，
可通过如下配置进行集成：
```xml
<dependency>
    <groupid>org.slf4j</groupid>
    <artifactid>slf4j-api</artifactid>
    <version>${slf4j-api.version}</version>
</dependency>
<dependency>
    <groupid>ch.qos.logback</groupid>
    <artifactid>logback-classic</artifactid>
    <version>${logback-classic.version}</version>
</dependency>
<dependency>
    <groupid>ch.qos.logback</groupid>
    <artifactid>logback-core</artifactid>
    <version>${logback-core.version}</version>
</dependency>
```
如果是老工程，则需要根据所使用的日志库来确定门面适配器，通常情况下老工
程使用的都是log4j，因此以log4j日志库为例，可通过如下配置进行集成：
```xml
<dependency>
    <groupid>org.slf4j</groupid>
    <artifactid>slf4j-api</artifactid>
    <version>${slf4j-api.version}</version>
</dependency>
<dependency>
    <groupid>org.slf4j</groupid>
    <artifactid>slf4j-log4j12</artifactid>
    <version>${slf4j-1og4j12.version}</version>
</dependency>
<dependency>
    <groupid>log4j</groupid>
    <artifactid>log4j</artifactid>
    <version>${1og4j.version}</version>
</dependency>
```
如果老代码中直接使用了log4j日志库提供的接口来打印日志，则还需要引入日
志库适配器，配置实例如下所示：
```xml
<dependency>
    <groupid>org.slf4j</groupid>
    <artifactid>log4j-over-slf4j</artifactid>
    <version>${log4j-over-slf4j.version}</version>
</dependency>
```
至此我们的工程就完成了日志框架的集成，再加上一个日志配置文件(如
logback.xml、log4j.xml 等)，并在工程启动时加载，然后就可以进行日志打印了，示
例代码如下：
```java
private static final Logger logger = LoggerFactory.getLogger(Abc.class);
```
注意，logger被定义为static变量，是因为这个logger与当前类绑定，避免每次
都new一个新对象，造成资源浪费，甚至引发OutOfMemoryError问题

另外，在使用slf4j+日志库模式时，要防止日志库冲突，一旦发生则可能会出现
日志打印功能失效的问题。例如，某个业务的网站页面出现了500错误，但开发工程
师翻遍整个系统的日志文件都没有发现任何异常日志。线下模拟调试发现：错误发生
时有异常对象抛出并被框架捕获，然后执行了日志打印的相关代码，但实际没有输出
到日志文件。经开发工程师深入排查，当前工程代码中配置的日志库为log4j，但工
程依赖的一个jar包间接地引入了logback日志库，导致打印日志的Logger引用实际
指向ch.qos.logback. classic.Logger对象，二者的冲突引发了日志打印失效的问题
