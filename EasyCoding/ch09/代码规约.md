#### 第9章 代码规约
##### 9.1 代码规约的意义
别人都说程序员是“搬砖”的码农，但我们知道自己是追求个性的艺术家。也许
我们不会过多在意自己的外表和穿着，但在不羁的外表下，骨子里追求着代码的美、
系统的美、设计的美，代码规约其实就是对程序美的一个定义。但是这种美离程序员，
的生活有些遥远，尽管代码规约的价值在业内有着广泛的共识，然而在现实中执行得
并不是很好。程序员曾经最引以为豪的代码，因为代码规约的缺失严重制约了相互之
间的高效协同，频繁的系统重构和心惊胆战的维护似乎成了工作的主旋律，如何走出
这种怪圈呢?众所周知，互联网公司的效能是企业的核心竞争力，体现在开发领域上，
其实就是沟通效率和研发效率。沟通效率的重要性可以从程序员三大“编程理念之争”
(如图9-1所示)说起：

- 缩进采用空格键，还是Tab键
- if单语句需要大括号，还是不需要大括号
- 左大括号不换行，还是单独另起一行

其中，if单语句是否需要大括号是争论不休的话题。相对来说，写过格式缩进类
编程语言(比如Python)的开发工程师，更加习惯于不加大括号。因为单语句的写法，
继续添加其他语句时，容易引起视觉上的错误判断导致程序逻辑问题，所以我们提倡
if、for、while单语句必须加大括号。此外，不加大括号还可能会导致作用域问题：
```java
public class IfSingleStatementTest {
    public static void main(String[] args) {
        // 以下三句均编译报错: declaration not allowed here
        if (true) int x;
        for(; ; ) int y;
        while (true) int z;
    }
}
```
有程序员想当然地认为编译会通过，最多出现警告提示：variable is never used。
实际上，编译报错为declaration not allowed here。单语句在没有加大括号的情况
下，声明的变量不可能再被使用，编译器认为没有任何意义，参考官方说明：Every
declaration that introduces a name has a scope, in which they can be used.

这些理念之争的本质就是程序员多年代码习惯生了茧，不愿意对不一样的代码风
格妥协。很多代码风格客观.上没有对与错，但是一致性很重要，可读性很重要，团队
沟通效率很重要。帕金森琐碎定律是指团队成员往往会把过多的精力花费在一些琐碎
的争论上，而真正重要的决议反而可以轻松通过。在代码风格上，团队不需要进行过
多的讨论、争论，而应该把更多的精力放在重要问题的沟通和协调上。个性化应尽量
表现在系统架构和算法效率的提升上，而不是独特的代码风格上

原始社会的部落冲突讲究个人蛮力，现代化战争则需要海陆空多兵种联合作战，
软件工程亦是如此。从软件小作坊发展到现在，凭一人之力编写大型软件系统已经是
不可能的了。跨团队的联合开发越来越常见，需要一定的规范来保障沟通的有效性。
如果规范不一，就像图9-2中的小鸭和小鸡对话一样，言语不通，一脸囧相。鸡同鸭
讲也恰恰形容了人与人之间沟通的痛点，自说自话，无法沟通

代码规约除代码风格之外，还应该包括异常日志、数据库规约、安全规约、单元
测试等相关领域，旨在提升开发工程师之间的沟通效率，本书的书名“码出高效”指
的就是高效沟通与协作。大雁是一种非常讲究团队配合的鸟类，它们飞翔的队形可以
有效地减少空气阻力。所以，封面选择大雁作为背景，传递团队沟通与协作的理念，
顺利达到共同的目标。虽然代码规约的价值是明确的，但是要避免对代码规约有如下
错误认识：

1. 代码规约消灭创造力
 
程序员对代码的创造力与业务理解、建模能力、架构设计等都有关系。有人认为，
代码规约是把程序员变成流水线上的工人，消灭创造力。非要类比的话，代码规约只
是墙上的安全生产规范，并非定义工作内容本身(这才是程序员真正发挥创造力的地
方)，代码规约让代码生产更加有序、更加高效

2. 代码本人理解就行

代码是给三个群体看的：编译器、编写者、维护者。编译器需要代码符合语法；
编写者需要代码符合自己的编程风格；维护者需要代码可读性强。在软件生命周期内，
编译器的时间单位是“秒”，编写者的时间单位是“天”，维护者的时间单位是“年”。
编写者有可能成为维护者。此外，一个人对于团队的价值，取决于他的稀缺性。有些
程序员认为自己写的代码只有自己能够看懂，比如if-else嵌套5层，再来一个for循环，
才能显示出个人的不可替代性。实际上，写代码的时候，应该多从团队利益、公司战
略的角度考虑，遵从统一的代码规约，助人也是助己，在维护自己代码的时候，也会
更加从容

3. 一成不变的代码不需要规范

代码部署到服务器上稳定运行后，即使没有任何功能的增加或删除，也不是永远
不需要修改的。代码具有时间维度、机器维度、框架维度等相关属性。时间维度，比
如千年虫问题或2038问题等；机器维度，比如机器过保或机器换代等；框架维度，
比如JDK升级或框架安全风险等。举个例子，JDK6升级到JDK7必须要及时修改代码，
使Comparator满足JDK7的新要求，否则Arrays.sort会拋异常。诚如哲学家所述“人
不能两次踏进同一条河流”，代码的每一次部署 ，也是不可能完全相同的。所以没有
一成不变的代码

4. 代码规约必须符合所有人的习惯

如果一双鞋适合所有人的脚，那绝对是一双废鞋。 代码规约并不是寻找最优解，
而是寻找认知中的最大公约数。如果一个餐馆日料、法餐、湘菜、杭帮菜都做的话，
必然不是一个好餐馆。舍得，就是舍去小部分的意志，得到大格局上的成功。在制订
代码规约的过程中，一些规则向左走或向右走都有自身的合理性。比如返回集合时，
是否允许return null值的问题，可归结为防御式编程理念与契约式编程理念不同的处
理方式。积累多次教训后，我们提倡防御式编程理念，明确允许返回为null值。在共
识的规约面前，我们应该放下成见，牺牲小我，成就大我

综上所述，代码规约的意义如下：

(1) 码出高效。标准统一，提升沟通效率和协作效率，促使研发效能的提升

(2) 码出质量。防患未然，提升质量意识，降低故障率和维护成本，快速定位问题

(3) 码出情怀。追求卓越的工匠精神，打磨精品代码

##### 9.2 如何推动落地
任何出发点多么美好的规章制度，如果没有被落地执行到位，也终将是一纸空文。
如何落地，上令下达，往往是很多标准类文件的痛点。在制订团队代码规约的时候，
往往是一帆风顺的，但是真正到实际执行层面的时候，规约落地的过程总会遇到各种
推三阻四的情况。我们可以尝试从三个方面推动落地：第一，立法透明；第二，执法
坚定；第三，组织支持。推进的节奏需要循序渐进，过于生硬的一刀切很可能触发团
队的抵触情绪，甚至有些程序员会不惜辞职来捍卫自己的编程习惯

1. 立法透明

在规约制订的过程中，保持全程透明与公开，充分讨论，反复审稿，谨慎定稿。
需要明确回答规约为什么这样制订，违反了会有什么后果。不论团队成员是否理解，
是否赞同，要让所有人觉得规约的制订是一个共同参与、共同讨论的过程，规约是共
同遵守的约定。但某些规则或左或右时，仅仅需要的是一个拍板。由于技术是不断向
前发展的，没有一套代码规约可以流行数年而不更新，我们需要保持规约内容的与时
俱进。比如，《阿里巴巴 Java开发手册》(下称《手册》)制订之初是JDK7时代，
转眼间已经开始拥抱JDK11，底层技术发生了很大的变化，因此，规约需要不断地吸
收新的特性，并且修改不再适用于主流版本的相关内容

2. 执法坚定

对于规约的遵守符合典型的破窗理论，如果团队某个成员完全不遵守共同的代码
规约，久而久之，出于人性的弱点，其他成员必然一个接一个地开始违反规约， 最后
规约就是形同虚设。执法的过程需要面对两件事情：第一，如何判断是否违反规约；
第二，如何进行奖惩。第一件事情，首先由程序自动分析保证，能够降低规约的遵守
成本。保障规约轻量化落地的技术包括自动化扫描、数据分析等配套工具，自动化扫
描最好提供全量和增量的配置，尤其是后者可以减少因为历史代码而增加的规约遵守
成本。规约扫描的相关数据分析是指形成数据报表，按时间、团队、应用各个维度进
行聚合，立体地分析违反规约的成员和代码，有助于长效地提升规约的生命力。《手册》
也提供相应的静态代码扫描工具，称为P3C扫描插件，甚至提供部分自动纠错功能，
可以有效地提升开发效率。其次，在自动化分析的基础上，增加人工CodeReview来
保证规约的落地，进一步 判断无法通过自动扫描的规则是否被遵守。比如：即使是多
个字段组合，只要业务特性唯一， 就必须建成唯一索引，这样的规则很难通过自动化
分析进行判断，需要Reviewer根据业务逻辑进行人工审查。第二件事情，数据分析
的结果可以作为考核机制的参考指标，督促团队成员更好地遵守代码规约。此外，对
于优秀代码，可以通过代码秀或者代码墙分享出来，引导其他成员学习和主动遵守代
码规范

3. 组织支持

公司是否需要代码规约来提升整体开发效率，维护长效的开发秩序，它是一个管
理决定，决定之后的执行需要某个部门进行专项推进。通常来说，推进规约落地是一
件成就感并不是特别强的脏活累活，并且经常会面对各种抵触行为，这时就需要组织
给予充分的支持。组织支持包括三个方面：第一，给予负责人相应的考核权限；第二，
需要进行各种广泛而有力的宣传和引导；第三，建立良性、有序、分享的长效代码文化

##### 9.3 手册纵览
现代软件行业的高速发展和复杂架构对于开发者的综合素质要求越来越高，因为
不仅是编程知识，其他维度的知识结构也会影响到软件的最终交付质量。比如，数据
库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导
致维护困难；没有鉴权的漏洞代码被黑客攻击等。《手册》全文被划分为编程规约、
异常日志、单元测试、安全规约、MySQL数据库、工程结构、设计规约七大章节，
呈现出完整的程序员能力模型。衍生的问题是这样的知识体系是不是过于庞大?仅安
全规约扩展开来可以是上百页的资料。《手册》主要关注的是与开发紧密相关的知识点，
如果不知道水平权限校验，如果不知道建立合理的索引，如果不知道设计模式七大原
则，那么会是一名合格的开发工程师吗?这本手册不是提倡深究所有的知识点而成为
安全专家、运维专家，而是关注与编码相关的生态知识，成为知识全面的开发工程师

回顾2013年的手册原型，最初的内容只涉及编程习惯和异常处理两个章节。数
据库规约是第一个被扩充的章节，是因为当时认知到数据库的设计极为轻佻。建库建
表、字段名称、字段类型、字段长度的决定都比较随意，导致上层应用不得不花费更
大的代价去修正底层数据结构的缺陷

比如，存储一对多的关系主要有四种实现方式，分别为JSON方式、XML方式、
逗号分隔、多字段存储，底层实现方式的不同选择决定着上层实现逻辑的巨大差异。
当时在技术评审会上，开发工程师根本就没有认真评审四种实现方式的区别，直接选
择多字段存储，导致后期不断增加列来适配一对多的关系。推荐使用JSON方式来进
行存储，因为解析框架比较成熟，存储开销适中，性能不错，并且数据存储格式可以
直接阅读

再如，表达删除的字段名非常杂乱，类似于delete、delete_flag、 is_deleted、
is_delete等。甚至在同一个应用中的多个表中，表达删除的字段名都没有统一，这导致
在进行数据分析时，总要小心翼翼，像玩文字游戏。另外，在同一个字段中，居然出
现1/0和y/n同时表达已删除和未删除的状态，《 手册》推荐使用is_deleted的字段命
名，使用1/0表示已删除和未删除的状态

为何将约束等级分为三级?传统观念上的代码规约只列出强制项，而不是把那些
无法衡量的推荐或参考写入规约。在《手册》诞生之前，业界并没有使用过代码规约
分级制。什么都是强制项的“规范”，更像是一纸冰冷的法律文书。在《手册》的制
订过程中，发现有些规则可以量化，有些规则难以量化，根据约束力强弱及故障敏感性，
规约依次分级为强制、推荐、参考三大类。强制是一种命令型的约束，表达的是协作
痛点或故障隐患。推荐是一-种语气比较强的提倡，即使不这样做也不会产生严重的问
题，但如果团队一致遵守会使代码结构更清晰，团队协作更高效。参考分成两种情
况：第一种是无法用规则量化的要求，比如避免出现重复的代码，即Don' t Repeat
Yourself；第二种向左向右均可以，仅提出一种期望，自由度由开发工程师自己把握，
比如在服务层的方法命名中，获取单个对象的方法用get作为前缀等

扩展的说明、正例、反例希望达到什么样的目的?知其然，知其不然，深度地理
解规则背后的思想。如果只是冷冰冰的规则，对于阅读者的理解和记忆都是很大的挑
战。《手册》希望读者能够非常舒心地完成阅读，掩卷遐思，亦有所得。其中“说明”
对内容做了引申和解释，为求知其然；“正例” 展示什么样的编码、配置、实现方式
是被倡导的；"反例”标识需要提防的雷区，以及真实的错误案例，让人知其不然

考虑到方便离线查看，《手册》是以PDF文件的方式进行发布的，共有9个版本。
2017年2月9日，第一个版本正式公布，引起社区热议。紧接着5月20日，吸纳社
区意见，修正错误描述，发布完美版。9月25日，增加单元测试规约，发布终极版。
但是，注意到软件设计领域没有比较好的指导原则，2018年5月20日，增加16条
设计规约，发布详尽版。版本命名是有当时特定的背景考量的，每个版本都有相应的
版本号列在《手册》最后的附表中，目前已经转为在线维护

##### 9.4 聊聊成长
成长并没有直线式的捷径，“不走弯路就是捷径” 这个观点未必正确。弯路是成
长的必经之路，我们在成长的路上需要注意的是保证弯路的前进大方向与直线的行进
方向基本一致。南辕北辙消耗的是时间成本、精力成本、机会成本，尤其机会成本往
往是可遇不可求的。弯路上的泥泞、徘徊、痛苦等都是成长的养分，一味地想速成某
种能力，反而适得其反。夯实基础，方能建万丈高楼。浮沙筑高台，那只是极少数天
才的专利而已

代码能力的提升就是不断磨炼、不断尝试、不断纠错的成长过程。编程实战能力
是开发工程师的核心能力，现在越来越多的企业会进行在线编程能力测试，甚至在计
算机类博士的相关招聘中，也会有此类要求。优秀的代码能力应该体现在运行效率和
架构设计上。运行效率取决于对语言的合理运用和算法设计的合理性上。要尽量避免
《手册》中提到很多关于Java语言一些低效的处理方式。在算法设计上，可以参考
本书的“数据结构与集合”章节，尽可能写出高质量的算法代码；而架构设计，需要
融会贯通，使代码优雅、具有扩展性

孔子曰：“学而不思则罔，思而不学则殆。”如果只是把书架上的书的数量来衡
量自己的技术功底，那真错了，真正的书架应在心中，反复地学习、实践，再夯实理论。
如果缺乏思考，就会因为不能深刻理解书本的意义而不能有效地在实际中运用好这些
知识，甚至陷入更深的迷茫中。我们只有把学习和思考结合起来，才能把知识转为己用。
笔者很喜欢在学习的同时作深度总结，至今沉淀了超过2000页的笔记，分为四个文档：
搜集、整理、专题、哲学。知识快速进入搜集区，包括书上的、听到的、看到的、疑
惑的；不断地去思考、复核并总结之后，沉淀在整理区。这是点维度的总结；把这些
点的知识串成一个专题是线维度的总结；而最后的知识上升到哲学方法论级别，是面
维度的总结

我们考完驾照的时候，总想找机会显示一下自己的驾驶技术。同理，学习和体会
计算机技术，也要敢于到班门去弄斧。提倡把自己丑陋的代码在比自己更优秀的人面
前晒出来。含蓄的结果就是以为自己是宇宙中心，别人写的代码都不如我，自己的风
格总是正道。在一度火爆的“向代码致敬，寻找你的第83行”活动中，最后的获奖
者感言，在这个过程中收获了成长，正因为大神们的指导，打开了自己知识的广一度,
找到了自己的不足之处

最后，做一个有技术情怀的人。技术情怀总结成两个关键词：热爱、卓越。热爱
是一种源动力，卓越是一种境界。兴趣是最好的老师，也是最好的动力。而热爱是一
种信念，即使痛苦，也不会让你背离这份事业和内心的执着。对技术的热爱，让人勇
于追根究底，勇于坐冷板凳，勇于回馈别人。极致与卓越，似乎是一个意思，即出类
拔萃，超出期望。技术情怀提倡我们追求极致式的卓越，把卓越再往前提升。不管一
个人如何卓越与优秀，都要学会自我驱动，持续进步，追求个人内心的极致。因为卓
越，所以经典，只有这样百尺竿头，才能更进一步。仰望星空的同时，是脚踏实地，
这样才能不断地学习和打磨自己

在成长的路上，愿《码出高效: Java开发手册》 和你一路同行，成为良师益友，
一起成长，一起携手面对技术难题，走向更精彩的明天!
