跨战区PK
========

创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着
重于如何建立一个软件结构，虽然三种模式的着重点不同，但是在实际应用中还是有重叠
的，会出现一种模式适用、另外一种模式也适用的情况，我们到底该选用哪一个设计模式
呢？本章就带领读者进入不同类设计模式PK的世界中，让你清晰地认识到各个模式的不同
点以及它们的特长

#### 策略模式VS桥梁模式

详见：strategy

两者之间确实很相似。如果把策略模式的环境角色变更为一个抽象类加一个实现类，或
者桥梁模式的抽象角色未实现，只有修正抽象化角色，想想看，这两个类图有什么地方不一
样？完全一样！正是由于类似场景的存在才导致了两者在实际应用中经常混淆的情况发生，
我们来举例说明两者有何差别

大家都知道邮件有两种格式：文本邮件（Text Mail）和超文本邮件（HTML Mail）,在
文本邮件中只能有简单的文字信息，而在超文本邮件中可以有复杂文字（带有颜色、字体等
属性）、图片、视频等，如果你使用Foxmail邮件客户端的话就应该有深刻体验，看到一份
邮件，怎么没内容？原来是你忘记点击那个“HTML邮件”标签了。下面我们就来讲解如何发
送这两种不同格式的邮件，研究一下这两种模式如何处理这样的场景

策略模式实现邮件发送

使用策略模式发送邮件，我们认为这两种邮件是两种不同的封装格式，给定了发件人、
收件人、标题、内容的一封邮件，按照两种不同的格式分别进行封装，然后发送之。按照这
样的分析，我们发现邮件的两种不同封装格式就是两种不同的算法，具体到策略模式就是两
种不同策略，这样看已经很简单了，我们可以直接套用策略模式来实现

桥梁模式实现邮件发送

详见：bridge

桥梁模式关注的是抽象和实现的分离，它是结构型模式，结构型模式研究的是如何建立
一个软件架构

类图中我们增加了SendMail和Postfix两个邮件服务器来实现类，在邮件模板中允许增加
发送者标记，其他与策略模式都相同。我们在这里已经完成了一个独立的架构，邮件有了，
发送邮件的服务器也具备了，是一个完整的邮件发送程序。需要读者注意的是，SendMail类
不是一个动词行为（发送邮件），它指的是一款开源邮件服务器产品，一般*nix系统的默认
邮件服务器就是SendMail；Postfix也是一款开源的邮件服务器产品，其性能、稳定性都在逐
步赶超SendMail

最佳实践

策略模式和桥梁模式是如此相似，我们只能从它们的意图上来分析。策略模式是一个行
为模式，旨在封装一系列的行为，在例子中我们认为把邮件的必要信息（发件人、收件人、
标题、内容）封装成一个对象就是一个行为，封装的格式（算法）不同，行为也就不同。而
桥梁模式则是解决在不破坏封装的情况下如何抽取出它的抽象部分和实现部分，它的前提是
不破坏封装，让抽象部分和实现部分都可以独立地变化，在例子中，我们的邮件服务器和邮
件模板是不是都可以独立地变化？不管是邮件服务器还是邮件模板，只要继承了抽象类就可
以继续扩展，它的主旨是建立一个不破坏封装性的可扩展架构

简单来说，策略模式是使用继承和多态建立一套可以自由切换算法的模式，桥梁模式是
在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。桥梁模式必然有两个“桥
墩”——抽象化角色和实现化角色，只要桥墩搭建好，桥就有了，而策略模式只有一个抽象
角色，可以没有实现，也可以有很多实现

还是很难区分，是吧？多想想两者的意图，就可以理解为什么要建立两个相似的模式
了。我们在做系统设计时，可以不考虑到底使用的是策略模式还是桥梁模式，只要好用，能
够解决问题就成，“不管黑猫白猫，抓住老鼠的就是好猫”

#### 门面模式VS中介者模式

门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口
使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的
问题。中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不
再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构

中介者模式实现工资计算

详见：mediator

大家工作会得到工资，那么工资与哪些因素有关呢？这里假设工资与职位、税收有关，
职位提升工资就会增加，同时税收也增加，职位下降了工资也同步降低，当然税收也降低。
而如果税收比率增加了呢？工资自然就减少了！这三者之间两两都有关系，很适合中介者模
式的场景

类图中的方法比较简单，我们主要分析的是三者之间的关系，通过类图可以发现三者之
间已经没有耦合，原本在需求分析时我们发现三者有直接的交互，采用中介者模式后，三个
对象之间已经相互独立了，全部委托中介者完成。我们在类图中还定义了一个抽象同事类，
它是一个标志性接口，其子类都是同事类，都可以被中介者接收

我们回过头来分析一下设计，在接收到需求后我们发现职位、工资、税收之间有着紧密
的耦合关系，如果不采用中介者模式，则每个对象都要与其他两个对象进行通信，这势必会
增加系统的复杂性，同时也使系统处于僵化状态，很难实现拥抱变化的理想。通过增加一个
中介者，每个同事类的职位、工资、税收都只与中介者通信，中介者封装了各个同事类之间
的逻辑关系，方便系统的扩展和维护

门面模式实现工资计算

详见：facade

工资计算是一件非常复杂的事情，简单来说，它是对基本工资、月奖金、岗位津贴、绩
效、考勤、税收、福利等因素综合运算后的一个数字。即使设计一个HR（人力资源）系
统，员工工资计算也是非常复杂的模块，但是对于外界，比如高管层，最希望看到的结果是
张三拿了多少钱，李四拿了多少钱，而不是看中间的计算过程，怎么计算那是人事部门的事
情。换句话说，对外界的访问者来说，它只要传递进去一个人员名称和月份即可获得工资
数，而不用关心其中的计算有多么复杂，这就用得上门面模式了

最佳实践

门面模式和中介者模式之间的区别还是比较明显的，门面模式是以封装和隔离为主要任
务，而中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务
逻辑控制。两者的主要区别如下：

- 功能区别

门面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门
面模式是完全可以独立运行的。而中介者模式则增加了业务功能，它把各个同事类中的原有
耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂
性和降低扩展性

- 知晓状态不同

对门面模式来说，子系统不知道有门面存在，而对中介者来说，每个同事类都知道中介
者存在，因为要依靠中介者调和同事之间的关系，它们对中介者非常了解

- 封装程度不同

门面模式是一种简单的封装，所有的请求处理都委托给子系统完成，而中介者模式则需
要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的
业务功能封装

#### 包装模式群PK












