跨战区PK
========

详见：wrappingPattern

创建类模式描述如何创建对象，行为类模式关注如何管理对象的行为，结构类模式则着
重于如何建立一个软件结构，虽然三种模式的着重点不同，但是在实际应用中还是有重叠
的，会出现一种模式适用、另外一种模式也适用的情况，我们到底该选用哪一个设计模式
呢？本章就带领读者进入不同类设计模式PK的世界中，让你清晰地认识到各个模式的不同
点以及它们的特长

#### 策略模式VS桥梁模式

详见：strategy

两者之间确实很相似。如果把策略模式的环境角色变更为一个抽象类加一个实现类，或
者桥梁模式的抽象角色未实现，只有修正抽象化角色，想想看，这两个类图有什么地方不一
样？完全一样！正是由于类似场景的存在才导致了两者在实际应用中经常混淆的情况发生，
我们来举例说明两者有何差别

大家都知道邮件有两种格式：文本邮件（Text Mail）和超文本邮件（HTML Mail）,在
文本邮件中只能有简单的文字信息，而在超文本邮件中可以有复杂文字（带有颜色、字体等
属性）、图片、视频等，如果你使用Foxmail邮件客户端的话就应该有深刻体验，看到一份
邮件，怎么没内容？原来是你忘记点击那个“HTML邮件”标签了。下面我们就来讲解如何发
送这两种不同格式的邮件，研究一下这两种模式如何处理这样的场景

策略模式实现邮件发送

使用策略模式发送邮件，我们认为这两种邮件是两种不同的封装格式，给定了发件人、
收件人、标题、内容的一封邮件，按照两种不同的格式分别进行封装，然后发送之。按照这
样的分析，我们发现邮件的两种不同封装格式就是两种不同的算法，具体到策略模式就是两
种不同策略，这样看已经很简单了，我们可以直接套用策略模式来实现

桥梁模式实现邮件发送

详见：bridge

桥梁模式关注的是抽象和实现的分离，它是结构型模式，结构型模式研究的是如何建立
一个软件架构

类图中我们增加了SendMail和Postfix两个邮件服务器来实现类，在邮件模板中允许增加
发送者标记，其他与策略模式都相同。我们在这里已经完成了一个独立的架构，邮件有了，
发送邮件的服务器也具备了，是一个完整的邮件发送程序。需要读者注意的是，SendMail类
不是一个动词行为（发送邮件），它指的是一款开源邮件服务器产品，一般*nix系统的默认
邮件服务器就是SendMail；Postfix也是一款开源的邮件服务器产品，其性能、稳定性都在逐
步赶超SendMail

最佳实践

策略模式和桥梁模式是如此相似，我们只能从它们的意图上来分析。策略模式是一个行
为模式，旨在封装一系列的行为，在例子中我们认为把邮件的必要信息（发件人、收件人、
标题、内容）封装成一个对象就是一个行为，封装的格式（算法）不同，行为也就不同。而
桥梁模式则是解决在不破坏封装的情况下如何抽取出它的抽象部分和实现部分，它的前提是
不破坏封装，让抽象部分和实现部分都可以独立地变化，在例子中，我们的邮件服务器和邮
件模板是不是都可以独立地变化？不管是邮件服务器还是邮件模板，只要继承了抽象类就可
以继续扩展，它的主旨是建立一个不破坏封装性的可扩展架构

简单来说，策略模式是使用继承和多态建立一套可以自由切换算法的模式，桥梁模式是
在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。桥梁模式必然有两个“桥
墩”——抽象化角色和实现化角色，只要桥墩搭建好，桥就有了，而策略模式只有一个抽象
角色，可以没有实现，也可以有很多实现

还是很难区分，是吧？多想想两者的意图，就可以理解为什么要建立两个相似的模式
了。我们在做系统设计时，可以不考虑到底使用的是策略模式还是桥梁模式，只要好用，能
够解决问题就成，“不管黑猫白猫，抓住老鼠的就是好猫”

#### 门面模式VS中介者模式

门面模式为复杂的子系统提供一个统一的访问界面，它定义的是一个高层接口，该接口
使得子系统更加容易使用，避免外部模块深入到子系统内部而产生与子系统内部细节耦合的
问题。中介者模式使用一个中介对象来封装一系列同事对象的交互行为，它使各对象之间不
再显式地引用，从而使其耦合松散，建立一个可扩展的应用架构

中介者模式实现工资计算

详见：mediator

大家工作会得到工资，那么工资与哪些因素有关呢？这里假设工资与职位、税收有关，
职位提升工资就会增加，同时税收也增加，职位下降了工资也同步降低，当然税收也降低。
而如果税收比率增加了呢？工资自然就减少了！这三者之间两两都有关系，很适合中介者模
式的场景

类图中的方法比较简单，我们主要分析的是三者之间的关系，通过类图可以发现三者之
间已经没有耦合，原本在需求分析时我们发现三者有直接的交互，采用中介者模式后，三个
对象之间已经相互独立了，全部委托中介者完成。我们在类图中还定义了一个抽象同事类，
它是一个标志性接口，其子类都是同事类，都可以被中介者接收

我们回过头来分析一下设计，在接收到需求后我们发现职位、工资、税收之间有着紧密
的耦合关系，如果不采用中介者模式，则每个对象都要与其他两个对象进行通信，这势必会
增加系统的复杂性，同时也使系统处于僵化状态，很难实现拥抱变化的理想。通过增加一个
中介者，每个同事类的职位、工资、税收都只与中介者通信，中介者封装了各个同事类之间
的逻辑关系，方便系统的扩展和维护

门面模式实现工资计算

详见：facade

工资计算是一件非常复杂的事情，简单来说，它是对基本工资、月奖金、岗位津贴、绩
效、考勤、税收、福利等因素综合运算后的一个数字。即使设计一个HR（人力资源）系
统，员工工资计算也是非常复杂的模块，但是对于外界，比如高管层，最希望看到的结果是
张三拿了多少钱，李四拿了多少钱，而不是看中间的计算过程，怎么计算那是人事部门的事
情。换句话说，对外界的访问者来说，它只要传递进去一个人员名称和月份即可获得工资
数，而不用关心其中的计算有多么复杂，这就用得上门面模式了

最佳实践

门面模式和中介者模式之间的区别还是比较明显的，门面模式是以封装和隔离为主要任
务，而中介者模式则是以调和同事类之间的关系为主，因为要调和，所以具有了部分的业务
逻辑控制。两者的主要区别如下：

- 功能区别

门面模式只是增加了一个门面，它对子系统来说没有增加任何的功能，子系统若脱离门
面模式是完全可以独立运行的。而中介者模式则增加了业务功能，它把各个同事类中的原有
耦合关系移植到了中介者，同事类不可能脱离中介者而独立存在，除非是想增加系统的复杂
性和降低扩展性

- 知晓状态不同

对门面模式来说，子系统不知道有门面存在，而对中介者来说，每个同事类都知道中介
者存在，因为要依靠中介者调和同事之间的关系，它们对中介者非常了解

- 封装程度不同

门面模式是一种简单的封装，所有的请求处理都委托给子系统完成，而中介者模式则需
要有一个中心，由中心协调同事类完成，并且中心本身也完成部分业务，它属于更进一步的
业务功能封装

#### 包装模式群PK

我们讲了这么多的设计模式，大家有没有发觉在很多的模式中有些角色是不干活的？它
们只是充当黔首作用，你有问题，找我，但我不处理，我让其他人处理。最典型的就是代理
模式了，代理角色接收请求然后传递到被代理角色处理。门面模式也是一样，门面角色的任
务就是把请求转发到子系统。类似这种结构的模式还有很多，我们先给这种类型的模式定义
一个名字，叫做包装模式（wrapping pattern）。注意，包装模式是一组模式而不是一个。包
装模式包括哪些设计模式呢？包装模式包括：装饰模式、适配器模式、门面模式、代理模
式、桥梁模式。下面我们通过一组例子来说明这五个包装模式的区别

- 代理模式

详见：proxy

现在很多明星都有经纪人，一般有什么事他们都会说：“你找我的经纪人谈好了”，下面
我们就看看这一过程怎么模拟

看看我们的程序逻辑，我们是找明星的经纪人签字，真实签字的是明星，经纪人只是把
这个请求传递给明星处理而已，这是普通的代理模式的典型应用

- 装饰模式

详见：decorator

明星也都是一步一步地奋斗出来的，谁都不是一步就成为大明星的。甚至一些演员通过
粉饰自己给观众一个好的印象，现在我们就来看怎么粉饰一个演员

- 适配器模式

详见：adaptor

我们知道在演艺圈中还存在一种情况：替身，替身也是演员，只是普通的演员而已，在
一段戏中，前十五分钟是明星本人，后十五分钟也是明星本人，就中间的五分钟是替身，那
这个场景该怎么描述呢？注意中间那五分钟，这个时候一个普通演员被导演认为是明星演
员

- 桥梁模式

详见：bridge

我们继续说明星圈的事情，现在明星类型太多了，比如电影明星、电视明星、歌星、体
育明星、网络明星等，每个类型的明星都有明确的职责，电影明星的主要工作就是演电影，
电视明星的主要工作就是演电视剧或者主持电视节目。再看看现在的明星，单一发展的基本
没有，主持人出专辑、体育明星演电影、歌星拍戏等太平常了，我们就用程序来表现一下多
元化情形

bridge中“图33-9 各类明星描述”中定义了一个抽象明星AbsStar，然后产生出各个具体类型的明星，比如电影明星
FilmStar、歌星Singer，当然还可以继续扩展下去。这里还定义了一个抽象的行为
AbsAction，描述明星所具有的活动，比如演电影、唱歌等，在这种设计下，明星可以扩
展，明星的活动也可以扩展，非常灵活

好了，各类明星都有自己的本职工作，但是偶尔客串一个其他类型的活动也是允许的，
如此设计后，明星就可以不用固定在自己的本职工作上，而是向其他方向发展，比如影视歌
三栖明星

- 门面模式

相对简单，参考前面所讲，不再追诉

最佳实践

5个包装模式是大家在系统设计中经常会用到的模式，它们具有相似的特征：都是通过
委托的方式对一个对象或一系列对象（例如门面模式）施行包装，有了包装，设计的系统才
更加灵活、稳定，并且极具扩展性。从实现的角度来看，它们都是代理的一种具体表现形
式，我们来看看它们在使用场景上有什么区别

代理模式主要用在不希望展示一个对象内部细节的场景中，比如一个远程服务不需要把
远程连接的所有细节都暴露给外部模块，通过增加一个代理类，可以很轻松地实现被代理类
的功能封装。此外，代理模式还可以用在一个对象的访问需要限制的场景中，比如AOP

装饰模式是一种特殊的代理模式，它倡导的是在不改变接口的前提下为对象增强功能，
或者动态添加额外职责。就扩展性而言，它比子类更加灵活，例如在一个已经运行的项目
中，可以很轻松地通过增加装饰类来扩展系统的功能

适配器模式的主要意图是接口转换，把一个对象的接口转换成系统希望的另外一个接
口，这里的系统指的不仅仅是一个应用，也可能是某个环境，比如通过接口转换可以屏蔽外
界接口，以免外界接口深入系统内部，从而提高系统的稳定性和可靠性

桥梁模式是在抽象层产生耦合，解决的是自行扩展的问题，它可以使两个有耦合关系的
对象互不影响地扩展，比如对于使用笔画图这样的需求，可以采用桥梁模式设计成用什么笔
（铅笔、毛笔）画什么图（圆形、方形）的方案，至于以后需求的变更，如增加笔的类型，
增加图形等，对该设计来说是小菜一碟

门面模式是一个粗粒度的封装，它提供一个方便访问子系统的接口，不具有任何的业务
逻辑，仅仅是一个访问复杂系统的快速通道，没有它，子系统照样运行，有了它，只是更方
便访问而已
