行为类模式大PK
========

行为类模式包括
- 责任链模式
- 命令模式
- 解释器模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 模板方法模式
- 访问者模式

该组真可谓是人才济济，高手如云。行为类模式的11个模式基本上都是大家耳熟能详的，而且它们之间还有
很多的相似点，特别是一些扩展部分就更加相似了，我们挑选几个比较重要的模式进行对比说明

#### 命令模式VS策略模式

命令模式和策略模式的类图确实很相似，只是命令模式多了一个接收者（Receiver）角
色。它们虽然同为行为类模式，但是两者的区别还是很明显的。策略模式的意图是封装算
法，它认为“算法”已经是一个完整的、不可拆分的原子业务（注意这里是原子业务，而不是
原子对象），即其意图是让这些算法独立，并且可以相互替换，让行为的变化独立于拥有行
为的客户；而命令模式则是对动作的解耦，把一个动作的执行分为执行对象（接收者角
色）、执行行为（命令角色），让两者相互独立而不相互影响

我们从一个相同的业务需求出发，按照命令模式和策略模式分别设计出一套实现，来看
看它们的侧重点有什么不同。zip和gzip文件格式相信大家都很熟悉，它们是两种不同的压缩
格式，我们今天就来对一个目录或文件实现两种不同的压缩方式：zip压缩和gzip压缩（这里
的压缩指的是压缩和解压缩两种对应的操作行为，下同）。实现这两种压缩格式有什么意义
呢？有意义！一是zip格式（.zip后缀）是Windows操作系统常用的压缩格式，gzip格式（.gz
后缀）是*nix系统常用的压缩格式；二是JDK提供了对zip和gzip文件的操作包，非常容易实
现文件的压缩和解压缩操作

策略模式实现压缩算法

详见：strategy

要使用gzip算法吗？在客户端（Client）上把注释删掉就可以了，其他的模块根本不受任
何影响，策略模式关心的是算法是否可以相互替换。策略模式虽然简单，但是在项目组使用
得非常多，可以说随手拈来就是一个策略模式

命令模式实现压缩算法

详见：command

命令模式的主旨是封装命令，使请求者与实现者解耦。例如，到饭店点菜，客人（请求
者）通过服务员（调用者）向厨师（接收者）发送了订单（行为的请求），该例子就是通过
封装命令来使请求者和接收者解耦。我们继续来看压缩和解压缩的例子，怎么使用命令模式
来完成该需求呢？

类图看着复杂，但是还是一个典型的命令模式，通过定义具体命令完成文件的压缩、解
压缩任务，注意我们这里对文件的每一个操作都是封装好的命令，对于给定的请求，命令不
同，处理的结果当然也不同，这就是命令模式要强调的

大家可以这样思考这个问题，接收者就是厨房的厨师，具体要哪个厨师做这道菜则是餐
馆的规章制度已经明确的，你让专做粤菜的师傅做一个剁椒鱼头，能做出好菜吗？在命令模
式中，就是在抽象命令中定义了接收者的引用，然后在具体的实现类中确定要让哪个接收者
进行处理。这就好比是客人点菜：我要一个剁椒鱼头，这就是一个命令，然后服务员
（Inovker）接收到这个命令后，就开始执行，把这个命令指定给具体的执行者执行

详见：command2

当然了，接收者这部分还可以这样设计，即按照职责设计接收者，比如压缩接收者、解
压缩接收者，但接口需要稍稍改动

剩下的工作就是对抽象命令、具体命令稍作修改，这里不再赘述。为什么要在这里增加
一个分支描述呢？这是为了与策略模式对比，在命令模式中，我们可以把接收者设计得与策
略模式的算法相同，也可以不相同。我们按照职责设计的接口就不适用于策略模式，不可能
封装一个叫做压缩的算法类，然后在类中提供两种不同格式的压缩功能，这违背了策略模式
的意图——封装算法，为什么呢？如果要增加一个rar压缩算法，该怎么办呢？修改抽象算
法？这是绝对不允许的！那为什么命令模式就是允许的呢？因为命令模式着重于请求者和接
收者解耦，你管我接收者怎么变化，只要不影响请求者就成，这才是命令模式的意图

想新增一个命令？当然没有问题，只要重新定义一个命令就成，命令改变了，高层模块
只要调用它就成。请注意，这里的程序还有点欠缺，没有与文件的后缀名绑定，不应该出现
使用zip压缩命令产生一个.gzip后缀的文件名，读者在实际应用中可以考虑与文件后缀名之间
建立关联

通过以上例子，我们看到命令模式也实现了文件的压缩、解压缩的功能，它的实现是关
注了命令的封装，是请求者与执行者彻底分开，看看我们的程序，执行者根本就不用了解命
令的具体执行者，它只要封装一个命令——“给我用zip格式压缩这个文件”就可以了，具体由
谁来执行，则由调用者负责，如此设计后，就可以保证请求者和执行者之间可以相互独立，
各自发展而不相互影响

同时，由于是一个命令模式，接收者的处理可以进行排队处理，在排队处理的过程中，
可以进行撤销处理，比如客人点了一个菜，厨师还没来得及做，那要撤回很简单，撤回也是
命令，这是策略模式所不能实现的

小结

策略模式和命令模式相似，特别是命令模式退化时，比如无接收者（接收者非常简单或
者接收者是一个Java的基础操作，无需专门编写一个接收者），在这种情况下，命令模式和
策略模式的类图完全一样，代码实现也比较类似，但是两者还是有区别的

- 关注点不同

策略模式关注的是算法替换的问题，一个新的算法投产，旧算法退休，或者提供多种算
法由调用者自己选择使用，算法的自由更替是它实现的要点。换句话说，策略模式关注的是
算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换

命令模式则关注的是解耦问题，如何让请求者和执行者解耦是它需要首先解决的，解耦
的要求就是把请求的内容封装为一个一个的命令，由接收者执行。由于封装成了命令，就同
时可以对命令进行多种处理，例如撤销、记录等

- 角色功能不同

在我们的例子中，策略模式中的抽象算法和具体算法与命令模式的接收者非常相似，但
是它们的职责不同。策略模式中的具体算法是负责一个完整算法逻辑，它是不可再拆分的原
子业务单元，一旦变更就是对算法整体的变更

而命令模式则不同，它关注命令的实现，也就是功能的实现。例如我们在分支中也提到
接收者的变更问题，它只影响到命令族的变更，对请求者没有任何影响，从这方面来说，接
收者对命令负责，而与请求者无关。命令模式中的接收者只要符合六大设计原则，完全不用
关心它是否完成了一个具体逻辑，它的影响范围也仅仅是抽象命令和具体命令，对它的修改
不会扩散到模式外的模块

当然，如果在命令模式中需要指定接收者，则需要考虑接收者的变化和封装，例如一个
老顾客每次吃饭都点同一个厨师的饭菜，那就必须考虑接收者的抽象化问题

- 使用场景不同

策略模式适用于算法要求变换的场景，而命令模式适用于解耦两个有紧耦合关系的对象
场合或者多命令多撤销的场景

#### 策略模式VS状态模式

详见：state、strategy

在行为类设计模式中，状态模式和策略模式是亲兄弟，两者非常相似，我们先看看两者
的通用类图，把两者放在一起比较一下

两个类图非常相似，都是通过Context类封装一个具体的行为，都提供了一个封装的方
法，是高扩展性的设计模式。但根据两者的定义，我们发现两者的区别还是很明显的：策略
模式封装的是不同的算法，算法之间没有交互，以达到算法可以自由切换的目的；而状态模
式封装的是不同的状态，以达到状态切换行为随之发生改变的目的。这两种模式虽然都有变
换的行为，但是两者的目标却是不同的。我们举例来说明两者的不同点

人只要生下来就有工作可做，人在孩童时期的主要工作就是玩耍（学习只是在人类具有
了精神意识行为后才产生的）；成人时期的主要工作是养活自己，然后为社会做贡献；老年
时期的主要工作就是享受天伦之乐。按照策略模式来分析，这三种不同的工作方式就是三个
不同的具体算法，随着时光的推移工作内容随之更替，这和对一堆数组的冒泡排序、快速排
序、插入排序一样，都是一系列的算法；而按照状态模式进行设计，则认为人的状态（孩
童、成人、老人）产生了不同的行为结果，这里的行为都相同，都是工作，但是它们的实现
方式确实不同，也就是产生的结果不同，看起来就像是类改变了

策略模式实现人生

详见：strategy

这是非常典型的策略模式，没有太多的玄机，它定义了一个工作算法，然后有三个实现
类：孩童工作、成年人工作和老年人工作

通过采用策略模式我们实现了“工作”这个策略的三种不同算法，算法可以自由切换，到
底用哪个算法由调用者（高层模块）决定。策略模式的使用重点是算法的自由切换——老的
算法退休，新的算法上台，对模块的整体功能没有非常大的改变，非常灵活。而如果想要增
加一个新的算法，比如未出生婴儿的工作，只要继承WorkAlgorithm就可以了

状态模式实现人生

详见：state

我们再来看看使用状态模式是如何实现该需求的。随着时间的变化，人的状态变化了，
同时引起了人的工作行为改变，完全符合状态模式

运行结果与策略模式相同，但是两者的分析角度是大相径庭的。策略模式的实现是通过
分析每个人的工作方式的不同而得出三个不同的算法逻辑，状态模式则是从人的生长规律来
分析，每个状态对应了不同的行为，状态改变后行为也随之改变。从以上示例中我们也可以
看出，对于相同的业务需求，有很多种实现方法，问题的重点是业务关注的是什么，是人的
生长规律还是工作逻辑？找准了业务的焦点，才能选择一个好的设计模式

小结

从例子中我们可以看出策略模式和状态模式确实非常相似，称之为亲兄弟亦不为过，但
是这两者还是存在着非常大的差别，而且也是很容易区分的

- 环境角色的职责不同

两者都有一个叫做Context环境角色的类，但是两者的区别很大，策略模式的环境角色只
是一个委托作用，负责算法的替换；而状态模式的环境角色不仅仅是委托行为，它还具有登
记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务

- 解决问题的重点不同

策略模式旨在解决内部算法如何改变的问题，也就是将内部算法的改变对外界的影响降
低到最小，它保证的是算法可以自由地切换；而状态模式旨在解决内在状态的改变而引起行
为改变的问题，它的出发点是事物的状态，封装状态而暴露行为，一个对象的状态改变，从
外界来看就好像是行为改变

- 解决问题的方法不同

策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模
式对外暴露的是行为，状态的变化一般是由环境角色和具体状态共同完成的，也就是说状态
模式封装了状态的变化而暴露了不同的行为或行为结果

- 应用场景不同

两者都能实现前面例子中的场景，但并不表示两者的应用场景相同，这只是为了更好地
展示出两者的不同而设计的一个场景。我们来想一下策略模式和状态模式的使用场景有什么
不同，策略模式只是一个算法的封装，可以是一个有意义的对象，也可以是一个无意义的逻
辑片段，比如MD5加密算法，它是一个有意义的对象吗？不是，它只是我们数学上的一个公
式的相关实现，它是一个算法，同时DES算法、RSA算法等都是具体的算法，也就是说它们
都是一个抽象算法的具体实现类，从这点来看策略模式是一系列平行的、可相互替换的算法
封装后的结果，这就限定了它的应用场景：算法必须是平行的，否则策略模式就封装了一堆
垃圾，产生了“坏味道”。状态模式则要求有一系列状态发生变化的场景，它要求的是有状态
且有行为的场景，也就是一个对象必须具有二维（状态和行为）描述才能采用状态模式，如
果只有状态而没有行为，则状态的变化就失去了意义

- 复杂度不同

通常策略模式比较简单，这里的简单指的是结构简单，扩展比较容易，而且代码也容易
阅读。当然，一个具体的算法也可以写得很复杂，只有具备很高深的数学、物理等知识的人
才可以看懂，这也是允许的，我们只是说从设计模式的角度来分析，它是很容易被看懂的。
而状态模式则通常比较复杂，因为它要从两个角色看到一个对象状态和行为的改变，也就是
说它封装的是变化，要知道变化是无穷尽的，因此相对来说状态模式通常都比较复杂，涉及
面很多，虽然也很容易扩展，但是一般不会进行大规模的扩张和修正

#### 观察者模式VS责任链模式

为什么要把观察者模式和责任链模式放在一起对比呢？看起来这两个模式没有太多的相
似性，真没有吗？回答是有。我们在观察者模式中也提到了触发链（也叫做观察者链）的问
题，一个具体的角色既可以是观察者，也可以是被观察者，这样就形成了一个观察者链。这
与责任链模式非常类似，它们都实现了事务的链条化处理，比如说在上课的时候你睡着了，
打鼾声音太大，盖过了老师讲课声音，老师火了，捅到了校长这里，校长也处理不了，然后
告状给你父母，于是你的魔鬼日子来临了，这是责任链模式，老师、校长、父母都是链中的
一个具体角色，事件（你睡觉）在链中传递，最终由一个具体的节点来处理，并将结果反馈
给调用者（你挨揍了）。那什么是触发链？你还是在课堂上睡觉，还是打鼾声音太大，老师
火了，但是老师掏出个扩音器来讲课，于是你睡不着了，同时其他同学的耳朵遭殃了，这就
是触发链，其中老师既是观察者（相对你）也是被观察者（相对其他同学），事件从“你睡
觉”到老师这里转化为“扩音器放大声音”，这也是一个链条结构，但是链结构中传递的事件
改变了

我们还是以一个具体的例子来说明两者的区别，DNS协议相信大家都听说过，只要
在“网络设置”中设置一个DNS服务器地址就可以把我们需要的域名翻译成IP地址。DNS协议
还是比较简单的，传递过去一个域名以及记录标志（比如是要A记录还是要MX记
录），DNS就开始查找自己的记录树，找到后把IP地址反馈给请求者。我们可以在Windows
操作系统中了解一下DNS解析过程，在DOS窗口下输入nslookup命令
```
> set type=a
> www.xxx.com.cn
Server: 192.168.10.1
Address: 192.168.10.1

Non-authoritative answer:
Name: xxx.xxx.com.cn
Address: 202.108.33.122
Aliases: www.xxx.com.cn
```
我们的意图就是要DNS服务器192.168.10.1解析出www.xxx.com.cn的IP地址，DNS服务器
是如何工作的呢？图32-6中的192.168.10.1这个DNS Server存储着全球的域名和IP之间的对应
关系吗？不可能，目前全球的域名数量是1.7亿个，如此庞大的数字，每个DNS服务器都存
储一份，还怎么快速响应？DNS解析的响应时间一般都是毫秒级别的，如此高的性能要求还
怎么让DNS服务器遍地开花呢？而且域名变更非常频繁，数据读写的量也非常大，不可能每
个DNS服务器都保留这1.7亿数据，那么是怎么设计的呢？DNS协议还是很聪明的，它规定了
每个区域的DNS服务器（Local DNS）只保留自己区域的域名解析，对于不能解析的域名，
则提交上级域名解析器解析，最终由一台位于美国洛杉矶的顶级域名服务器进行解析，返回
结果。很明显这是一个事务的链结构处理，我们使用两种模式来实现该解析过程

责任链模式实现DNS解析过程




















