命令模式+责任链模式
========

搬移UNIX的命令

详见：command_chainOfResponsibility

在操作系统的世界里，有两大阵营一直在PK着：*nix（包括UNIX和Linux）和
Windows。从目前的统计数据来看，*nix在应用服务器领域占据相对优势，不过Windows也
不甘示弱，国内某些小型银行已经在使用PC Server（安装Windows操作系统的服务器）集群
来进行银行业务运算，而且稳定性、性能各方面的效果不错；而在个人桌面方面，Windows
是占绝对优势的，大家应该基本上都在用这个操作系统，它的诸多优点这里就不多说了，我
们今天就来解决一个习惯问题。如果你负责过UNIX系统维护，你自己的笔记本又是Windows
操作系统的话，可能常常在Windows的CMD里输入Linux命令

是不是经常把UNIX上的命令敲到Windows系统了？为了避免这种情况发生，可以把
UNIX上的命令移植到Windows上，也就是Windows下的shell工具，有很多类似的工具，比如
cygwin、GUN Bash等，这些都是非常完美的工具，我们今天的任务就是自己写一个这样的工
具。怎么写呢？我们学了这么多的模式，当然要融会贯通了，可以使用命令模式、责任链模
式、模板方法模式设计一个方便扩展、稳定的工具

我们先说说UNIX下的命令，一条命令分为命令名、选项和操作数，例如命令"ls-l/usr"，
其中，ls是命令名，l是选项，/usr是操作数，后两项都是可选项，根据实际情况而定。UNIX
命令一定遵守以下几个规则：

- 命令名为小写字母
- 命令名、选项、操作数之间以空格分隔，空格数量不受限制
- 选项之间可以组合使用，也可以单独拆分使用
- 选项以横杠（-）开头

在UNIX世界中，我们最常用的就是ls这个命令，它用于显示目录或文件信息，下面我们
先来看看这个命令。常用的有以下几条组合命令：

- ls：简单列出一个目录下的文件
- ls -l：详细列出目录下的文件
- ls -a：列出目录下包含的隐藏文件，主要是点号（.）开头的文件
- ls -s：列出文件的大小

除此之外，还有一些非常常用的组合命令，如"ls -la"、"ls -ls"等。ls命令名确定了，但是
其后连接的选项和操作数是不确定的。操作数我们不用关心它，每个命令必然有一个操作
数，若没有则是当前的目录。问题的关键是选项，用哪个选项以及什么时候使用都是由用户
决定的，也就是从设计上考虑。设计者需要完全解析所有的参数，需要很多个类来处理如此
多的选项，客户输入一个参数，立刻返回一个结果。针对一个ls命令族，要求如下：

每一个ls命令都有操作数，默认操作数为当前目录
- 选项不可重复，例如对于"ls -l-l-s"，解析出的选项应该只有两个：l选项和s选项
- 每个选项返回不同的结果，也就是说每个选项应该由不同的业务逻辑来处理
- 为提高扩展性，ls命令族内的运算应该是对外封闭的，减少外界访问ls命令族内部细
节的可能性

针对一个命令族的分析结果，我们可以使用什么模式？责任链模式！对，只要把一个参
数传递到链首，就可以立刻获得一个结果，中间是如何传递的以及由哪个逻辑解析都不需要
外界（高层）模块关心

类图还是比较清晰的，UNIX的命令有上百个，我们定义一个CommandName抽象类，所
有的命令都继承于该类，它就是责任链模式的handler类，负责链表控制；每个命令族都有一
个独立的抽象类，因为每个命令族都有其独特的个性，比如ls命令和df命令，其后可加的参
数是不一样的，这就可以在抽象类AbstractLS中定义，而且它还有标示作用，标示其下的实
现类都是实现ls命令的，只是命令的选项不同；Context负责建立一条命令的链表，比如ls命
令族、df命令族等，它组装出一个处理一个命令族的责任链，并返回首节点供高层模块调
用，这是非常典型的责任链模式

分析完毕一个具体的命令族，已经确定可以采用责任链模式，我们继续往下分析。
UNIX命令非常多，敲一个命令返回一个结果，每个具体的命令可以由相关的命令族（也就
是责任链）来解析，但是如此多的命令还是需要有一个派发的角色，输入一个命令，不管后
台谁来解析，返回一个结果就成，这就要用到命令模式。命令模式负责协调各个命令正确地
传递到各个责任链的首节点，这就是它的任务

是不是典型的命令模式类图？其中Chain是一个标示符，表示的就是我们上面分析的责
任链，每一个具体的命令负责调用责任链的首节点，获得返回值，结束命令的执行。两个核
心模块都分析完毕了，就可以把类图融合在一起

这个类图还是比较简单的，我们来看一下各个类的职责

- ClassUtils

ClassUtils是工具类，其主要职责是根据一个接口、父类查找到所有的子类。在不考虑效
率的应用中，使用该类可以带来非常好的扩展性

- CommandVO

CommandVO是命令的值对象，它把一个命令解析为命令名、选项、操作数，
例如"ls -l /usr"命令分别解析为getCommandName、getParam、getData三个方法的返回值

- CommandEnum

CommandEnum是枚举类型，是主要的命令配置文件。为什么需要枚举类型？这是JDK
1.5提供的一个非常好的功能，我们在程序中再讲解如何使用它

我们已经实现了在Windows下操作UNIX命令的功能，但是仅仅一个ls命令族是不够的，
我们要扩展，把一百多个命令都扩展出来，怎么扩展呢？现在增加一个df命令族，显示磁盘
的大小，只要增加类图就成

混编小结

在这里的例子中用到了以下模式

- 责任链模式

负责对命令的参数进行解析，而且所有的扩展都是增加链数量和节点，不涉及原有的代
码变更

- 命令模式

负责命令的分发，把适当的命令分发到指定的链上

- 模板方法模式

在Command类以及子类中，buildChain方法是模板方法，只是没有基本方法而已；在责
任链模式的CommandName类中，用了一个典型的模板方法handlerMessage，它调用了基本方
法，基本方法由各个实现类实现，非常有利于扩展

- 迭代器模式

在for循环中我们多次用到类似for(Class c : classes)的结构，是谁来支撑该方法运行？当然
是迭代器模式，只是JDK已经把它融入到了API中，更方便使用了

可能读者已经注意到了，"ls -l -a"这样的组合选项还没有处理。确实没有处理，以下提供
两个思路来处理:

- 独立处理

"ls -l-a"等同于"ls -la"，也等同于"ls -al"命令，可以把"ls -la"中的选项"la"作为一个参数来
进行处理，扩展一个类就可以了。该方法的缺点是类膨胀得太大，但是简单

- 混合处理

修正命令族处理链，每个命令处理节点运行完毕后，继续由后续节点处理，最终由
Command类组装结果，根据每个节点的处理结果，组合后生成完整的返回信息，如"ls -l -a"就
应该是LS_L类与LS_A类两者返回值组装的结果，当然链上的节点返回值就要放在Collection
类型中了

该框架还有一个名称，叫做命令链（Chain of Command）模式，具体来说就是命令模式
作为责任链模式的排头兵，由命令模式分发具体的消息到责任链模式。对于该框架，读者可
以继续扩展下去。当然，上面的程序还可以优化，优化的结果就是Command类缩为一个类，
通过CommandEnum配置文件类传递命令，这比较容易实现，读者可以自行设计

