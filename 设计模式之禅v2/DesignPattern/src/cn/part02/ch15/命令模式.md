命令模式
========

例子引入：旅行社项目开发

痛点：甲方频繁和乙方各个项目组沟通，有时候说不清需求，不能及时表达需求与提供反馈，导致需求频繁返工

详见 command

在原有的类图上增加了一个Invoker类，其作用是根据客户的命令安排不同的组员进行工
作，例如，客户说“界面上删除一条记录”，Invoker类接收到该String类型命令后，通知美工
组PageGroup开始delete，然后再找到代码组CodeGroup后台不要存到数据库中，最后反馈给
客户一个执行计划。这是一个挺好的方案，但是客户的命令是一个String类型的，这有非常
多的变化，仅仅通过一个字符串来传递命令并不是一个非常好的方案，因为在系统设计中，
字符串没有约束力，根据字符串判断相关的业务逻辑不是一个优秀的解决方案。那怎么才是
一个优秀的方案呢？解决方案是：对客户发出的命令进行封装，每个命令是一个对象，避免
客户、负责人、组员之间的交流误差，封装后的结果就是客户只要说一个命令，我的项目组
就立刻开始启动，不用思考、解析命令字符串

详见 command2

Command抽象类只有一个方法execute，其作用就是执行命令，子类非常坚决地实现该命
令，与军队中类似，上级军官给士兵发布命令：爬上这个旗杆！然后士兵回答：Yes,Sir！完
美的项目也与此类似，客户发送一个删除页面的命令，接头负责人Invoker接收到命令后，立
刻执行DeletePageCommand的execute方法。对类图中增加的几个类说明如下

- Command抽象类：客户发给我们的命令，定义三个工作组的成员变量，供子类使用；
定义一个抽象方法execute，由子类来实现

- CInvoker实现类：项目接头负责人，setComand接收客户发给我们的命令，action方法
是执行客户的命令（方法名写成是action，与command的execute区分开，避免混淆）

其中，Command抽象类是整个扩展的核心

命令模式的定义

命令模式是一个高内聚的模式，其定义为：Encapsulate a request as an object, thereby
letting you parameterize clients with different requests, queue or log requests, and support undoable
operations.（将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请
求排队或者记录请求日志，可以提供命令的撤销和恢复功能。）

详见 command3

在该类图中，我们看到三个角色

- Receive接收者角色

该角色就是干活的角色，命令传递到这里是应该被执行的，具体到我们上面的例子中就
是Group的三个实现类

- Command命令角色

需要执行的所有命令都在这里声明

- Invoker调用者角色

接收到命令，并执行命令。在例子中，我（项目经理）就是这个角色

命令模式比较简单，但是在项目中非常频繁地使用，因为它的封装性非常好，把请求方
（Invoker）和执行方（Receiver）分开了，扩展性也有很好的保障，通用代码比较简单

命令模式的优点

- 类间解耦

调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需调用Command
抽象类的execute方法就可以，不需要了解到底是哪个接收者执行

- 可扩展性

Command的子类可以非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严
重的代码耦合

- 命令模式结合其他模式会更优秀

命令模式可以结合责任链模式，实现命令族解析任务；结合模板方法模式，则可以减少
Command子类的膨胀问题

命令模式的缺点

命令模式也是有缺点的，请看Command的子类：如果有N个命令，问题就出来
了，Command的子类就可不是几个，而是N个，这个类膨胀得非常大，这个就需要读者在项
目中慎重考虑使用

命令模式的使用场景

只要你认为是命令的地方就可以采用命令模式，例如，在GUI开发中，一个按钮的点击
是一个命令，可以采用命令模式；模拟DOS命令的时候，当然也要采用命令模式；触发－反
馈机制的处理等

命令模式的扩展

- 未讲完的故事

上面的例子我们还没有说完。想想看，客户要求增加一项需求，那是不是页面也增加，
同时功能也要增加呢？如果不使用命令模式，客户就需要先找需求组，然后找美工组，再找
代码组……你想让客户跳楼啊！使用命令模式后，客户只管发命令模式，例如，需要增加一
项需求，没问题，我内部调动三个组通力合作，然后把结果反馈给你，这也正是客户需要
的。那这个要怎么修改呢？想想看，很简单的！在AddRequirementCommand类的execute方法
中增加对PageGroup和CodePage的调用就可以了

- 反悔问题

我们的例子说到这里是不是应该真的结束了？不，还有一个问题会经常发生的：客户发
出命令，要撤回，怎么办？就类似你使用Ctl+Z组合键（undo功能），发出一个命令，在没
有执行（这时只要重新setCommand就可以了）或执行后撤回（执行后撤回是状态变更）该怎
么实现呢？

有两种方法可以解决：一是结合备忘录模式还原最后状态，该方法适合接收者为状态的
变更情况，而不适合事件处理；二是通过增加一个新的命令，实现事件的回滚。例子中
的“删除一个页面”就需要一个反命令：撤销刚刚删除页面的命令，那客户发出这样一个命
令，我们该怎么处理呢？

我们这样思考，反命令也是一个命令，那就是Command的一个子类，它实现的功能就是
恢复刚刚删除的页面，然后我们再思考，谁能恢复删除的页面呢？当然是页面组了，于是作
为接收者的页面组必须还有一个方法恢复最后删除的页面，也就是日志的回滚机制了，指定
一个页面，回滚回去。分析完毕，我们来看实现，注意：以下为示意代码，请读者自行在应
用中进行实现

代码见 command3

然后就是用Invoker进行调用了，客户选择了执行这个撤销动作，就可以进行撤销操作，
该示意代码确实比较简单，真正实现起来那是异常复杂的，为什么呢？事务日志处理是非常
繁琐的处理机制，想想数据库的日志处理吧，你就能想象出这个日志有多复杂

最佳实践

各位读者可能已经发觉了这样的问题：在我们旅行社的例子中，我们的Receiver角色
（也就是Group的三个实现类）并没有暴露给Client，而在通用的类图和源码中却出现了
Client类对Receiver角色的依赖，这是为什么呢？

如果你发现了这个问题，则说明你阅读得非常仔细，好习惯！每一个模式到实际应用的
时候都有一些变形，命令模式的Receiver在实际应用中一般都会被封装掉（除非非常必要，
例如撤销处理），那是因为在项目中：约定的优先级最高，每一个命令是对一个或多个
Receiver的封装，我们可以在项目中通过有意义的类名或命令名处理命令角色和接收者角色
的耦合关系（这就是约定），减少高层模块（Client类）对低层模块（Receiver角色类）的依
赖关系，提高系统整体的稳定性。因此，建议大家在实际的项目开发时采用封闭Receiver的
方式（当然了，仁者见仁，智者见智），减少Client对Reciver的依赖，该方案只是对
Commandd抽象类及其子类有一定的修改









