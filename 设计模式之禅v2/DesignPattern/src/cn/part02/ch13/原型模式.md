原型模式
========

引入例子：广告信

详见 prototype

这个程序是否有问题？Look here，这是一个
线程在运行，也就是你发送的是单线程的，那按照一封邮件发出去需要0.02秒（够小了，你
还要到数据库中取数据呢），600万封邮件需要33个小时，也就是一个整天都发送不完，今
天的没发送完，明天的账单又产生了，日积月累，激起甲方人员一堆抱怨，那怎么办？

好办，把sendMail修改为多线程，但是只把sendMail修改为多线程还是有问题的呀，产
生第一封邮件对象，放到线程1中运行，还没有发送出去；线程2也启动了，直接就把邮件对
象mail的收件人地址和称谓修改掉了，线程不安全了。说到这里，你会说这有N多种解决办
法，其中一种是使用一种新型模式来解决这个问题：通过对象的复制功能来解决这个问题，
类图稍做修改

详见 prototype2

运行结果不变，一样完成了电子广告信的发送功能，而且sendMail即使是多线程也没有
关系。注意，看Client类中的粗体字mail.clone()这个方法，把对象复制一份，产生一个新的
对象，和原有对象一样，然后再修改细节的数据，如设置称谓、设置收件人地址等。这种不
通过new关键字来产生一个对象，而是通过对象复制来实现的模式就叫做原型模式

原型模式的定义

原型模式（Prototype Pattern）的简单程度仅次于单例模式和迭代器模式。正是由于简
单，使用的场景才非常地多，其定义如下：

Specify the kinds of objects to create using a prototypical instance,and create new objects by
copying this prototype.（用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对
象。）

原型模式的核心是一个clone方法，通过该方法进行对象的拷贝，Java
提供了一个Cloneable接口来标示这个对象是可拷贝的，为什么说是“标示”呢？翻开JDK的帮
助看看Cloneable是一个方法都没有的，这个接口只是一个标记作用，在JVM中具有这个标记
的对象才有可能被拷贝。那怎么才能从“有可能被拷贝”转换为“可以被拷贝”呢？方法是覆盖
clone()方法

详见 prototype3

原型模式的优点

- 性能优良

原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一
个循环体内产生大量的对象时，原型模式可以更好地体现其优点

- 逃避构造函数的约束

这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。
优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑

原型模式的使用场景

- 资源优化场景

类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等

- 性能和安全要求的场景

通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式

- 一个对象多个修改者的场景

一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑
使用原型模式拷贝多个对象供调用者使用

在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的
方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为一体，大家可
以随手拿来使用

原型模式的注意事项

- 构造函数不会被执行

详见 prototype4

对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲得通的，Object类的
clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配
一个内存块，那构造函数没有被执行也是非常正常的了

- 浅拷贝和深拷贝

详见 prototype5、prototype6

是因为Java做了一个偷懒的拷贝动作，Object类提供
的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象
的内部元素地址，这种拷贝就叫做浅拷贝。确实是非常浅，两个对象共享了一个私有变量，
你改我改大家都能改，是一种非常不安全的方式，在实际项目中使用还是比较少的（当然，
这也是一种“危机”环境的一种救命方式）。你可能会比较奇怪，为什么在Mail那个类中就可
以使用String类型，而不会产生由浅拷贝带来的问题呢？内部的数组和引用对象才不拷贝，
其他的原始类型比如int、long、char等都会被拷贝，但是对于String类型，Java就希望你把它
认为是基本类型，它是没有clone方法的，处理机制也比较特殊，通过字符串池（string pool）
在需要的时候才在内存中创建新的字符串，读者在使用的时候就把String当做基本类使用即可

注意：使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成
员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可
变对象

深拷贝还有一种实现方式就是通过自己写二进制
流来操作对象，然后实现对象的深拷贝，这个大家有时间自己实现一下

- clone与final两个冤家

对象的clone与对象内的final关键字是有冲突的

详见 prototype7

粗体部分仅仅增加了一个final关键字，然后编译器就报斜体部分错误，正常呀，final类
型你还想重赋值呀！你要实现深拷贝的梦想在final关键字的威胁下破灭了，路总是有的，我
们来想想怎么修改这个方法：删除掉final关键字，这是最便捷、安全、快速的方式。你要使
用clone方法，在类的成员变量上就不要增加final关键字

注意：要使用clone方法，类的成员变量上不要增加final关键字

最佳实践

原型模式先产生出一个包含大量共有信息的类，然后可以拷贝出副本，修正细节信息，
建立了一个完整的个性对象。不知道大家有没有看过施瓦辛格演的《第六日》这部电影，电
影的主线也就是一个人被复制，然后正本和副本对掐。我们今天讲的原型模式也就是由一个
正本可以创建多个副本的概念。可以这样理解：一个对象的产生可以不由零起步，直接从一
个已经具备一定雏形的对象克隆，然后再修改为生产需要的对象。也就是说，产生一个人，
可以不从1岁长到2岁，再到3岁……也可以直接找一个人，从其身上获得DNA，然后克隆一
个，直接修改一下就是30岁了！我们讲的原型模式也就是这样的功能

