组合模式
========

引入例子：公司的人事架构，二叉树

详见 composite

和我们期望的结果一样，一棵完整的树就生成了，而且我们还能够遍历。不错，不错，
但是看类图或程序的时候，你有没有发觉有问题？getInfo每个接口都有，为什么不能抽象出
来？Root类和Branch类有什么差别？根节点本身就是树枝节点的一种，为什么要定义成两个
接口两个类?如果我要加一个任职期限，你是不是每个类都需要修改？如果我要后序遍历
（从员工找到他的上级领导）能做到吗？——彻底晕菜了！

详见 composite2

仔细看看这个类图，还能不能发现点问题。想想看接口的作用是什么？定义一类事物所
具有的共性，那ILeaf和IBranch是不是也有共性呢？有，getInfo方法！我们是不是要把这个共
性也封装起来呢？是的，是的，提炼事物的共同点，然后封装之，这是我们作为设计专家的
拿手好戏

类图上增加了一个ICorp接口，它是公司所有人员信息的接口类，不管你是经理还是员
工，你都有名字、职位、薪水，这个定义成一个接口没有错，但是你可能对于ILeaf接口持怀
疑状态，空接口有何意义呀？有意义！它是每个树枝节点的代表，系统扩容的时候你就会发
现它是多么“栋梁”

详见 composite3

进一步优化，把接口变成抽象类

组合模式的定义

组合模式(Composite Pattern)也叫合成模式，有时又叫做部分-整体模式（Part-Whole），
主要是用来描述部分与整体的关系，其定义如下：

Compose objects into tree structures to represent part-whole hierarchies.Composite lets clients
treat individual objects and compositions of objects uniformly.（将对象组合成树形结构以表
示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。）

详见 composite4

组合模式的几个角色

- Component抽象构件角色

定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性，比如我们例子
中的getInfo就封装到了抽象类中

- Leaf叶子构件

叶子对象，其下再也没有其他的分支，也就是遍历的最小单位

- Composite树枝构件

树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构

组合模式的优点

- 高层模块调用简单

一棵树形机构中的所有节点都是Component，局部和整体对调用者来说没有任何区别，
也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的
代码

- 节点自由增加

使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点是不是都很容
易，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利

组合模式的缺点

组合模式有一个非常明显的缺点，看到我们在场景类中的定义，提到树叶和树枝使用时
的定义了吗？直接使用了实现类！这在面向接口编程上是很不恰当的，与依赖倒置原则冲
突，读者在使用的时候要考虑清楚，它限制了你接口的影响范围

组合模式的使用场景

- 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理

- 从一个整体中能够独立出部分模块或功能的场景

组合模式的注意事项

只要是树形结构，就要考虑使用组合模式，这个一定要记住，只要是要体现局部和整体
的关系的时候，而且这种关系还可能比较深，考虑一下组合模式吧

组合模式的扩展

真实的组合模式

详见 composite5

什么是真实的组合模式？就是你在实际项目中使用的组合模式，而不是仅仅依照书本上
学习到的模式，它是“实践出真知”。在我们的例子中，经过精简后，确实是类、接口减少了
很多，而且程序也简单很多，但是大家可能还是很迷茫，这个Client程序并没有改变多少
呀，非常正确，树的组装是跑不了的，你要知道在项目中使用关系型数据库来存储这些信
息，你可以从数据库中直接提取出哪些人要分配到树枝，哪些人要分配到树叶，树枝与树
枝、树叶的关系等，这些都是由相关的业务人员维护到数据库中的，通常这里是把数据存放
到一张单独的表中

这张数据表定义了一个树形结构，我们要做的就是从数据库中把它读取出来，然后展现
到前台上，用for循环加上递归就可以完成这个读取。用了数据库后，数据和逻辑已经在表中
定义好了，我们直接读取放到树上就可以了，这个还是比较容易做的，大家不妨自己考虑一
下

这才是组合模式的真实引用，它依靠了关系数据库的非对象存储性能，非常方便地保存
了一个树形结构。大家可以在项目中考虑采用，想想看现在还有哪个项目不使用关系型数据
库呢

透明的组合模式

详见 composite6

透明模式是把用来组合使用
的方法放到抽象类中，比如add()、remove()以及getChildren等方法（顺便说一下，getChildren
一般返回的结果为Iterable的实现类，很多，大家可以看JDK的帮助），不管叶子对象还是树
枝对象都有相同的结构，通过判断是getChildren的返回值确认是叶子节点还是树枝节点，如
果处理不当，这个会在运行期出现问题，不是很建议的方式；安全模式就不同了，它是把树
枝节点和树叶节点彻底分开，树枝节点单独拥有用来组合的方法，这种方法比较安全，我们
的例子使用了安全模式

仅仅在遍历时不再进行牵制的类型转化了，其他的组装则没有任何变化。透明模式的好
处就是它基本遵循了依赖倒转原则，方便系统进行扩展

组合模式的遍历

详见 composite7

我们在上面也还提到了一个问题，就是树的遍历问题，从上到下遍历没有问题，但是我
要是从下往上遍历呢？比如组织机构这棵树，我从中抽取一个用户，要找到它的上级有哪
些，下级有哪些，怎么处理

在Corp类中增加了两个方法，setParent是设置父节点是谁，getParent是查找
父节点是谁

增加了粗体部分。看懂程序了吗？甭管是树枝节点还是树叶节点，在每个节点都增加了
一个属性：父节点对象，这样在树枝节点增加子节点或叶子节点是设置父节点，然后你看整
棵树除了根节点外每个节点都有一个父节点，剩下的事情还不好处理吗？每个节点上都有父
节点了，你要往上找，那就找呗！大家自己考虑一下，写个find方法，然后一步一步往上
找，非常简单的方法，这里就不再赘述

有了这个parent属性，什么后序遍历（从下往上找）、中序遍历（从中间某个环节往上
或往下遍历）都解决了，这个就不多说了

再提一个问题，树叶节点和树枝节点是有顺序的，你不能乱排，怎么办？比如我们上面
的例子，研发一组下边有3个成员，这3个成员要进行排序（在机关里这叫做排位，同样是同
事也有个先后升迁顺序），你怎么处理？问我呀，问你呢，好好想想，以后用得着的！

最佳实践
 
组合模式在项目中到处都有，比如现在的页面结构一般都是上下结构，上面放系统的
Logo，下边分为两部分：左边是导航菜单，右边是展示区，左边的导航菜单一般都是树形的
结构，比较清晰，有非常多的JavaScript源码实现了类似的树形菜单，大家可以到网上搜索
一下
 
还有，大家常用的XML结构也是一个树形结构，根节点、元素节点、值元素这些都与我
们的组合模式相匹配，之所以本章节不以XML为例子讲解，是因为很少有人还直接读写
XML文件，一般都是用JDOM或者DOM4J了

还有一个非常重要的例子：我们自己本身也是一个树状结构的一个树枝或树叶。根据我
能够找到我的父母，根据父亲又能找到爷爷奶奶，根据母亲能够找到外公外婆等，很典型的
树形结构，而且还很规范（这个要是不规范那肯定乱套了）
