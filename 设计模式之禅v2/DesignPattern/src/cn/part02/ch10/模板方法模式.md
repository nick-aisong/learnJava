模板方法模式
========

例子引入，详见templateMethod

两个实现类的run()方法都是完全相同的，那这个run()方法的实现应该出现在抽象类，不应该在实现类上，抽象是所有子类的共性封装

注意：在软件开发过程中，如果相同的一段代码复制过两次，就需要对设计产生怀疑，
架构师要明确地说明为什么相同的逻辑要出现两次或更多次

例子修改，详见templateMethod2
注意，抽象类HummerModel中的run()方法，由抽象方法变更为实现方法

模板方法模式（Template Method Pattern）的定义

Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.Template
Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's
structure.（定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改
变一个算法的结构即可重定义该算法的某些特定步骤。）

详见templateMethod3

模板方法模式确实非常简单，仅仅使用了Java的继承机制，但它是一个应用非常广泛的
模式。其中，AbstractClass叫做抽象模板，它的方法分为两类：
- 基本方法

基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用
- 模板方法

可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑

注意：为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写

在类图中还有一个角色：具体模板。ConcreteClass1和ConcreteClass2属于具体模板，实
现父类所定义的一个或多个抽象方法，也就是父类定义的基本方法在子类中得以实现

注意 抽象模板中的基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露
的属性或方法尽量不要设置为protected类型。实现类若非必要，尽量不要扩大父类中的访问权限

模板方法模式的优点

- 封装不变部分，扩展可变部分

把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。
在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易
呀，增加一个子类，实现父类的基本方法就可以了

- 提取公共部分代码，便于维护

我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱
的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码

- 行为由父类控制，子类实现

基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则

模板方法模式的缺点
 
按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成
具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类
实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目
中，会带来代码阅读的难度，而且也会让新手产生不适感
 
模板方法模式的使用场景
 
- 多个子类有公有的方法，并且逻辑基本相同时

- 重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现

- 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通
过钩子函数（见“模板方法模式的扩展”）约束其行为

模板方法模式的扩展

需求变更：
客户提出H1型号的悍马喇叭想让它响就响，H2型号的喇叭不要有声音

详见templateMethod4

看到没，H1型号的悍马是由客户自己控制是否要响喇叭，也就是说外界条件改变，影
响到模板方法的执行。在我们的抽象类中isAlarm的返回值就是影响了模板方法的执行结
果，该方法就叫做钩子方法（Hook Method）。有了钩子方法模板方法模式才算完美，大家
可以想想，由子类的一个方法返回值决定公共部分的执行结果，是不是很有吸引力呀

模板方法模式就是在模板方法中按照一定的规则和顺序调用基本方法，具体到前面那个
例子，就是run()方法按照规定的顺序（先调用start()，然后再调用engineBoom()，再调用
alarm()，最后调用stop()）调用本类的其他方法，并且由isAlarm()方法的返回值确定run()中的
执行顺序变更

最佳实践

初级程序员在写程序的时候经常会问高手“父类怎么调用子类的方法”。这个问题很有普
遍性，反正我是被问过好几回，那么父类是否可以调用子类的方法呢？我的回答是能，但强
烈地、极度地不建议这么做，那该怎么做呢

- 把子类传递到父类的有参构造中，然后调用

- 使用反射的方式调用，你使用了反射还有谁不能调用的

- 父类调用子类的静态方法

这三种都是父类直接调用子类的方法，好用不？好用！解决问题了吗？解决了！项目中
允许使用不？不允许！我就一直没有搞懂为什么要用父类调用子类的方法。如果一定要调用
子类，那为什么要继承它呢？搞不懂。其实这个问题可以换个角度去理解，父类建立框架，
子类在重写了父类部分的方法后，再调用从父类继承的方法，产生不同的结果（而这正是模
板方法模式）。这是不是也可以理解为父类调用了子类的方法呢？你修改了子类，影响了父
类行为的结果，曲线救国的方式实现了父类依赖子类的场景，模板方法模式就是这种效果

模板方法在一些开源框架中应用非常多，它提供了一个抽象类，然后开源框架写了一堆
子类。在《××× In Action》中就说明了，如果你需要扩展功能，可以继承这个抽象类，然后
覆写protected方法，再然后就是调用一个类似execute方法，就完成你的扩展开发，非常容易
扩展的一种模式
