适配器模式
========

引入例子：人力资源管理项目 人员信息管理 模块设计有缺陷

详见 adapter

非常简单，有一个对象UserInfo存储用户的所有信息（实际系统上还有很多子类，不多
说了），也就是BO（Business Object，业务对象），这个对象设计为贫血对象（Thin
Business Object），不需要存储状态以及相关的关系，本人是反对使用充血对象（Rich
Business Object），这里提到两个名词：贫血对象和充血对象，这两个名词很简单，在领域
模型中分别叫做贫血领域模型和充血领域模型，有什么区别呢？一个对象如果不存储实体状
态以及对象之间的关系，该对象就叫做贫血对象，对应的领域模型就是贫血领域模型，有实
体状态和对象关系的模型就是充血领域模型。看不懂没关系，都是糊弄人的东西，属于专用
名词。扯远了，我们继续说我们的人力资源管理项目，这个UserInfo对象，在系统中很多地
方使用，你可以查看自己的信息，也可以修改，当然这个对象是有setter方法的，我们这里用
不到就隐藏掉了

大家可能会问，这两个对象都不在一个系统中，你如何使用呢？简单！RMI已经帮我们
做了这件事情，只要有接口，就可以把远程的对象当成本地的对象使用，这个大家有时间可
以去看一下RMI文档，不多说了。OuterUserInfo可以看做是“两面派”，实现了IUserInfo接口，
还继承了OuterUser，通过这样的设计，把OuterUser伪装成我们系统中一个IUserInfo对象，这
样，我们的系统基本不用修改，所有的人员查询、调用跟本地一样

注意：我们之所以能够增加一个OuterUserInfo中转类，是因为我们在系统设计时严格遵
守了依赖倒置原则和里氏替换原则，否则即使增加了中转类也无法解决问题

适配器模式（Adapter Pattern）的定义如下：

Convert the interface of a class into another interface clients expect. Adapter lets classes work
together that couldn't otherwise because of incompatible interfaces.（将一个类的接口变换成客户
端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。）

适配器模式又叫做变压器模式，也叫做包装模式（Wrapper），但是包装模式可不止一
个，还包括了第17章讲解的装饰模式

详见 adapter2

适配器模式在生活中还是很常见的，比如你笔记本上的电源适配器，可以使用在110～
220V之间变化的电源，而笔记本还能正常工作，这也是适配器一个良好模式的体现，简单地
说，适配器模式就是把一个接口或类转换成其他的接口或类，从另一方面来说，适配器模式
也就是一个包装模式，为什么呢？它把Adaptee包装成一个Target接口的类，加了一层衣服，
包装成另外一个靓妞了。大家知道，设计模式原是为建筑设计而服务的，软件设计模式只是
借用了人家的原理而已

适配器模式的三个角色：

- Target目标角色

该角色定义把其他类转换为何种接口，也就是我们的期望接口，例子中的IUserInfo接口
就是目标角色

- Adaptee源角色

你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对
象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色

- Adapter适配器角色

适配器模式的核心角色，其他两个角色都是已经存在的角色，而适配器角色是需要新建
立的，它的职责非常简单：把源角色转换为目标角色，怎么转换？通过继承或是类关联的方式

适配器模式的优点

- 适配器模式可以让两个没有任何关系的类在一起运行，只要适配器这个角色能够搞定
他们就成

- 增加了类的透明性

想想看，我们访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高
层次模块是透明的，也是它不需要关心的

- 提高了类的复用度

当然了，源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演
员

- 灵活性非常好

某一天，突然不想要适配器，没问题，删除掉这个适配器就可以了，其他的代码都不用
修改，基本上就类似一个灵活的构件，想用就用，不想就卸载

适配器模式的使用场景

适配器应用的场景只要记住一点就足够了：你有动机修改一个已经投产中的接口时，适
配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这
个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的

适配器模式的注意事项

适配器模式最好在详细设计阶段不要考虑它，它不是为了解决还处在开发阶段的问题，
而是解决正在服役的项目问题，没有一个系统分析师会在做详细设计的时候考虑使用适配器
模式，这个模式使用的主要场景是扩展应用中，就像我们上面的那个例子一样，系统扩展
了，不符合原有设计的时候才考虑通过适配器模式减少代码修改带来的风险

再次提醒一点，项目一定要遵守依赖倒置原则和里氏替换原则，否则即使在适合使用适
配器的场合下，也会带来非常大的改造

适配器模式的扩展

详见 adapter3

我们刚刚讲的人力资源管理的例子中，其实是一个比较幸运的例子，为什么呢？如果劳
动服务公司提供的人员接口不止一个，也就是说，用户基本信息是一个接口，工作信息是一
个接口，家庭信息是一个接口，总共有三个接口三个实现类，想想看如何处理呢？不能再使
用我们上面的方法了，为什么呢？Java是不支持多继承的，你难道想让OuterUserInfo继承三
个实现类？此路不通，再想一个办法，对哦，可以使用类关联的办法嘛！声明一个
OuterUserInfo实现类，实现IUserInfo接口，通过再关联其他三个实现类不就可以解决这个问
题了吗？是的，是的，好方法，

适配器的通用代码也比较简单，把原有的继承关系变更为关联关系就可以了，不再赘
述。对象适配器和类适配器的区别是：类适配器是类间继承，对象适配器是对象的合成关
系，也可以说是类的关联关系，这是两者的根本区别。二者在实际项目中都会经常用到，由
于对象适配器是通过类间的关联关系进行耦合的，因此在设计时就可以做到比较灵活，比如
修补源角色的隐形缺陷，关联其他对象等，而类适配器就只能通过覆写源角色的方法进行扩
展，在实际项目中，对象适配器使用到场景相对较多

最佳实践

适配器模式是一个补偿模式，或者说是一个“补救”模式，通常用来解决接口不相容的问
题，在百分之百的完美设计中是不可能使用到的，什么是百分之百的完美设计？“千虑”而没
有“一失”的设计，但是，再完美的设计也会遇到“需求”变更这个无法逃避的问题，就以我们
上面的人力资源管理系统为例来说，不管系统设计得多么完美，都无法逃避新业务的发生，
技术只是一个工具而已，是因为它推动了其他行业的进步和发展而具有了价值，通俗地说，
技术是为业务服务的，因此业务在日新月异变化的同时，也对技术提出了同样的要求，在这
种要求下，就需要我们有一种或一些这样的补救模式诞生，使用这些补救模式可以保证我们
的系统在生命周期内能够稳定、可靠、健壮的运行，而适配器模式就是这样的一个“救世
主”，它在需求巨变、业务飞速而导致你极度郁闷、烦躁、崩溃的时候横空出世，它通过把
非本系统接口的对象包装成本系统可以接受的对象，从而简化了系统大规模变更风险的存
在

