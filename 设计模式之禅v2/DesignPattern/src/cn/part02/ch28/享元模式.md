享元模式
========

引入例子：报考系统内存溢出

详见：flyweight

内存溢出对Java应用来说实在是太平常了，有以下两种可能

- 内存泄漏

无意识的代码缺陷，导致内存泄漏，JVM不能获得连续的内存空间

- 对象太多

代码写得很烂，产生的对象太多，内存被耗尽。现在的情况是没有内存泄漏，那只有一
种原因——代码太差把内存耗尽

很简单的工厂方法模式，表现层通过工厂方法模式创建对象，然后传递给业务层和持久
层，最终保存到数据库中，为什么要使用工厂方法模式而不用直接new一个对象呢？因为是
在框架下编程，必须有一个对象工厂（ObjectFactory,Spring也有对象工厂）

就这么简单，但是简单为什么会出现问题呢？而且这样写也没有问题呀，很标准的工厂
方法模式，应该不会有大问题，然后又看了看系统厂商提供的分析报告，报告中指出：内存
突然由800MB飙升到1.4GB，新的对象申请不到内存空间，于是出现OutOfMemory，同时报
告中还列出宕机时刻内存中的对象，其中SignInfo类的对象就有400MB，疯子，绝对是疯
子！报告都没有看嘛！

我想了想，也确实是这么回事。既然已经定位是内存中对象太多，那就应该想到使用一
种共享的技术减少对象数量，那怎么共享呢？

大家知道，对象池（Object Pool）的实现有很多开源工具，比如Apache的commons-pool
就是一个非常不错的池工具，我们暂时还用不到这种重量级的工具，我们自己来设计一个共
享对象池，需要实现如下两个功能

- 容器定义

我们要定义一个池容器，在这个容器中容纳哪些对象

- 提供客户端访问的接口

我们要提供一个接口供客户端访问，池中有可用对象时，可以直接从池中获得，否则建
立一个新的对象，并放置到池中

设计思路有了，那我们池中对象的标准是什么呢？你想想看，如果你把所有的对象都放
到池中，那还有什么意义？内存早就给你撑爆了！这么多对象，必然有一些相同的属性值，
如几十万SignInfo对象中，考试科目就4个，考试地点也就是30多个，其他的属性则是每个对
象都不相同的，我们把对象的相同属性提取出来，不同的属性在系统内进行赋值处理，是不
是就可以建立一个池了？

详见：flyweight2

很简单，就是增加了一个key值，为什么要增加key值？为什么要使用子类，而不在
SignInfo类上做修改？好，我来给你解释为什么要这样做，我们刚刚已经分析了所有的
SignInfo对象都有一些共同的属性：考试科目和考试地点，我们把这些共性提取出来作为所
有对象的外部状态，在这个对象池中一个具体的外部状态只有一个对象。按照这个设计，我
们定义key值的标准为：考试科目+考试地点的复合字符串作为唯一的池对象标准，也就是说
在对象池中，一个key值唯一对应一个对象

注意：在对象池中，对象一旦产生，必然有一个唯一的、可访问的状态标志该对象，而
且池中的对象声明周期是由池容器决定，而不是由使用者决定的

你可能马上就要提出了，为什么不建立一个新的类，包含subject和location两个属性作为
外部状态呢？嗯，这是一个办法，但不是最好的办法，有两个原因：

- 修改的工作量太大，增加的这个类由谁来创建呢？同时，SignInfo类是否也要修改
呢？你不可能让两段相同的POJO程序同时出现在同一模块中吧

- 性能问题，我们会在扩展模块中讲解

通过这样的改造后，我们想想内存中有
多少个SignInfo对象？是的，最多120个对象，相比之前几万个SignInfo对象优化了非常多。细
心的读者可能注意到了SignInfo4Pool类基本上没有跑出我们的视线范围，仅仅在工厂方法中
使用到了，尽量缩小变更引起的风险，想想看我们的改动是不是很小，只要在展示层中拼一
个字符串，然后传递到工厂方法中就可以了

享元模式的定义

详见：flyweight3

享元模式（Flyweight Pattern）是池技术的重要实现方式，其定义如下：Use sharing to
support large numbers of fine-grained objects efficiently.（使用共享对象可有效地支持大量的细
粒度的对象。）

享元模式的定义为我们提出了两个要求：细粒度的对象和共享对象。我们知道分配太多
的对象到应用程序中将有损程序的性能，同时还容易造成内存溢出，那怎么避免呢？就是享
元模式提到的共享技术。我们先来了解一下对象的内部状态和外部状态

要求细粒度对象，那么不可避免地使得对象数量多且性质相近，那我们就将这些对象的
信息分为两个部分：内部状态（intrinsic）与外部状态（extrinsic）

- 内部状态

内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，
如我们例子中的id、postAddress等，它们可以作为一个对象的动态附加信息，不必直接储存
在具体某个对象中，属于可以共享的部分

- 外部状态

外部状态是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态，如
我们例子中的考试科目+考试地点复合字符串，它是一批对象的统一标识，是唯一的一个索
引值

类图也很简单，我们先来看我们享元模式角色名称

- Flyweight——抽象享元角色

它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现

- ConcreteFlyweight——具体享元角色

具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应
该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允
许的

- unsharedConcreteFlyweight——不可共享的享元角色

不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般
不会出现在享元工厂中

- FlyweightFactory——享元工厂

职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法

享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，我们的设计确实
也应该这样，多使用细粒度的对象，便于重用或重构

注意：在程序开发中，确认只需要一次赋值的属性则设置为final类型，避免无意修改导
致逻辑混乱，特别是Session级的常量或变量

享元模式的优点和缺点

享元模式是一个非常简单的模式，它可以大大减少应用程序创建的对象，降低程序内存
的占用，增强程序的性能，但它同时也提高了系统复杂性，需要分离出外部状态和内部状
态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混
乱

享元模式的使用场景

- 系统中存在大量的相似对象

- 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没
有特定身份

- 需要缓冲池的场景

享元模式的扩展

- 线程安全的问题

线程安全是一个老生常谈的话题，只要使用Java开发都会遇到这个问题，我们之所以要
在今天的享元模式中提到该问题，是因为该模式有太大的几率发生线程不安全，为什么呢？

我们还以报考系统为例来说明这个问题。大家有没有想过，为什么要以考试科目+考试
地点作为外部状态呢？为什么不能以考试科目或者考试地点作为外部状态呢？这样池中的对
象会更少！可以！

详见：flyweight4

看看，线程不安全了吧，这是正常的，设置的享元对象数量太少，导致每个线程都到对
象池中获得对象，然后都去修改其属性，于是就出现一些不和谐数据。只要使用Java开发，
线程问题是不可避免的，那我们怎么去避免这个问题呢？享元模式是让我们使用共享技术，
而Java的多线程又有如此问题，该如何设计呢？没什么可以参考的标准，只有依靠经验，在
需要的地方考虑一下线程安全，在大部分的场景下都不用考虑。我们在使用享元模式时，对
象池中的享元对象尽量多，多到足够满足业务为止。

- 性能平衡

尽量使用Java基本类型作为外部状态。在报考系统中，我们不考虑系统的修改风险，完
全可以重新建立一个类作为外部状态，因为这才完全符合面向对象编程的理念

注意：如果把一个对象作为Map类的键值，一定要确保重写了equals和hashCode方法，
否则会出现通过键值搜索失败的情况，例如map.get(object)、map.contains(object)等会返回失
败的结果

详见：flyweight5

看到没？一半的效率，这还是非常简单的享元对象，看看我们重写的equals方法和
hashCode方法，这段代码是必须实现的，如果比较复杂，这个时间差异会更大。

各位，想想看，使用自己编写的类作为外部状态，必须覆写equals方法和hashCode方
法，而且执行效率还比较低，这种吃力不讨好的事情最好别做，外部状态最好以Java的基本
类型作为标志，如String、int等，可以大幅地提升效率

最佳实践

Flyweight是拳击比赛中的特用名词，意思是“特轻量级”，指的是51公斤级比赛，用到设
计模式中是指我们的类要轻量级，粒度要小，这才是它要表达的意思。粒度小了，带来的问
题就是对象太多，那就用共享技术来解决

享元模式在Java API中也是随处可见，如这样的程序就是一个很好的例子
```java
public class Test {
  public static void main(String[] args) {
    String str1 = "和谐";
    String str2 = "社会";
    String str3 = "和谐社会";
    String str4;
    str4 = str1 + str2;
    System.out.println(str3 == str4);
    str4 = (str1 + str2).intern();
    System.out.println(str3 == str4);
  }
}
//false
//true
```
看看Java的帮助文件中String类的intern方法。如果是String的对象池中有该类型的值，则
直接返回对象池中的对象，那当然相等了

需要说明一下的是，虽然可以使用享元模式可以实现对象池，但是这两者还是有比较大
的差异，对象池着重在对象的复用上，池中的每个对象是可替换的，从同一个池中获得A对
象和B对象对客户端来说是完全相同的，它主要解决复用，而享元模式在主要解决的对象的
共享问题，如何建立多个可共享的细粒度对象则是其关注的重点
