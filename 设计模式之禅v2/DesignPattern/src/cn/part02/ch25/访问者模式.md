访问者模式
========

引入例子：现在有这样一个需求，我要把公司中的所有人员信息都打印汇报上去

详见：visitor

问题：

- 大老板就看部门经理的报表，小兵的报表可看可不看

- 多个大老板的“嗜好”是不同的，主管销售的，则主要关心营销的情况；主管会计的，
则主要关心企业的整体财务运行状态；主管技术的，则主要看技术的研发情况

综合成一句话，这个报表会修改：数据的修改以及报表的展现修改，按照开闭原则，项
目分析的时候已经考虑到这些可能引起变更的因素，就需要在设计时考虑通过扩展来避开未
来需求变更而引起的代码修改风险。我们来想一想，每个普通员工类和经理类都用一个方法
report（从父类继承过来的），他无法为每一个子类定制特殊的属性

我们思考一下，如何提供一个能够为每个子类定制报表的方法呢？可以这样思考，普通
员工和管理层员工是两个不同的对象，例如，我邀请一个人过来参观我的家，参观者参观完
毕后分别进行描述，那参观的对象不同，描述的结果也当然不同

详见：visitor2

两个子类的report方法都不需要了，只有Visitor类来实现了report的方法，这个猛一看还
真有点委托（intergration）的意味，我们实现出来你就知道这和委托有非常大的差距

程序是怎么实现的：
- 第一，通过循环遍历所有元素
- 第二，每个员工对象都定义了一个访问者
- 第三，员工对象把自己作为一个参数调用访问者visit方法
- 第四，访问者调用自己内部的计算逻辑，计算出相应的数据和表格元素
- 第五，访问者打印出报表和数据

事情的经过就是这个样子。那我们再来看看上面提到的数据和报表格式都会改变的情
况。首先是数据的改变，数据改了当然都要改，说不上两个方案有什么优劣；其次是报表格
式的修改，这个方案绝对是有优势的，我只要再产生一个IVisitor的实现类就可以产生一个新
的报表格式，而其他的类都不用修改，如果你用Spring开发，那就更好了，在Spring的配置
文件中使用的是接口注入，我只要把配置文件中的 ref修改一下就行了，其他的都不用修改
了！这就是访问者模式的优势所在

访问者模式的定义

访问者模式（Visitor Pattern）是一个相对简单的模式，其定义如下：Represent an
operation to be performed on the elements of an object structure. Visitor lets you define a new
operation without changing the classes of the elements on which it operates. （封装一些作用于某种
数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的
操作。）

详见：visitor3

看了这个通用类图，大家可能要犯迷糊了，这里怎么有一个ObjectStruture类呢？你刚刚
举的例子怎么就没有呢？真没有吗？我们不是定义了一个List了吗？它中间的元素是我们一
个一个手动增加上去的，这就是一个ObjectStruture，我们来看这几个角色的职责

- Visitor——抽象访问者

抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定
义哪些对象是可以被访问的

- ConcreteVisitor——具体访问者

它影响访问者访问到一个类后该怎么干，要做什么事情

- Element——抽象元素

接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定
义的

- ConcreteElement——具体元素

实现accept方法，通常是visitor.visit(this)，基本上都形成了一种模式了

- ObjectStruture——结构对象

元素产生者，一般容纳在多个不同类、不同接口的容器，如List、Set、Map等，在项目
中，一般很少抽象出这个角色

通过增加访问者，只要是具体元素就非常容易访问，对元素的遍历就更加容易了，甭管
它是什么对象，只要它在一个容器中，都可以通过访问者来访问，任务集中化。这就是访问
者模式

访问者模式的优点

- 符合单一职责原则

具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报
表的展现，两个不同的职责非常明确地分离开来，各自演绎变化

- 优秀的扩展性

由于职责分开，继续增加对数据的操作是非常快捷的，例如，现在要增加一份给大老板
的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传递数据后进行整理打
印

- 灵活性非常高

例如，数据汇总，就以刚刚我们说的Employee的例子，如果我现在要统计所有员工的工
资之和，怎么计算？把所有人的工资for循环加一遍？是个办法，那我再提个问题，员工工资
×1.2，部门经理×1.4，总经理×1.8，然后把这些工资加起来，你怎么处理？1.2，1.4，1.8是什
么？不是吧？！你没看到领导不论什么时候都比你拿得多，工资奖金就不说了，就是过节发
个慰问券也比你多，就是这个系数在作祟。我们继续说你想怎么统计？使用for循环，然后使
用instanceof来判断是员工还是经理？这可以解决，但不是个好办法，好办法是通过访问者模
式来实现，把数据扔给访问者，由访问者来进行统计计算

访问者模式的缺点

- 具体元素对访问者公布细节

访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其
他类的内部细节，这是迪米特法则所不建议的

- 具体元素变更比较困难

具体元素角色的增加、删除、修改都是比较困难的，就上面那个例子，你想想，你要是
想增加一个成员变量，如年龄age，Visitor就需要修改，如果Visitor是一个还好办，多个呢？
业务逻辑再复杂点呢

- 违背了依赖倒置转原则

访问者依赖的是具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对
象的编程中，抛弃了对接口的依赖，而直接依赖实现类，扩展比较难

访问者模式的使用场景

- 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖
于其具体类的操作，也就说是用迭代器模式已经不能胜任的情景

- 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操
作“污染”这些对象的

总结一下，在这种地方你一定要考虑使用访问者模式：业务规则要求遍历多个不同的对
象。这本身也是访问者模式出发点，迭代器模式只能访问同类或同接口的数据（当然了，如
果你使用instanceof，那么能访问所有的数据，这没有争论），而访问者模式是对迭代器模式
的扩充，可以遍历不同的对象，然后执行不同的操作，也就是针对访问的对象不同，执行不
同的操作。访问者模式还有一个用途，就是充当拦截器（Interceptor）角色，这个我们将在
混编模式中讲解

访问者模式的扩展

- 统计功能

详见：visitor4

在例子中我们也提到访问者的统计功能，汇总和报表是金融类企业非常常用的功能，基
本上都是一堆的计算公式，然后出一个报表，很多项目采用了数据库的存储过程来实现，我
不是很推荐这种方式，除非海量数据处理，一个晚上要批处理上亿、几十亿条的数据，除了
存储过程来处理还没有其他办法，你要是用应用服务器来处理，连接数据库的网络就是处于
100%占用状态，一个晚上也未必能处理完这批数据！除了这种海量数据外，我建议数据统
计和报表的批处理通过访问者模式来处理会比较简单

- 多个访问者

详见：visitor5

在实际的项目中，一个对象，多个访问者的情况非常多。其实我们上面例子就应该是两
个访问者，为什么呢？报表分两种：第一种是展示表，通过数据库查询，把结果展示出来，
这个就类似于我们的那个列表；第二种是汇总表，这个是需要通过模型或者公式计算出来
的，一般都是批处理结果，这个类似于我们计算工资总额，这两种报表格式是对同一堆数据
的两种处理方式。从程序上看，一个类就有个不同的访问者了

大家可以再深入地想象，一堆数据从几个角度来分析，那是什么？即数据挖掘（Data
Mining），数据的上切、下钻等处理，大家有兴趣看可以翻看数据挖掘或者商业智能（BI）
的书

- 双分派

说到访问者模式就不得不提一下双分派（double dispatch）问题，什么是双分派呢？我
们先来解释一下什么是单分派（single dispatch）和多分派（multiple dispatch），单分派语言
处理一个操作是根据请求者的名称和接收到的参数决定的，在Java中有静态绑定和动态绑定
之说，它的实现是依据重载（overload）和覆写（override）实现的，我们来说一个简单的例
子

例如，演员演电影角色，一个演员可以扮演多个角色，我们先定义一个影视中的两个角
色：功夫主角和白痴配角

```java
//代码清单25-25 角色接口及实现类
public interface Role {
  //演员要扮演的角色
}

public class KungFuRole implements Role {
  //武功天下第一的角色
}

public class IdiotRole implements Role {
  //一个弱智角色
}

//代码清单25-26 抽象演员
public abstract class AbsActor {
  //演员都能够演一个角色
  public void act(Role role){
    System.out.println("演员可以扮演任何角色");
  }
  //可以演功夫戏
  public void act(KungFuRole role){
    System.out.println("演员都可以演功夫角色");
  }
}

//代码清单25-27 青年演员和老年演员
public class YoungActor extends AbsActor {
  //年轻演员最喜欢演功夫戏
  public void act(KungFuRole role){
    System.out.println("最喜欢演功夫角色");
  }
}

public class OldActor extends AbsActor {
  //不演功夫角色
  public void act(KungFuRole role){
    System.out.println("年龄大了，不能演功夫角色");
  }
}

//代码清单25-28 场景类
public class Client {
  public static void main(String[] args) {
    //定义一个演员
    AbsActor actor = new OldActor();
    //定义一个角色
    Role role = new KungFuRole();
    //开始演戏
    actor.act(role);
    actor.act(new KungFuRole());
  }
}

//演员可以扮演任何角色
//年龄大了，不能演功夫角色
```
重载在编译器期就决定了要调用哪个方法，它是根据role的表面类型而决定调用act(Role
role)方法，这是静态绑定；而Actor的执行方法act则是由其实际类型决定的，这是动态绑
定

一个演员可以扮演很多角色，我们的系统要适应这种变化，也就是根据演员、角色两个
对象类型，完成不同的操作任务，该如何实现呢？很简单，我们让访问者模式上场就可以解
决该问题，只要把角色类稍稍修改即可

```java
//代码清单25-29 引入访问者模式
public interface Role {
  //演员要扮演的角色
  public void accept(AbsActor actor);
}

public class KungFuRole implements Role {
  //武功天下第一的角色
  public void accept(AbsActor actor){
    actor.act(this);
  }
}

public class IdiotRole implements Role {
  //一个弱智角色，由谁来扮演
  public void accept(AbsActor actor){
    actor.act(this);
  }
}

//代码清单25-30 场景类
public class Client {
  public static void main(String[] args) {
    //定义一个演员
    AbsActor actor = new OldActor();
    //定义一个角色
    Role role = new KungFuRole();
    //开始演戏
    role.accept(actor);
  }
}

//年龄大了，不能演功夫角色
```
看到没？不管演员类和角色类怎么变化，我们都能够找到期望的方法运行，这就是双反
派。双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型，它是多分派的一
个特例。从这里也可以看到Java是一个支持双分派的单分派语言

最佳实践

访问者模式是一种集中规整模式，特别适用于大规模重构的项目，在这一个阶段需求已
经非常清晰，原系统的功能点也已经明确，通过访问者模式可以很容易把一些功能进行梳
理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他
模式混编建立一套自己的过滤器或者拦截器，请大家参考混编模式的相关章节
