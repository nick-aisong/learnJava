新模式
========

设计模式已经诞生多年，“23”这个数字也在逐渐变大，这是好事情，表明我们软件界正
在积累、汇编我们的知识和经验。一个模式的提出和成熟需要一段时间，因此本章挑选了5
个大家时常使用，但又经常忽视的新模式进行讲解，即
- 规格模式
- 对象池模式
- 雇工模式
- 黑板模式
- 空对象模式

希望这5个新模式能够帮助大家解决更多的实际开发难题

#### 规格模式

详见：specification

规格模式的实现

不知道诸位有没有使用C#3.5做过开发，它有一个非常重要的新特性——
LINQ（Language INtegrated Query，语言集成查询），它提供了类似于SQL语法的遍历、筛选
等功能，能完成对对象的查询，就像通过SQL语句查询数据库一样，例如这样的一个程序片段：
```
Dim DataList As String() = {"abc", "def", "ght"}
Dim Result = From T As String In DataList Where T = "abc"
```
这句话的意思就是从一个数组中查找出值为abc的元素，返回结果为IEnumerable，枚举
器类型。注意看第二句话，它使用了类似SQL的Select语法结构，from、where关键字都有
了，而且还支持类似的Orderby、Groupby功能，很强大，有兴趣的读者可以查阅有关资料。
那在Java世界中是否也存在这样的辅助框架呢？有，JoSQL、Quaere都可以提供类似的LINQ
语言，读者可以到网上研究一下JavaDoc，同样非常简单，功能强大

我们今天要讲的主题与LINQ有很大关系，它是实现LINQ的核心。想想SQL语句中什么
是最复杂的，是where后面的查询条件，看看自己写的SQL语句基本上都是一长串的条件判
断，中间一堆的and、or、not逻辑符。我们今天的任务就是要实现条件语句的解析，该部分
实现了，基本上LINQ语法已经实现了一大半

我们以一个案例来讲解该技术，在内存中有10个User对象，根据不同的条件查找出用
户，比如姓名包含某个字符、年龄小于多少岁等条件，类似这样的SQL：
```
Select * From User where name like '%国庆%'
```
查找出姓名中包含“国庆”两个字的用户，这在关系型数据库中很容易实现，但是在对象
群中怎么实现这样的查询呢？好，看似很简单，先设计一个用户类，然后提供一个用户查找
工具类，类图非常容易，如图38-1所示

结果非常正确，但是这样的一个框架基本上是不能适应业务变化的，为什么呢？业务变
化虽然无规则，但是可以预测，比如我们这个查询，今天要查找年龄大于20岁的用户，明天
要查找年龄小于30岁的用户，后天要查找姓名中包含“国庆”两个字的用户，想想看
IUserProvider接口是不是要一直修改下去？接口是契约，而且我们一直提倡面向接口编程，
但是在这里接口竟然都可以修改，是不是发现设计有很大问题了！

问题发现了，就要想办法解决。再回顾一下编写的代码，注意看findUserByAgeThan和
findUserByNameEqual两个方法，两者的代码有什么不同呢？除了if后面的判断条件不同外，
就没有不同的地方了，我们一直在说封装变化，这两段程序就仅仅有这一个变化点，我们是
不是可以把它封装起来呢？完全可以，把它们两者的共同点抽取出来，先修改一下接口，如
代码清单38-5所示

这个接口的设计想法非常好，但是参数condition很难实现，看看findUserByAgeThan、
findUserByNameEqual这两个方法，怎么才能把两者的不同点设置成一个布尔型呢？如果需要
在IUserProvider对象外判断后传递进来，那我们的封装就没有任何意义了——目前为止，这
个方案有问题了

继续考虑，既然不能在封装外运算，那就把整个条件都进行封装，由IUserProvider自己
实现运算。好方法！那我们就设计一个这样的类，我们叫它规格类，什么意思呢？它是对一
批对象的说明性描述，它依照基准判断候选对象是否满足条件

在该类图中建立了一个规格书接口，它的作用就是定制各种各样的规格，比如名字相等
的规格UserByNameEqual、年龄大于基准年龄的规格UserByAgeThan等，然后在用户操作类中
采用该规格进行判断。User类没有任何改变，如代码清单38-1所示，不再赘述

规格书接口只定义一个方法，判断候选用户是否满足条件。再来看姓名相同的规格书，
它实现了规格书接口，如代码清单38-7所示

代码很简单，通过构造函数传递进来基准用户名，然后判断候选用户是否匹配。大于基
准年龄的规格书与此类似，如代码清单38-8所示

规格书都已经定义完毕，我们再来看用户操作类，先看用户操作的接口，如代码清单38-9所示

只有一个方法——根据指定的规格书查找用户。再来看其实现类，如代码清单38-10所示

程序改动很小，仅仅在if判断语句中根据规格书进行判断，我们持续地扩展规格书，有
多少查询分类就可以扩展出多少个实现类，而IUserProvider则不需要任何改动，它的一个方
法就覆盖了我们刚刚提出的N多查询路径。我们设计一个场景来看看效果如何，如代码清单
38-11所示

大家想想看，如果现在需求变更了，比如需要一个年龄小于基准年龄的用户，该怎么修
改？增加一个小于基准年龄的规格书，实现IUserSpecification接口，然后在新的业务中调用
即可，别的什么都不需要修改。再比如需要一个类似SQL中like语句的处理逻辑，这个也不
难，如代码清单38-12所示

到目前为止，我们已经设计了一个可扩展的对象查询平台，但是我们还有遗留问题未解
决，看看SQL语句，为什么where后面会很长？是因为有AND、OR、NOT这些逻辑操作符的
存在，它们可以串联起多个判断语句，然后整体反馈出一个结果来。想想看，我们上面的平
台能支持这种逻辑操作符吗？不能，你要说能，那也说得通，需要两次过滤才能实现，比如
要找名字包含“国庆”并且年龄大于25岁的用户，代码该怎么修改？如代码清单38-14所示

能够实现，但是思考一下程序逻辑，它采用了两次过滤，也就是两次循环，如果对象数
量少还好说，如果对象数量巨大，这个效率就太低了，这是其一；其二，组合方式非常多，
比如“与”、“或”、“非”可以自由组合，姓名中包含“国庆”但年龄小于25的用户，姓名中不包
含国庆但年龄大于25岁的用户等，我们还能如此设计吗？太多的组合方式，产生组合爆炸，
这种设计就不妥了，应该有更优秀的方案

我们换个方式思考该问题，不管是AND或者OR或者NOT操作，它们的返回结果都还是
一个规格书，只是逻辑更复杂了而已，这3个操作符只是提供了对原有规格书的复合作用，
换句话说，规格书对象之间可以进行与或非操作，操作的结果不变，分析到这里，我们就可
以开始修改接口了，如代码清单38-15所示

在规格书接口中增加了与或非的操作，接口修改了，实现类当然也要修改。先全面思考
一下业务，与或非是不可扩展的操作，规格书（也就是规格对象）之间的操作只有这三种方
法，是不需要扩展也不用预留扩展空间的。如此，我们就可以把与或非的实现放到基类中，
那现在的问题变成了怎么在基类中实现与或非。注意看它们的返回值都需要返回规格书类
型，很明显，我们在这里要用到递归调用了。可以这样理解，基类需要子类提供业务逻辑支
持，因为基类是一个抽象类，不能实例化后返回，我们把简单类图画出来，如图38-3所示

基类对子类产生了依赖，然后进行递归计算，大家一定会发出这样的疑问：父类怎么可
能依赖子类，这还是面向接口编程吗？想想看，我们提出面向接口编程的目的是什么？是为
了适应变化，拥抱变化，对于不可能发生变化的部分为什么不能固化呢？与或非操作符号还
会增加修改吗？规格书对象之间的操作还有其他吗？思考清楚这些问题后，答案就迎刃而解了

注意：父类依赖子类的情景只有在非常明确不会发生变化的场景中存在，它不具备扩展
性，是一种固化而不可变化的结构

可能大家有很多的疑问，我们先来分析代码，代码分析完毕估计能解决你大部分的疑
问。规格书接口如代码清单38-15所示，不再赘述。我们来看组合规格书
（CompositeSpecification），它是一个抽象类，实现了与或非的操作，如代码清单38-16所示

候选对象是否满足条件是由isSatisfiedBy方法决定的，它代表的是一个判断逻辑，由各
个实现类实现。三个与或非操作在抽象类中实现，它是通过直接new了一个子类，如此设计
非常符合单一职责原则，每个子类都有一个独立的职责，要么完成“与”操作，要么完
成“或”操作，要么完成“非”操作。我们先来看“与”操作规格书，如代码清单38-17所示

这三个规格书都是不发生变化的，只要使用该框架，三个规格书都要实现的，而且代码
基本上是雷同的，所以才有了父类依赖子类的设计，否则是严禁出现父类依赖子类的情况
的。大家再仔细看看这三个规格书和组合规格书，代码很简单，但也很巧妙，它跳出了我们
面向对象设计的思维，不变部分使用一种固化方式实现

姓名相同、年龄大于基准年龄、Like格式等规格书都有少许改变，把实现接口变为继承
基类，我们以名字相等规格书为例，如代码清单38-20所示

到此为止我们的LINQ已经完成了很大一部分了，SQL语句中的where后面部分已经可以
解析了，完全可以再增加年龄相等的规格书、姓名字数规格书等，你在SQL中使用过的条件
在这里都能实现了。功臣还是依赖于三个与或非规格书，有了它们三个栋梁才能组合出一个
精彩的条件查询世界

最佳实践

详见：specification2

我们在例子中多次提到规格两个字，该实现模式就叫做规格模式（Specification
Pattern），它不属于23个设计模式，它是其中一个模式的扩展，是哪个模式呢？

我们用全局的观点思考一下，基类代表的是所有的规格书，它的目的是描述一个完整
的、可组合的规格书，它代表的是一个整体，其下的And规格书、Or规格书、Not规格书、年
龄大于基准年龄规格书等都是一个真实的实现，也就是一个局部，现在我们又回到了整体和
部分的关系了，那这是什么模式？对，组合模式，它是组合模式的一种特殊应用，我们来看
它的通用类图，如图38-5所示

以上一个接口、一个抽象类、3个实现类只要在适用规格模式的地方都完全相同，不用
做任何的修改，大家闭着眼照抄就成，要修改的是下面的规格书——业务规格书，如代码清
单38-27所示

规格模式已经是一个非常具体的应用框架了（相对于23个设计模式），大家遇到类似多
个对象中筛选查找，或者业务规则不适于放在任何已有实体或值对象中，而且规则的变化和
组合会掩盖那些领域对象的基本含义，或者是想自己编写一个类似LINQ的语言工具的时候
就可以照搬这部分代码，只要实现自己的逻辑规格书即可

#### 对象池模式

详见：objectPool

上周二，师兄过来找我，他负责运维一个大型新闻网站，说是网站出现性能，让我帮忙
分析调优。我这几天正好闲得手痒，同时又卖个人情，何乐而不为呢。于是我们俩就到机房
蹲点，追查问题

正确的池化

网站首页内容基本都是静态的（轮询生成），唯一的动态部分是网站的激励语，比
如“积一时之跬步，臻千里之遥程”、“业精于勤，荒于嬉；行成于思，毁于随”等励志语句，
这是一个简单的SQL随机查询结果，表中的数量在5000条左右，而且结构简单，查询性能不
是问题。示例代码如代码清单38-29所示
```java
//代码清单38-29 无缓存的SQL随机读取
@Service
public class WisdomProvider {
    @Autowire
    private WisdomDao wisdomDao;
    
    public String getOneWord() {
        return wisdomDao.randomOneWisdom();
    }
}
```
对于代码中的@Service、@Autowire注解，做过Spring开发的都懂，这是一个典型的三
层架构，WisdomDao的randomOneWisdom方法是通过数据库随机函数查询一条记录。在跟踪
过程中，发现高峰期数据库连接偶尔出现占满情况，而且都是查询该表（顺便说下，该数据
库的随机查询算法有缺陷），问题找到了：每一次访问都会直接查询数据库，没有缓存。通
常情况下，这没有问题，但是在高并发的情况下，例如在10万PV的压力下服务器基本就垮
掉了，这是非常严重的问题

怎么解决呢？好办，引入一个对象池，把这5000条记录（根据评估最多不超过20000条
记录）在启动时直接加载到内存中，在需要时再从内存中取得，以后查询不再与数据库交
互。示例代码如代码清单38-30所示
```java
@Service
public class WisdomProvider {
    @Autowire
    private WisdomDao wisdomDao;
    
    private List<String> wisdoms = null;
    
    @PostConstruct
    public void init() {
        wisdoms = wisdomDao.getAll();
    }
    
    public String getOneWord() {
        return RandomUtils.getOne(wisdoms);
    }
}
```
@PostConstruct注解的作用是Spring容器在启动完毕后，直接执行init方法，一次性读取
所有的数据，然后在应用运行期间不再与数据库交互，直接从List列表中获取数据。通过这
样的修正，系统性能有了大幅提升，在不增加硬件的情况下，彻底解决了性能问题。这就是
对象池模式

对象池模式的意图

对象池模式，或者称为对象池服务，其意图如下：

通过循环使用对象，减少资源在初始化和释放时的昂贵损耗

注意：这里的“昂贵”可能是时间效益（如性能），也可能是空间效益（如并行处理），
在大多的情况下，“昂贵”指性能

简单地说，在需要时，从池中提取；不用时，放回池中，等待下一个请求。典型例子是
连接池和线程池，这是我们开发中经常接触到的。类图如图38-6所示

对象池提供两个公共的方法：checkOut负责从池中提取对象，checkIn负责把回收对象
（当然，很多时候checkIn已经自动化处理，不需要显式声明,如连接池），对象池代码如代
码清单38-31所示

这是一个简单的对象池实现，在实际应用中还需要考虑池的最小值、最大值、池化对象
状态（若有的话，需要重点考虑）、异常处理（如满池情况）等方面，特别是池化对象状
态，若是有状态的业务对象则需要重点关注

最佳实践

把对象池化的本意是期望一次性初始化所有对象，减少对象在初始化上的昂贵性能开
销，从而提高系统整体性能。然而池化处理本身也要付出代价，因此，并非任何情况下都适
合采用对象池化

通常情况下，在重复生成对象的操作成为影响性能的关键因素时，才适合进行对象池
化。但是若池化所能带来的性能提高并不显著或重要的话，建议放弃对象池化技术，以保持
代码的简明，转而使用更好的硬件来提高性能为佳

对象池技术在Java领域已经非常成熟，只要做过企业级开发的人员，基本都用过C3P0、
DBCP、Proxool等连接池，也配置过minPoolSize、maxPoolSize等参数，这是对象池模式的典
型应用。在实际开发中若需要对象池，建议使用common-pool工具包来实现，简单、快捷、
高效

#### 雇工模式

详见：servant

雇工合作

我是一个富豪（当然只是想象中的），家里有很多佣人，家务活基本上不用我动手，我
只要动动口就可以了，在这里每个人都有不同分工，我可以指挥厨师把厨房弄干净，这是他
的地盘；我可以指挥园丁把花园收拾干净、漂亮，这是他应该做的；我还可以让裁缝把我的
衣服收拾干净。注意看，我这里列举出的三个对象（厨师、园丁、裁缝）都具有相同的功
能：清洁。从另一方面说，厨房、花园、衣服都具有被清洁的特性，我们从这一例子入手，
编写代码如代码清单38-32所示

三个对象（厨房、花园、衣服）的共同特征抽取出来，同时也需要把厨师、裁缝、园丁
的共同特征也抽象出来。从我这个主人的角度看来，他们三者都是清洁者，只是输入的对象
不同而已，如代码清单38-33所示

非常简单，就这么一个清洁者就可以厨师、园丁、裁缝。我们再编写一个场景类，描述
一下发生了什么事，如代码清单38-34所示

场景写完了，运行一下，就可以看到厨师打扫了厨房，园丁清洁了花园，裁缝清洁了衣
服。代码很简单，但是诸位有没有发觉这和我们通常的分析是不同的。通常的做法是：既然
厨师、园丁、裁缝都具有清洁的功能，那就定义一个接口描述三者的清洁功能，然后再定义
三个类，分别代表厨师、园丁、裁缝实现这个接口。这是一种常用的解决办法，可以解决该
问题，但今天我们从另外一个侧面进行分析，引出一个新的模式:雇工模式

雇工模式的意图

详见：servant2

雇工模式也叫做仆人模式（Servant Design Pattern），其意图是：

雇工模式是行为模式的一种，它为一组类提供通用的功能，而不需要类实现这些功能，
它是命令模式的一种扩展

看看我们的例子，厨师、裁缝、园丁是一组类，都具有清洁的能力，但是我们却没实
现，而是采用一种更优雅的方式来实现，这就是雇工模式。雇工模式的类图如图38-7所示

在类图中，IServiced是用于定义“一组类”所具有的功能，其示例代码如代码清单38-35所示

针对不同的服务对象具备不同的服务内容，也就是具体的功能实现IServiced接口即可，
示例代码如代码清单38-36所示

功能定义完毕后，我们需要由一个雇工来执行这些功能。简单地说，就是需要有一个执
行者，可以把一组功能聚集起来，示例代码如代码清单38-37所示

在整个雇工模式中，所有具有IServiced功能的类可以实现该接口，然后由雇工类Servant
进行集合，完成一组类不用实现通用功能而具有相应职能的目的

最佳实践

在日常的开发过程中，我们可能已经接触过雇工模式，只是我们没有把它抽取出来，也
没有汇编成册。或许大家已经看出这与命令模式非常相似，读者可以回顾第15章，会发现雇
工模式是命令模式的一种简化，但它更符合我们实际的需要，更容易引入开发场景中

#### 黑板模式

详见：blackboard

黑板模式的意图

黑板模式（Blackboard Design Pattern）是观察者模式的一个扩展，知名度并不高，但是
我们使用的范围却非常广。黑板模式的意图如下：

允许消息的读写同时进行，广泛地交互消息

简单地说，黑板模式允许多个消息读写者同时存在，消息的生产者和消费者完全分开。
这就像一个黑板，任何一个教授（消息的生产者）都可以在其上书写消息，任何一个学生
（消息的消费者）都可以从黑板上读取消息，两者在空间和时间上可以解耦，并且互不干
扰。示意图如图38-8所示

看到这个图大家可能会说：这不是一个简单的消息广播吗？是的，确实如此，黑板模式
确实是消息的广播，主要解决的问题是消息的生产者和消费者之间的耦合问题，它的核心是
消息存储（黑板），它存储所有消息，并可以随时被读取。当消息生产者把消息写入到消息
仓库后，其他消费者就可以从仓库中读取。当然，此时消息的写入者也可以变身为消息的阅
读者，读写者在时间上解耦。对于这些消息，消费者只需要关注特定消息，不处理与自己不
相关的消息，这一点通常通过过滤器来实现

黑板模式的实现方法

黑板模式一般不会对架构产生什么影响，但它通常会要求有一个清晰的消息结构。黑板
模式一般都会提供一系列的过滤器，以便消息的消费者不再接触到与自己无关的消息。在实
际开发中，黑板模式常见的有两种实现方式

- 数据库作为黑板

利用数据库充当黑板，生产者更新数据信息，不同的消费者共享数据库中信息，这是最
常见的实现方式。该方式在技术上容易实现，开发量较少，熟悉度较高。缺点是在大量消息
和高频率访问的情况下，性能会受到一定影响

在该模式下，消息的读取是通过消费者主动“拉取”，因此该模式也叫做“拉模式”

- 消息队列作为黑板

以消息队列作为黑板，通过订阅-发布模型即可实现黑板模式。这也是黑板模式被淡忘
的一个重要原因：消息队列（Message Queue）已经非常普及了，做Java开发的已经没有几个
不知道消息队列的

在该模式下，消费者接收到的消息是被主动推送过来的，因此该模式也称为“推模式”

提示：黑板模式不做详细讲解，因为我们现在已经在大量使用消息队列，既可以做到消
息的同步处理，也可以实现异步处理，相信大家已经在开发中广泛使用了，它已经成为跨系
统交互的一个事实标准了

#### 空对象模式

详见：nullObject

空对象模式（Null Object Pattern）是通过实现一个默认的无意义对象来避免null值出现，
简单地说，就是为了避免在程序中出现null值判断而诞生的一种常用设计方法

空对象模式的例子

举个简单的例子来说明，我们写一个听动物叫声的模拟程序，如代码清单38-38所示

然后再定义一个人来听动物的叫声，如代码清单38-39所示

注意看粗体部分，也许你觉得程序没有什么问题，输入参数animal是应该做空值判断。
但是，我们这样思考：在一个完整的系统中，animal对象是如何产生？什么原因会产生null
值？如果我们能够控制住null值的产生，是不是就可以去掉这个空值判断了？那这样，程序
是不是更易读更简单？好，我们就编写一个更完美的程序，增加一个NullAnimal类，如代码
清单38-40所示

增加了NullAnimal类后，在Person类中就不需要"animal!=null"这句话了，因为我们提供了
一个实现接口的所有方法，不会再产生null对象。想象一个Web项目中，animal对象可能由
MVC框架映射产生，我们只要定义一个默认的映射对象是NullAnimal，就可以解决空值判断
的问题，提升代码的可读性。这就是空对象模式（一些项目组把它作为编码规范的一部
分），非常简单，但非常实用

最佳实践

空对象模式是通过空代码实现一个接口或抽象类的所有方法，以满足开发需求，简化程
序。它如此简单，以至于我们经常在代码中看到和使用，对它已经熟视无睹了，而它无论是
事前规划或事后重构，都不会对我们的代码产生太大冲击，这也是我们“藐视”它的根本原因
