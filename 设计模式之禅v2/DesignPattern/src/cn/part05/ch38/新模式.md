新模式
========

设计模式已经诞生多年，“23”这个数字也在逐渐变大，这是好事情，表明我们软件界正
在积累、汇编我们的知识和经验。一个模式的提出和成熟需要一段时间，因此本章挑选了5
个大家时常使用，但又经常忽视的新模式进行讲解，即
- 规格模式
- 对象池模式
- 雇工模式
- 黑板模式
- 空对象模式

希望这5个新模式能够帮助大家解决更多的实际开发难题

#### 规格模式

详见：specification

规格模式的实现

不知道诸位有没有使用C#3.5做过开发，它有一个非常重要的新特性——
LINQ（Language INtegrated Query，语言集成查询），它提供了类似于SQL语法的遍历、筛选
等功能，能完成对对象的查询，就像通过SQL语句查询数据库一样，例如这样的一个程序片段：
```
Dim DataList As String() = {"abc", "def", "ght"}
Dim Result = From T As String In DataList Where T = "abc"
```
这句话的意思就是从一个数组中查找出值为abc的元素，返回结果为IEnumerable，枚举
器类型。注意看第二句话，它使用了类似SQL的Select语法结构，from、where关键字都有
了，而且还支持类似的Orderby、Groupby功能，很强大，有兴趣的读者可以查阅有关资料。
那在Java世界中是否也存在这样的辅助框架呢？有，JoSQL、Quaere都可以提供类似的LINQ
语言，读者可以到网上研究一下JavaDoc，同样非常简单，功能强大

我们今天要讲的主题与LINQ有很大关系，它是实现LINQ的核心。想想SQL语句中什么
是最复杂的，是where后面的查询条件，看看自己写的SQL语句基本上都是一长串的条件判
断，中间一堆的and、or、not逻辑符。我们今天的任务就是要实现条件语句的解析，该部分
实现了，基本上LINQ语法已经实现了一大半

我们以一个案例来讲解该技术，在内存中有10个User对象，根据不同的条件查找出用
户，比如姓名包含某个字符、年龄小于多少岁等条件，类似这样的SQL：
```
Select * From User where name like '%国庆%'
```
查找出姓名中包含“国庆”两个字的用户，这在关系型数据库中很容易实现，但是在对象
群中怎么实现这样的查询呢？好，看似很简单，先设计一个用户类，然后提供一个用户查找
工具类，类图非常容易，如图38-1所示

结果非常正确，但是这样的一个框架基本上是不能适应业务变化的，为什么呢？业务变
化虽然无规则，但是可以预测，比如我们这个查询，今天要查找年龄大于20岁的用户，明天
要查找年龄小于30岁的用户，后天要查找姓名中包含“国庆”两个字的用户，想想看
IUserProvider接口是不是要一直修改下去？接口是契约，而且我们一直提倡面向接口编程，
但是在这里接口竟然都可以修改，是不是发现设计有很大问题了！

问题发现了，就要想办法解决。再回顾一下编写的代码，注意看findUserByAgeThan和
findUserByNameEqual两个方法，两者的代码有什么不同呢？除了if后面的判断条件不同外，
就没有不同的地方了，我们一直在说封装变化，这两段程序就仅仅有这一个变化点，我们是
不是可以把它封装起来呢？完全可以，把它们两者的共同点抽取出来，先修改一下接口，如
代码清单38-5所示

这个接口的设计想法非常好，但是参数condition很难实现，看看findUserByAgeThan、
findUserByNameEqual这两个方法，怎么才能把两者的不同点设置成一个布尔型呢？如果需要
在IUserProvider对象外判断后传递进来，那我们的封装就没有任何意义了——目前为止，这
个方案有问题了

继续考虑，既然不能在封装外运算，那就把整个条件都进行封装，由IUserProvider自己
实现运算。好方法！那我们就设计一个这样的类，我们叫它规格类，什么意思呢？它是对一
批对象的说明性描述，它依照基准判断候选对象是否满足条件

在该类图中建立了一个规格书接口，它的作用就是定制各种各样的规格，比如名字相等
的规格UserByNameEqual、年龄大于基准年龄的规格UserByAgeThan等，然后在用户操作类中
采用该规格进行判断。User类没有任何改变，如代码清单38-1所示，不再赘述

规格书接口只定义一个方法，判断候选用户是否满足条件。再来看姓名相同的规格书，
它实现了规格书接口，如代码清单38-7所示

代码很简单，通过构造函数传递进来基准用户名，然后判断候选用户是否匹配。大于基
准年龄的规格书与此类似，如代码清单38-8所示

规格书都已经定义完毕，我们再来看用户操作类，先看用户操作的接口，如代码清单38-9所示

只有一个方法——根据指定的规格书查找用户。再来看其实现类，如代码清单38-10所示

程序改动很小，仅仅在if判断语句中根据规格书进行判断，我们持续地扩展规格书，有
多少查询分类就可以扩展出多少个实现类，而IUserProvider则不需要任何改动，它的一个方
法就覆盖了我们刚刚提出的N多查询路径。我们设计一个场景来看看效果如何，如代码清单
38-11所示

大家想想看，如果现在需求变更了，比如需要一个年龄小于基准年龄的用户，该怎么修
改？增加一个小于基准年龄的规格书，实现IUserSpecification接口，然后在新的业务中调用
即可，别的什么都不需要修改。再比如需要一个类似SQL中like语句的处理逻辑，这个也不
难，如代码清单38-12所示

到目前为止，我们已经设计了一个可扩展的对象查询平台，但是我们还有遗留问题未解
决，看看SQL语句，为什么where后面会很长？是因为有AND、OR、NOT这些逻辑操作符的
存在，它们可以串联起多个判断语句，然后整体反馈出一个结果来。想想看，我们上面的平
台能支持这种逻辑操作符吗？不能，你要说能，那也说得通，需要两次过滤才能实现，比如
要找名字包含“国庆”并且年龄大于25岁的用户，代码该怎么修改？如代码清单38-14所示

能够实现，但是思考一下程序逻辑，它采用了两次过滤，也就是两次循环，如果对象数
量少还好说，如果对象数量巨大，这个效率就太低了，这是其一；其二，组合方式非常多，
比如“与”、“或”、“非”可以自由组合，姓名中包含“国庆”但年龄小于25的用户，姓名中不包
含国庆但年龄大于25岁的用户等，我们还能如此设计吗？太多的组合方式，产生组合爆炸，
这种设计就不妥了，应该有更优秀的方案

我们换个方式思考该问题，不管是AND或者OR或者NOT操作，它们的返回结果都还是
一个规格书，只是逻辑更复杂了而已，这3个操作符只是提供了对原有规格书的复合作用，
换句话说，规格书对象之间可以进行与或非操作，操作的结果不变，分析到这里，我们就可
以开始修改接口了，如代码清单38-15所示

在规格书接口中增加了与或非的操作，接口修改了，实现类当然也要修改。先全面思考
一下业务，与或非是不可扩展的操作，规格书（也就是规格对象）之间的操作只有这三种方
法，是不需要扩展也不用预留扩展空间的。如此，我们就可以把与或非的实现放到基类中，
那现在的问题变成了怎么在基类中实现与或非。注意看它们的返回值都需要返回规格书类
型，很明显，我们在这里要用到递归调用了。可以这样理解，基类需要子类提供业务逻辑支
持，因为基类是一个抽象类，不能实例化后返回，我们把简单类图画出来，如图38-3所示

基类对子类产生了依赖，然后进行递归计算，大家一定会发出这样的疑问：父类怎么可
能依赖子类，这还是面向接口编程吗？想想看，我们提出面向接口编程的目的是什么？是为
了适应变化，拥抱变化，对于不可能发生变化的部分为什么不能固化呢？与或非操作符号还
会增加修改吗？规格书对象之间的操作还有其他吗？思考清楚这些问题后，答案就迎刃而解了

注意：父类依赖子类的情景只有在非常明确不会发生变化的场景中存在，它不具备扩展
性，是一种固化而不可变化的结构

可能大家有很多的疑问，我们先来分析代码，代码分析完毕估计能解决你大部分的疑
问。规格书接口如代码清单38-15所示，不再赘述。我们来看组合规格书
（CompositeSpecification），它是一个抽象类，实现了与或非的操作，如代码清单38-16所示

候选对象是否满足条件是由isSatisfiedBy方法决定的，它代表的是一个判断逻辑，由各
个实现类实现。三个与或非操作在抽象类中实现，它是通过直接new了一个子类，如此设计
非常符合单一职责原则，每个子类都有一个独立的职责，要么完成“与”操作，要么完
成“或”操作，要么完成“非”操作。我们先来看“与”操作规格书，如代码清单38-17所示

这三个规格书都是不发生变化的，只要使用该框架，三个规格书都要实现的，而且代码
基本上是雷同的，所以才有了父类依赖子类的设计，否则是严禁出现父类依赖子类的情况
的。大家再仔细看看这三个规格书和组合规格书，代码很简单，但也很巧妙，它跳出了我们
面向对象设计的思维，不变部分使用一种固化方式实现

姓名相同、年龄大于基准年龄、Like格式等规格书都有少许改变，把实现接口变为继承
基类，我们以名字相等规格书为例，如代码清单38-20所示

到此为止我们的LINQ已经完成了很大一部分了，SQL语句中的where后面部分已经可以
解析了，完全可以再增加年龄相等的规格书、姓名字数规格书等，你在SQL中使用过的条件
在这里都能实现了。功臣还是依赖于三个与或非规格书，有了它们三个栋梁才能组合出一个
精彩的条件查询世界

最佳实践

详见：specification2

我们在例子中多次提到规格两个字，该实现模式就叫做规格模式（Specification
Pattern），它不属于23个设计模式，它是其中一个模式的扩展，是哪个模式呢？

我们用全局的观点思考一下，基类代表的是所有的规格书，它的目的是描述一个完整
的、可组合的规格书，它代表的是一个整体，其下的And规格书、Or规格书、Not规格书、年
龄大于基准年龄规格书等都是一个真实的实现，也就是一个局部，现在我们又回到了整体和
部分的关系了，那这是什么模式？对，组合模式，它是组合模式的一种特殊应用，我们来看
它的通用类图，如图38-5所示

以上一个接口、一个抽象类、3个实现类只要在适用规格模式的地方都完全相同，不用
做任何的修改，大家闭着眼照抄就成，要修改的是下面的规格书——业务规格书，如代码清
单38-27所示

规格模式已经是一个非常具体的应用框架了（相对于23个设计模式），大家遇到类似多
个对象中筛选查找，或者业务规则不适于放在任何已有实体或值对象中，而且规则的变化和
组合会掩盖那些领域对象的基本含义，或者是想自己编写一个类似LINQ的语言工具的时候
就可以照搬这部分代码，只要实现自己的逻辑规格书即可

#### 对象池模式

详见：objectPool




#### 雇工模式

详见：servant





#### 黑板模式

详见：blackboard





#### 空对象模式

详见：nullObject







